# 矢量地图动画切换方案

## 文档概述

### 文档目标
设计一套通用的地图动画系统，支持多种交互场景的平滑过渡效果，提升用户体验。

### 核心场景
1. **页面初始化动画**：页面加载时的"高空伪飞入"动画，从大洲视图切入到初始化区域省份视图
2. **远距离地址切换**：行政区域搜索切换、GPS定位反向解析后的区域切换（GPS定位功能已实现，参考 [16-GPS定位功能.md](./16-GPS定位功能.md)）
3. **2D/3D模式切换**：地图视图模式之间的平滑过渡
4. **扩展场景**：为未来可能的动画需求预留接口

### 技术基础
- Google Maps JavaScript API Vector Map（矢量地图）
- WebGL 渲染引擎
- `map.moveCamera()` 方法（原子化更新 camera 参数）

---

## 架构设计

### 分层架构

```
┌─────────────────────────────────────────┐
│  业务场景适配层                          │
│  (行政区域切换、GPS定位、模式切换)        │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│  动画策略层                              │
│  (Fly-To策略、2D/3D切换策略等)           │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│  动画引擎层                              │
│  (requestAnimationFrame、缓动函数、插值)  │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│  Google Maps API 层                     │
│  (moveCamera、getCenter、getZoom等)     │
└─────────────────────────────────────────┘
```

### 模块划分

1. **动画引擎核心** (`lib/mapAnimationEngine.ts`)
   - **⭐ 推荐方案**：集成第三方动画库（Tween.js 或 GSAP）
     - 使用第三方库处理 `requestAnimationFrame` 循环
     - 利用第三方库的缓动函数库（easeInOut、easeIn、easeOut 等）
     - 在 `onUpdate` 回调中调用 `map.moveCamera` 更新地图
     - **这是目前最主流、最丝滑的做法**
   - **备选方案**：手写动画循环
     - 处理 `requestAnimationFrame` 循环
     - 提供基础缓动函数库（easeInOut、easeIn、easeOut 等）
     - 数值插值计算（线性、球面几何等）
   - 动画状态管理（进行中、可中断、完成回调）

2. **动画策略接口** (`lib/mapAnimationStrategies.ts`)
   - 定义策略接口（`AnimationStrategy`）
   - 实现具体策略：
     - `FlyToStrategy`：远距离切换的抛物线动画
     - `ModeSwitchStrategy`：2D/3D 模式切换动画
     - `PanStrategy`：近距离平移动画（可选）

3. **React Hook 封装** (`hooks/useMapAnimation.ts`)
   - 提供业务层调用的 React Hook
   - 管理动画生命周期
   - 暴露简洁的 API（`flyTo`、`switchMode` 等）

4. **类型定义** (`types/animation.ts`)
   - 动画配置类型
   - 策略参数类型
   - 回调函数类型

---

## 核心 API 设计

### useMapAnimation Hook

```typescript
interface UseMapAnimationOptions {
  map: google.maps.Map | null;
  defaultDuration?: number;        // 默认动画时长（毫秒）
  defaultEasing?: EasingFunction;  // 默认缓动函数
  onAnimationStart?: () => void;   // 动画开始回调
  onAnimationComplete?: () => void; // 动画完成回调
  onAnimationCancel?: () => void;   // 动画取消回调
}

interface FlyToOptions {
  target: {
    center: google.maps.LatLng | google.maps.LatLngLiteral;
    zoom?: number;
    // 如果提供省份信息，将自动计算合适的zoom以显示省份全景
    province?: {
      country: string;
      province: string;
    };
  };
  duration?: number;
  easing?: EasingFunction;
  strategy?: 'parabolic' | 'linear'; // 动画策略
  source?: 'region-search' | 'gps-location'; // 触发来源，用于特殊处理
  onComplete?: () => void;
}

interface ModeSwitchOptions {
  targetMode: '2d' | '3d';
  duration?: number;
  easing?: EasingFunction;
  preserveCenter?: boolean;        // 是否保持当前中心点
  onComplete?: () => void;
}

interface InitializeOptions {
  target: {
    center: google.maps.LatLng | google.maps.LatLngLiteral;
    province: {
      country: string;
      province: string;
    };
  };
  duration?: number;
  easing?: EasingFunction;
  onComplete?: () => void;
}

function useMapAnimation(options: UseMapAnimationOptions) {
  return {
    // 页面初始化动画（高空伪飞入）
    initialize: (options: InitializeOptions) => Promise<void>;
    
    // 远距离地址切换
    flyTo: (options: FlyToOptions) => Promise<void>;
    
    // 2D/3D 模式切换
    switchMode: (options: ModeSwitchOptions) => Promise<void>;
    
    // 取消当前动画
    cancel: () => void;
    
    // 检查动画状态
    isAnimating: boolean;
  };
}
```

---

## 场景实现方案

### 场景 1：页面初始化动画（高空伪飞入）

#### 需求分析
- **触发场景**：页面首次加载时，地图初始化完成后
- **技术挑战**：
  - 需要从大洲级别的视图（zoom 很小，tilt 0）平滑过渡到省份视图（zoom 适合省份全景，tilt 45）
  - 同时变化 center、zoom、tilt 三个参数
  - 需要计算大洲级别的初始视图中心点
- **用户体验目标**：
  - 提供视觉冲击力，增强沉浸感
  - 让用户清楚看到从全局到局部的过渡
  - 最终停留在3D视角的省份全景视图

#### 实现策略：多参数同步动画（大洲 → 省份）

**核心思路**：
1. 初始状态：大洲视图（zoom 3-4，tilt 0，center 为大洲中心或目标区域的大致中心）
2. 目标状态：省份视图（zoom 根据省份边界计算，tilt 45，center 为省份中心）
3. 同时动画化 center、zoom、tilt 三个参数
4. 使用缓动函数确保平滑过渡

**⭐ 推荐实现方式**：
- **强烈推荐使用第三方动画库**（Tween.js 或 GSAP）来处理数值插值
- 在 `onUpdate` 回调中调用 `map.moveCamera` 更新地图视图
- 这是目前最主流、最丝滑的做法，能够提供更自然、更流畅的动画效果

**伪代码示例**：

```typescript
class InitializeStrategy implements AnimationStrategy {
  async animate(
    map: google.maps.Map,
    target: { 
      center: LatLng,
      province: { country: string; province: string }
    },
    options: AnimationOptions
  ): Promise<void> {
    // 1. 计算初始状态（大洲视图）
    const continentCenter = this.calculateContinentCenter(target.province.country);
    const continentZoom = this.getContinentZoom(target.province.country);
    const startTilt = 0;
    
    // 2. 计算目标状态（省份视图）
    const provinceCenter = target.center;
    const provinceZoom = await this.calculateProvinceZoom(
      target.province.country,
      target.province.province
    );
    const targetTilt = 45; // 3D视角
    
    // 3. 设置初始状态（立即设置，不动画）
    map.moveCamera({
      center: continentCenter,
      zoom: continentZoom,
      tilt: startTilt,
      heading: 0
    });
    
    // 4. 等待一帧，确保初始状态已应用
    await new Promise(resolve => requestAnimationFrame(resolve));
    
    // 5. 执行动画：从大洲视图切入到省份视图
    const duration = options.duration || 2500; // 默认2.5秒
    
    return new Promise((resolve) => {
      let startTime: number | null = null;
      
      const animate = (timestamp: number) => {
        if (!startTime) startTime = timestamp;
        const progress = Math.min((timestamp - startTime) / duration, 1);
        
        // 应用缓动函数（使用 easeInOutCubic 提供平滑的加速和减速）
        const eased = easingFunction(progress);
        
        // 同步插值所有参数
        const currentCenter = this.interpolateLatLng(
          continentCenter,
          provinceCenter,
          eased
        );
        const currentZoom = continentZoom + (provinceZoom - continentZoom) * eased;
        const currentTilt = startTilt + (targetTilt - startTilt) * eased;
        
        // 原子化更新所有参数
        map.moveCamera({
          center: currentCenter,
          zoom: currentZoom,
          tilt: currentTilt,
          heading: 0 // 保持正北向上
        });
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          resolve();
        }
      };
      
      requestAnimationFrame(animate);
    });
  }
  
  // 计算大洲中心点（根据国家位置估算）
  private calculateContinentCenter(country: string): LatLng {
    // 根据国家代码返回大洲的大致中心点
    const continentCenters: Record<string, LatLng> = {
      // 亚洲
      'CHN': { lat: 35.0, lng: 105.0 },  // 中国 → 亚洲中部
      'IDN': { lat: -2.0, lng: 118.0 },  // 印尼 → 东南亚
      'MYS': { lat: 4.0, lng: 102.0 },   // 马来西亚 → 东南亚
      'THA': { lat: 15.0, lng: 100.0 },  // 泰国 → 东南亚
      'VNM': { lat: 16.0, lng: 108.0 },  // 越南 → 东南亚
      // 可以添加更多国家
    };
    
    // 如果找不到精确匹配，使用国家的大致中心点并放大zoom
    return continentCenters[country] || { lat: 20.0, lng: 100.0 }; // 默认：东南亚
  }
  
  // 获取大洲级别的zoom
  private getContinentZoom(country: string): number {
    // 根据国家所在大洲返回合适的初始zoom
    const continentZooms: Record<string, number> = {
      'CHN': 4,  // 中国：亚洲较大，zoom稍大
      'IDN': 4,  // 印尼：东南亚
      'MYS': 5,  // 马来西亚：较小国家，zoom稍大
      'THA': 5,  // 泰国：中等国家
      'VNM': 5,  // 越南：中等国家
    };
    
    return continentZooms[country] || 4; // 默认 zoom 4
  }
  
  // 根据省份边界计算合适的 zoom 级别以显示省份全景
  private async calculateProvinceZoom(
    country: string,
    province: string
  ): Promise<number> {
    // 获取省份边界数据
    // 注意：可以使用现有的 regionData.ts 中的 getAdministrativeRegion 函数
    const provinceRegion = await getAdministrativeRegion({ country, province, district: '' });
    
    if (!provinceRegion || !provinceRegion.boundary || provinceRegion.boundary.length === 0) {
      // 如果无法获取边界，使用默认 zoom（根据国家大小调整）
      return this.getDefaultProvinceZoom(country);
    }
    
    // 计算边界框：遍历所有边界点，找到最小/最大经纬度
    let minLat = Infinity, maxLat = -Infinity;
    let minLng = Infinity, maxLng = -Infinity;
    
    for (const point of provinceRegion.boundary) {
      minLat = Math.min(minLat, point.lat);
      maxLat = Math.max(maxLat, point.lat);
      minLng = Math.min(minLng, point.lng);
      maxLng = Math.max(maxLng, point.lng);
    }
    
    // 计算边界框的宽度和高度（度）
    const latDiff = maxLat - minLat;
    const lngDiff = maxLng - minLng;
    
    // 使用 Google Maps 的 fitBounds 逻辑计算合适的 zoom
    // 简化版本：根据边界框大小估算 zoom
    const maxDiff = Math.max(latDiff, lngDiff);
    
    // 经验公式：根据边界框大小计算 zoom
    // 这个公式需要根据实际测试调整
    if (maxDiff > 10) return 5;      // 非常大的省份（如俄罗斯的州）
    if (maxDiff > 5) return 6;       // 大省份
    if (maxDiff > 2) return 7;       // 中等省份
    if (maxDiff > 1) return 8;       // 小省份
    if (maxDiff > 0.5) return 9;     // 更小的省份
    return 10;                        // 默认
  }
  
  // 根据国家获取默认省份 zoom（降级方案）
  private getDefaultProvinceZoom(country: string): number {
    // 根据国家大小提供合理的默认值
    const countryDefaults: Record<string, number> = {
      'CHN': 7,  // 中国：省份较大
      'USA': 6,  // 美国：州较大
      'IDN': 8,  // 印尼：省份中等
      'MYS': 8,  // 马来西亚：州中等
      'THA': 8,  // 泰国：府中等
      'VNM': 8,  // 越南：省中等
    };
    return countryDefaults[country] || 8; // 默认 8
  }
}
```

#### 集成点
- **MapWorkspace 组件**：在地图初始化完成后，调用 `initialize` 方法
- **初始化时机**：确保在地图实例创建完成、但数据加载之前执行
- **与数据加载的协调**：初始化动画完成后，再加载数据和图层（遵循数据加载约束）

---

### 场景 2：远距离地址切换（Fly-To 动画）

#### 需求分析
- **触发场景**：
  - 用户通过地图设置搜索行政区域
  - GPS 定位后反向解析到行政区域（**已实现**，参考 [16-GPS定位功能.md](./16-GPS定位功能.md)）
- **技术挑战**：
  - 跨越大距离时，直接 `panTo` 会显得漫长且可能加载无效瓦片
  - 需要类似 Google Earth 的"飞行"效果
- **特殊需求**：
  1. **所选区域全景显示**：切换完成后，最终 zoom 需要能够以所选区域中心为核心，显示所选区域（district级别）的全景
  2. **GPS 定位特殊动画**：GPS 定位触发的切换需要先滑动到GPS定位位置的同时 zoom in 到街道级别（15-16），然后 zoom out 并移动到所选区域中心，最终显示所选区域的全景
  3. **数据加载约束**：动画完成后才加载其他数据和各个图层

#### 实现策略：抛物线 Fly-To（支持所选区域全景和 GPS 特殊序列）

**核心思路**：
1. 先拉高视角（Zoom Out）→ 移动位置（Pan）→ 再拉近视角（Zoom In）
2. 使用抛物线曲线控制 Zoom 变化
3. 经纬度插值需要考虑球面几何
4. **所选区域全景计算**：根据所选区域（district）边界自动计算合适的 zoom 级别，以区域中心为核心显示区域全景
5. **GPS 定位特殊序列**：先滑动到GPS定位位置的同时 zoom in 到街道级别，再 zoom out 并移动到所选区域中心，最终显示所选区域的全景

**⭐ 推荐实现方式**：
- **强烈推荐使用第三方动画库**（Tween.js 或 GSAP）来处理数值插值
- 在 `onUpdate` 回调中调用 `map.moveCamera` 更新地图视图
- 这是目前最主流、最丝滑的做法，特别适合复杂的抛物线动画和球面几何插值

**伪代码示例**：

```typescript
class FlyToStrategy implements AnimationStrategy {
  async animate(
    map: google.maps.Map,
    target: { 
      center: LatLng, 
      zoom?: number,
      province?: { country: string; province: string }
    },
    options: AnimationOptions & { source?: 'region-search' | 'gps-location' }
  ): Promise<void> {
    const startCenter = map.getCenter();
    const startZoom = map.getZoom() || 10;
    
    // 计算目标 zoom
    let targetZoom: number;
    if (target.region) {
      // 根据所选区域（district）边界计算合适的 zoom 以显示区域全景
      targetZoom = await this.calculateRegionZoom(
        target.region.country,
        target.region.province,
        target.region.district
      );
    } else if (target.province) {
      // 降级方案：如果没有区域信息，使用省份边界计算
      targetZoom = await this.calculateProvinceZoom(
        target.province.country,
        target.province.province
      );
    } else {
      targetZoom = target.zoom || startZoom;
    }
    
    // GPS 定位特殊处理：两阶段动画
    if (options.source === 'gps-location') {
      return this.animateGPSSequence(map, target, targetZoom, options);
    }
    
    // 标准抛物线 Fly-To
    const distance = this.calculateDistance(startCenter, target.center);
    const duration = options.duration || this.adaptiveDuration(distance);
    
    // 计算抛物线最高点（Zoom 最小值）
    const maxZoomOut = Math.min(startZoom, targetZoom) - 2;
    
    return new Promise((resolve) => {
      let startTime: number | null = null;
      
      const animate = (timestamp: number) => {
        if (!startTime) startTime = timestamp;
        const progress = Math.min((timestamp - startTime) / duration, 1);
        
        // 应用缓动函数
        const eased = easingFunction(progress);
        
        // 经纬度插值（球面几何）
        const currentCenter = this.interpolateLatLng(
          startCenter,
          target.center,
          eased
        );
        
        // 抛物线 Zoom 曲线
        // 在进度 50% 时达到最大 Zoom Out
        const zoomArc = Math.sin(progress * Math.PI) * 2;
        const currentZoom = startZoom + 
          (targetZoom - startZoom) * eased - 
          zoomArc;
        
        // 更新地图
        map.moveCamera({
          center: currentCenter,
          zoom: currentZoom
        });
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          resolve();
        }
      };
      
      requestAnimationFrame(animate);
    });
  }
  
  // GPS 定位特殊动画序列：先滑动到GPS位置并zoom in到街道级别，再zoom out并移动到所选区域中心，最终显示所选区域全景
  private async animateGPSSequence(
    map: google.maps.Map,
    target: { center: LatLng, region?: { country: string; province: string; district: string } },
    regionZoom: number,
    options: AnimationOptions
  ): Promise<void> {
    const startCenter = map.getCenter();
    const startZoom = map.getZoom() || 10;
    const streetZoom = 15; // 街道级别 zoom
    
    // 获取所选区域中心点（如果提供了区域信息）
    let regionCenter: LatLng;
    if (target.region) {
      const center = await getRegionCenter(target.region);
      regionCenter = center || target.center;
    } else {
      regionCenter = target.center;
    }
    
    // 第一阶段：同时滑动到GPS定位位置并zoom in到街道级别
    // 使用抛物线动画，在移动位置的同时进行zoom in
    await this.animateFlyToWithZoom(map, startCenter, target.center, startZoom, streetZoom, 1000);
    
    // 短暂停留（可选，增强用户体验）
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // 第二阶段：zoom out并移动到所选区域中心，最终显示所选区域全景
    await this.animateFlyToWithZoom(map, target.center, regionCenter, streetZoom, regionZoom, 1200);
  }
  
  // 辅助方法：同时进行位置移动和zoom变化（抛物线动画）
  private async animateFlyToWithZoom(
    map: google.maps.Map,
    startCenter: LatLng,
    endCenter: LatLng,
    startZoom: number,
    endZoom: number,
    duration: number
  ): Promise<void> {
    return new Promise((resolve) => {
      let startTime: number | null = null;
      
      const animate = (timestamp: number) => {
        if (!startTime) startTime = timestamp;
        const progress = Math.min((timestamp - startTime) / duration, 1);
        
        // 应用缓动函数
        const eased = easingFunction(progress);
        
        // 经纬度插值（球面几何）
        const currentCenter = this.interpolateLatLng(startCenter, endCenter, eased);
        
        // Zoom 插值（线性或使用缓动函数）
        const currentZoom = startZoom + (endZoom - startZoom) * eased;
        
        // 原子化更新位置和zoom
        map.moveCamera({
          center: currentCenter,
          zoom: currentZoom
        });
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          resolve();
        }
      };
      
      requestAnimationFrame(animate);
    });
  }
  
  // 辅助方法：执行 zoom 动画
  private async animateZoom(
    map: google.maps.Map,
    startCenter: LatLng,
    endCenter: LatLng,
    startZoom: number,
    endZoom: number,
    duration: number
  ): Promise<void> {
    return new Promise((resolve) => {
      let startTime: number | null = null;
      
      const animate = (timestamp: number) => {
        if (!startTime) startTime = timestamp;
        const progress = Math.min((timestamp - startTime) / duration, 1);
        const eased = easingFunction(progress);
        
        const currentCenter = this.interpolateLatLng(startCenter, endCenter, eased);
        const currentZoom = startZoom + (endZoom - startZoom) * eased;
        
        map.moveCamera({
          center: currentCenter,
          zoom: currentZoom
        });
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          resolve();
        }
      };
      
      requestAnimationFrame(animate);
    });
  }
  
  // 根据省份边界计算合适的 zoom 级别以显示省份全景
  private async calculateProvinceZoom(
    country: string,
    province: string
  ): Promise<number> {
    // 获取省份边界数据
    // 注意：可以使用现有的 regionData.ts 中的 getAdministrativeRegion 函数
    // 或者使用 Google Maps Geometry 库的 LatLngBounds
    const provinceRegion = await getAdministrativeRegion({ country, province, district: '' });
    
    if (!provinceRegion || !provinceRegion.boundary || provinceRegion.boundary.length === 0) {
      // 如果无法获取边界，使用默认 zoom（根据国家大小调整）
      return this.getDefaultProvinceZoom(country);
    }
    
    // 计算边界框：遍历所有边界点，找到最小/最大经纬度
    let minLat = Infinity, maxLat = -Infinity;
    let minLng = Infinity, maxLng = -Infinity;
    
    for (const point of provinceRegion.boundary) {
      minLat = Math.min(minLat, point.lat);
      maxLat = Math.max(maxLat, point.lat);
      minLng = Math.min(minLng, point.lng);
      maxLng = Math.max(maxLng, point.lng);
    }
    
    // 计算边界框的宽度和高度（度）
    const latDiff = maxLat - minLat;
    const lngDiff = maxLng - minLng;
    
    // 使用 Google Maps 的 fitBounds 逻辑计算合适的 zoom
    // 简化版本：根据边界框大小估算 zoom
    const maxDiff = Math.max(latDiff, lngDiff);
    
    // 经验公式：根据边界框大小计算 zoom
    // 这个公式需要根据实际测试调整
    if (maxDiff > 10) return 5;      // 非常大的省份（如俄罗斯的州）
    if (maxDiff > 5) return 6;       // 大省份
    if (maxDiff > 2) return 7;       // 中等省份
    if (maxDiff > 1) return 8;       // 小省份
    if (maxDiff > 0.5) return 9;     // 更小的省份
    return 10;                        // 默认
    
    // 可选：使用 Google Maps LatLngBounds 的 fitBounds 方法
    // const bounds = new google.maps.LatLngBounds();
    // provinceRegion.boundary.forEach(point => bounds.extend(point));
    // const zoom = map.getBoundsZoomLevel(bounds); // 需要自定义实现
  }
  
  // 根据国家获取默认省份 zoom（降级方案）
  private getDefaultProvinceZoom(country: string): number {
    // 根据国家大小提供合理的默认值
    const countryDefaults: Record<string, number> = {
      'CHN': 7,  // 中国：省份较大
      'USA': 6,  // 美国：州较大
      'IDN': 8,  // 印尼：省份中等
      'MYS': 8,  // 马来西亚：州中等
      'THA': 8,  // 泰国：府中等
      'VNM': 8,  // 越南：省中等
    };
    return countryDefaults[country] || 8; // 默认 8
  }
  
  // 球面几何插值（可使用 Google Maps Geometry 库）
  private interpolateLatLng(
    start: LatLng,
    end: LatLng,
    t: number
  ): LatLng {
    // 简单线性插值（适用于短距离）
    // 长距离建议使用 Google Maps Geometry 库的球面插值
    return {
      lat: start.lat() + (end.lat() - start.lat()) * t,
      lng: start.lng() + (end.lng() - start.lng()) * t
    };
  }
  
  // 根据距离自适应动画时长
  private adaptiveDuration(distance: number): number {
    // 距离越远，动画时长越长（但有上限）
    const baseDuration = 1000; // 1秒基础时长
    const distanceFactor = Math.min(distance / 1000, 5); // 每1000km增加，最多5倍
    return baseDuration * (1 + distanceFactor);
  }
}
```

#### 集成点
- **行政区域搜索**：`MapWorkspace` 组件中，当用户选择新区域时调用 `flyTo`，传入完整的区域信息（country, province, district）以计算所选区域全景 zoom，最终以所选区域中心为核心显示区域全景
- **GPS 定位**：
  - GPS定位和反向解析功能**已实现**（参考 [16-GPS定位功能.md](./16-GPS定位功能.md)）
  - 在 `gpsLocation.ts` 的定位成功回调中，调用 `flyTo`，设置 `source: 'gps-location'` 触发特殊动画序列
  - 使用已实现的 `reverseGeocode` 函数获取行政区域信息
  - 传入完整的区域信息（country, province, district），通过特殊动画序列（先zoom in到街道级别，再zoom out并移动到所选区域中心），最终以所选区域中心为核心显示区域全景

#### 数据加载约束

**重要约束**：动画完成后才加载数据和图层

所有数据加载和图层渲染必须在动画完成后执行，确保：
1. 动画流畅性：避免数据加载过程中的地图更新干扰动画
2. 性能优化：减少动画期间的资源消耗
3. 用户体验：先看到平滑的动画，再看到数据填充

**实现方式**：
- 在 `flyTo` 的 `onComplete` 回调中触发数据加载
- 在动画进行期间，暂停所有图层更新和数据请求

---

### 场景 3：2D/3D 模式切换

#### 需求分析
- **触发场景**：用户点击 2D/3D 切换按钮
- **技术挑战**：
  - 需要同时动画化 `tilt`、`heading`、`zoom`
  - 避免突兀切换导致用户迷失方向感
  - 需要平滑的往返切换（2D → 3D → 2D）

#### 实现策略：同步多参数动画

**核心思路**：
1. 同时动画化 `tilt`、`heading`、`zoom` 三个参数
2. 使用相同的缓动函数确保同步
3. 进入 3D 时稍微放大（+1 或 +2），增强沉浸感

**⭐ 推荐实现方式**：
- **强烈推荐使用第三方动画库**（Tween.js 或 GSAP）来处理数值插值
- 在 `onUpdate` 回调中调用 `map.moveCamera` 更新地图视图
- 这是目前最主流、最丝滑的做法，能够确保多个参数同步动画的流畅性

**伪代码示例**：

```typescript
class ModeSwitchStrategy implements AnimationStrategy {
  async animate(
    map: google.maps.Map,
    targetMode: '2d' | '3d',
    options: AnimationOptions
  ): Promise<void> {
    const currentConfig = this.getCurrentCameraConfig(map);
    const targetConfig = this.getTargetConfig(targetMode, currentConfig);
    
    const duration = options.duration || 1500; // 默认1.5秒
    
    return new Promise((resolve) => {
      let startTime: number | null = null;
      
      const animate = (timestamp: number) => {
        if (!startTime) startTime = timestamp;
        const progress = Math.min((timestamp - startTime) / duration, 1);
        
        // 应用缓动函数
        const eased = easingFunction(progress);
        
        // 同步插值所有参数
        const currentTilt = this.interpolate(
          currentConfig.tilt,
          targetConfig.tilt,
          eased
        );
        const currentHeading = this.interpolate(
          currentConfig.heading,
          targetConfig.heading,
          eased
        );
        const currentZoom = this.interpolate(
          currentConfig.zoom,
          targetConfig.zoom,
          eased
        );
        
        // 原子化更新所有参数
        map.moveCamera({
          tilt: currentTilt,
          heading: currentHeading,
          zoom: currentZoom,
          // 如果 preserveCenter 为 false，可以同时改变 center
        });
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          resolve();
        }
      };
      
      requestAnimationFrame(animate);
    });
  }
  
  private getTargetConfig(
    mode: '2d' | '3d',
    current: CameraConfig
  ): CameraConfig {
    if (mode === '3d') {
      // 进入 3D 模式
      return {
        tilt: 45,                    // 倾斜 45 度
        heading: 0,                  // 正北向上
        zoom: current.zoom + 1,      // 稍微放大
        center: current.center       // 保持中心点
      };
    } else {
      // 回到 2D 模式
      return {
        tilt: 0,                     // 俯视
        heading: 0,                   // 正北向上
        zoom: current.zoom - 1,      // 稍微缩小（补偿之前的放大）
        center: current.center
      };
    }
  }
}
```

#### 集成点
- **控制面板**：`ControlPanel` 组件中，2D/3D 切换按钮调用 `switchMode`
- **地图配置**：与 `mapModeStyles.ts` 配置协同，确保目标参数一致

---

## 执行流程规范

### 概述

为确保动画系统的稳定性、性能和用户体验，所有动画场景必须遵循统一的执行流程规范。本规范明确了数据准备、动画执行、数据加载等关键步骤的顺序和时机。

### 核心原则

1. **动画优先原则**：动画执行期间，避免任何可能影响动画流畅性的操作
2. **并行优化原则**：数据准备可以在动画期间并行进行，但不加载到地图
3. **数据验证原则**：动画完成后，先验证数据完备性，再执行数据加载和地图渲染
4. **状态管理原则**：明确每个阶段的状态，便于错误处理和用户反馈

---

### 场景 1：页面初始化动画

#### 执行流程

```
步骤1：获取初始化区域信息
├─ 输入：默认区域配置或用户偏好
├─ 操作：同步/快速获取区域基本信息（country, province, district）
├─ 输出：Region 对象
└─ 耗时：< 100ms（通常为同步操作）

步骤2：设置地图初始状态
├─ 操作：立即设置地图为大洲视图（zoom 3-4, tilt 0）
├─ 目的：为动画提供起始状态
└─ 耗时：< 50ms

步骤3：执行动画效果
├─ 操作：从大洲视图切入到省份视图（zoom 根据省份计算, tilt 45）
├─ 时长：2.5秒（默认）
├─ 状态：isAnimating = true
└─ 期间：禁止任何地图操作和数据加载

步骤4：【并行】数据准备（可选优化）
├─ 操作：在动画期间并行生成/获取数据
│   ├─ 生成 Mock 天气数据
│   ├─ 计算风险事件
│   └─ 准备图层数据
├─ 状态：数据准备中，但不加载到地图
└─ 注意：如果数据准备完成，等待动画完成后再加载

步骤5：动画完成后 - 验证数据完备性
├─ 操作：检查数据准备状态
│   ├─ 如果数据已准备好：直接进入步骤6
│   └─ 如果数据未准备好：等待数据准备完成
├─ 验证项：
│   ├─ 区域数据完整性
│   ├─ 天气数据可用性
│   └─ 风险计算结果有效性
└─ 超时处理：如果数据准备超时（> 5秒），显示错误提示

步骤6：加载地图图层
├─ 操作：将准备好的数据加载到地图
│   ├─ 更新行政区域边界图层
│   ├─ 更新降雨量热力图图层
│   ├─ 更新风险事件标记图层
│   └─ 更新数据面板
├─ 状态：isLoadingData = false
└─ 完成：用户看到完整的地图和数据
```

#### 伪代码示例

```typescript
async function handlePageInitialization(initialRegion: Region) {
  // 步骤1：获取初始化区域信息
  const region = await getInitialRegion(initialRegion);
  
  // 步骤2：设置地图初始状态
  const continentCenter = calculateContinentCenter(region.country);
  map.moveCamera({
    center: continentCenter,
    zoom: 4,
    tilt: 0
  });
  
  // 步骤3：执行动画效果
  const animationPromise = initialize({
    target: {
      center: region.center,
      province: { country: region.country, province: region.province }
    },
    duration: 2500,
    onComplete: async () => {
      // 步骤5：验证数据完备性
      await waitForDataReady(dataPreparationPromise);
      
      // 验证数据完备性
      if (!validateDataCompleteness(preparedData)) {
        console.error('Data preparation incomplete');
        showErrorToast('数据加载失败，请刷新页面重试');
        return;
      }
      
      // 步骤6：加载地图图层
      await loadDataToMap(preparedData);
      await updateAllLayers(region);
    }
  });
  
  // 步骤4：并行数据准备
  const dataPreparationPromise = prepareData(region);
  
  // 等待动画完成（数据准备可能已经完成）
  await animationPromise;
}
```

---

### 场景 2：远距离地址切换

#### 执行流程

```
步骤1：用户触发操作
├─ 方式A：用户手动选择区域
│   └─ 触发：用户在地图设置中选择新的行政区域
├─ 方式B：用户点击GPS定位
│   └─ 触发：用户点击GPS定位按钮
└─ 状态：isLoadingData = true（禁用相关UI）

步骤2：获取目标区域信息
├─ 方式A：直接获取选择区域
│   ├─ 输入：用户选择的 Region 对象
│   └─ 操作：验证区域有效性，获取区域中心点
├─ 方式B：反向解析GPS定位所在区域（**已实现**，参考 [16-GPS定位功能.md](./16-GPS定位功能.md)）
│   ├─ 输入：GPS坐标（lat, lng）
│   ├─ 操作：调用已实现的 `reverseGeocode` 函数（`lib/gpsLocation.ts`）
│   │   ├─ 使用双重验证机制：地理预过滤 + 语义匹配
│   │   └─ 返回匹配的 AdministrativeRegion 对象
│   └─ 输出：Region 对象（country, province, district）
└─ 耗时：GPS定位可能需要 1-3秒（异步操作）

步骤3：计算目标视图参数
├─ 操作：
│   ├─ 计算目标中心点（center）
│   ├─ 计算目标 zoom（根据省份边界，显示省份全景）
│   └─ 确定动画策略（parabolic 或 GPS特殊序列）
├─ 输出：FlyToOptions 配置
└─ 耗时：< 50ms

步骤4：执行动画效果
├─ 操作：执行 Fly-To 动画
│   ├─ 标准场景：抛物线动画（1-2.5秒，根据距离自适应）
│   └─ GPS场景：两阶段动画（先滑动+zoom in，再zoom out）
├─ 时长：1-2.5秒（根据距离和场景）
├─ 状态：isAnimating = true
└─ 期间：禁止任何地图操作和数据加载

步骤5：【并行】数据准备
├─ 操作：在动画期间并行生成/获取数据
│   ├─ 生成新区域的 Mock 天气数据
│   ├─ 计算新区域的风险事件
│   ├─ 准备新区域的图层数据
│   └─ 预加载边界 GeoJSON 数据
├─ 状态：数据准备中，但不加载到地图
├─ 优化：如果数据准备完成，等待动画完成后再加载
└─ 注意：如果数据准备失败，记录错误但不中断动画

步骤6：动画完成后 - 验证数据完备性
├─ 操作：检查数据准备状态
│   ├─ 如果数据已准备好：直接进入步骤7
│   └─ 如果数据未准备好：等待数据准备完成（最多等待2秒）
├─ 验证项：
│   ├─ 区域数据完整性（边界、中心点）
│   ├─ 天气数据可用性（时间范围、数据类型）
│   ├─ 风险计算结果有效性（产品规则、计算逻辑）
│   └─ 图层数据完整性（GeoJSON、标记点）
├─ 超时处理：
│   ├─ 如果数据准备超时：使用缓存数据或显示加载中状态
│   └─ 如果数据准备失败：显示错误提示，回退到上一个区域
└─ 状态：isAnimating = false

步骤7：加载地图图层
├─ 操作：将准备好的数据加载到地图
│   ├─ 清除旧区域的图层数据
│   ├─ 更新行政区域边界图层（新区域）
│   ├─ 更新降雨量热力图图层（新区域数据）
│   ├─ 更新风险事件标记图层（新区域风险事件）
│   └─ 更新数据面板（新区域统计数据）
├─ 状态：isLoadingData = false
└─ 完成：用户看到新区域的完整地图和数据
```

#### 伪代码示例

```typescript
// 方式A：用户手动选择区域
async function handleRegionChange(selectedRegion: Region) {
  try {
    // 步骤1：用户触发操作
    setIsLoadingData(true);
    
    // 步骤2：获取目标区域信息
    const region = await validateAndGetRegion(selectedRegion);
    const regionCenter = await getRegionCenter(region);
    
    // 步骤3：计算目标视图参数
    const flyToOptions = {
      target: {
        center: regionCenter,
        region: {
          country: region.country,
          province: region.province,
          district: region.district
        }
      },
      strategy: 'parabolic' as const,
      source: 'region-search' as const,
      onComplete: async () => {
        // 步骤6：验证数据完备性
        const dataReady = await waitForDataReady(
          dataPreparationPromise,
          { timeout: 2000 }
        );
        
        if (!dataReady || !validateDataCompleteness(preparedData)) {
          console.error('Data preparation failed or incomplete');
          showErrorToast('数据加载失败，已回退到上一个区域');
          // 回退到上一个区域
          await revertToPreviousRegion();
          return;
        }
        
        // 步骤7：加载地图图层
        await clearPreviousLayers();
        await loadDataToMap(preparedData);
        await updateAllLayers(region);
        setIsLoadingData(false);
      }
    };
    
    // 步骤4：执行动画效果
    const animationPromise = flyTo(flyToOptions);
    
    // 步骤5：并行数据准备
    const dataPreparationPromise = prepareData(region).catch(error => {
      console.error('Data preparation error:', error);
      return null; // 返回null表示准备失败
    });
    
    await animationPromise;
  } catch (error) {
    console.error('Region change error:', error);
    setIsLoadingData(false);
    showErrorToast('区域切换失败，请重试');
  }
}

// 方式B：GPS定位
// 注意：GPS定位和反向解析功能已实现（参考 16-GPS定位功能.md）
// 使用 lib/gpsLocation.ts 中的 getCurrentPosition 和 reverseGeocode 函数
async function handleGPSLocation() {
  try {
    // 步骤1：用户触发操作
    setIsLoadingData(true);
    setGPSStatus('locating');
    
    // 步骤2：获取目标区域信息（GPS定位 + 反向解析）
    // 使用已实现的 GPS 定位功能
    const position = await getCurrentPosition(); // 来自 lib/gpsLocation.ts
    const region = await reverseGeocode(        // 来自 lib/gpsLocation.ts
      position.coords.latitude,
      position.coords.longitude
    );
    
    if (!region) {
      throw new Error('Failed to reverse geocode GPS location');
    }
    
    // 步骤3：计算目标视图参数
    const flyToOptions = {
      target: {
        center: {
          lat: position.coords.latitude,
          lng: position.coords.longitude
        },
        region: {
          country: region.country,
          province: region.province,
          district: region.district
        }
      },
      strategy: 'parabolic' as const,
      source: 'gps-location' as const, // 触发GPS特殊动画序列
      onComplete: async () => {
        // 步骤6：验证数据完备性
        const dataReady = await waitForDataReady(
          dataPreparationPromise,
          { timeout: 2000 }
        );
        
        if (!dataReady || !validateDataCompleteness(preparedData)) {
          console.error('Data preparation failed or incomplete');
          showErrorToast('数据加载失败');
          return;
        }
        
        // 步骤7：加载地图图层
        await clearPreviousLayers();
        await loadDataToMap(preparedData);
        await updateAllLayers(region);
        setIsLoadingData(false);
        setGPSStatus('success');
      }
    };
    
    // 步骤4：执行动画效果（GPS特殊序列）
    const animationPromise = flyTo(flyToOptions);
    
    // 步骤5：并行数据准备
    const dataPreparationPromise = prepareData(region).catch(error => {
      console.error('Data preparation error:', error);
      return null;
    });
    
    await animationPromise;
  } catch (error) {
    console.error('GPS location error:', error);
    setIsLoadingData(false);
    setGPSStatus('error');
    showErrorToast('GPS定位失败，请检查定位权限');
  }
}

// 辅助函数：等待数据准备完成
async function waitForDataReady(
  dataPromise: Promise<any>,
  options: { timeout: number } = { timeout: 5000 }
): Promise<boolean> {
  try {
    const result = await Promise.race([
      dataPromise,
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Timeout')), options.timeout)
      )
    ]);
    return result !== null;
  } catch (error) {
    return false;
  }
}

// 辅助函数：验证数据完备性
function validateDataCompleteness(data: any): boolean {
  if (!data) return false;
  
  return (
    data.region !== undefined &&
    data.weatherData !== undefined &&
    data.riskData !== undefined &&
    data.boundaryData !== undefined
  );
}
```

---

### 场景 3：2D/3D 模式切换

#### 执行流程

```
步骤1：用户触发操作
├─ 触发：用户点击 2D/3D 切换按钮
└─ 状态：isAnimating = true（禁用切换按钮）

步骤2：区域和数据无变化
├─ 说明：模式切换不改变区域和数据
├─ 操作：保持当前区域和数据不变
└─ 注意：无需重新获取或生成数据

步骤3：执行动画效果
├─ 操作：同步动画化 tilt、heading、zoom
│   ├─ 2D → 3D：tilt 0→45, zoom +1, heading 保持不变
│   └─ 3D → 2D：tilt 45→0, zoom -1, heading 保持不变
├─ 时长：1.5秒（默认）
└─ 期间：禁止任何地图操作

步骤4：动画完成后 - 更新图层样式
├─ 操作：根据新模式更新图层样式
│   ├─ 更新边界图层样式（strokeWeight, opacity等）
│   ├─ 更新热力图图层样式（fillOpacity等）
│   ├─ 更新标记图层样式（sizeMultiplier, shadow等）
│   └─ 更新地图控制（rotateControl显示/隐藏）
├─ 状态：isAnimating = false
└─ 完成：用户看到新模式下的地图视图
```

#### 伪代码示例

```typescript
async function handleModeSwitch(targetMode: '2d' | '3d') {
  try {
    // 步骤1：用户触发操作
    setIsAnimating(true);
    disableModeSwitchButton();
    
    // 步骤2：区域和数据无变化（无需操作）
    // 当前区域和数据保持不变
    
    // 步骤3：执行动画效果
    await switchMode({
      targetMode,
      duration: 1500,
      preserveCenter: true,
      onComplete: async () => {
        // 步骤4：更新图层样式
        const newStyles = getMapModeStyles(targetMode);
        
        // 更新边界图层样式
        updateBoundaryLayerStyles(newStyles.boundary);
        
        // 更新热力图图层样式
        updateHeatmapLayerStyles(newStyles.heatmap);
        
        // 更新标记图层样式
        updateMarkerLayerStyles(newStyles.markers);
        
        // 更新地图控制
        map.setOptions({
          rotateControl: newStyles.map.rotateControl
        });
        
        setIsAnimating(false);
        enableModeSwitchButton();
      }
    });
  } catch (error) {
    console.error('Mode switch error:', error);
    setIsAnimating(false);
    enableModeSwitchButton();
    showErrorToast('模式切换失败，请重试');
  }
}
```

---

### 数据准备与加载的时机控制

#### 数据准备阶段（可在动画期间并行）

**允许的操作**：
- 生成/计算数据（Mock数据生成、风险计算）
- 获取远程数据（API请求）
- 处理数据（数据转换、格式化）
- 准备图层数据（GeoJSON处理、标记点计算）

**禁止的操作**：
- 直接更新地图图层
- 调用 `map.moveCamera`（除了动画系统）
- 修改地图状态

#### 数据加载阶段（必须在动画完成后）

**执行条件**：
1. 动画已完成（`onComplete` 回调触发）
2. 数据准备完成（验证数据完备性通过）
3. 地图状态稳定（无其他动画进行中）

**执行操作**：
- 清除旧图层数据
- 加载新数据到地图图层
- 更新数据面板
- 触发相关事件通知

---

### 错误处理与回退机制

#### 数据准备失败

**场景**：数据准备超时或失败

**处理策略**：
1. 记录错误日志
2. 如果动画已完成：
   - 使用缓存数据（如果可用）
   - 或显示"数据加载失败"提示
   - 保持当前地图视图不变
3. 如果动画未完成：
   - 等待动画完成
   - 然后执行上述处理

#### 动画中断

**场景**：用户操作中断动画（如快速连续切换区域）

**处理策略**：
1. 立即取消当前动画
2. 取消待执行的数据准备任务
3. 清理动画状态
4. 执行新的动画请求

#### 区域获取失败

**场景**：GPS定位失败或区域解析失败

**处理策略**：
1. 显示错误提示
2. 回退到上一个有效区域
3. 或保持当前区域不变

---

### 状态管理规范

#### 关键状态变量

```typescript
interface AnimationState {
  isAnimating: boolean;        // 动画进行中
  isLoadingData: boolean;      // 数据加载中
  currentRegion: Region | null; // 当前区域
  dataPreparationStatus: 'idle' | 'preparing' | 'ready' | 'failed';
  lastError: Error | null;     // 最后错误
}
```

#### 状态转换规则

```
idle → preparing（开始数据准备）
preparing → ready（数据准备完成）
preparing → failed（数据准备失败）
ready → idle（数据加载完成）
failed → idle（错误处理完成）
```

---

### 性能优化建议

1. **数据预加载**：在用户可能切换的区域，提前准备数据
2. **数据缓存**：缓存已加载的区域数据，避免重复计算
3. **增量更新**：如果只是部分数据变化，只更新变化的图层
4. **防抖处理**：快速连续操作时，只执行最后一次操作

---

## 配置与扩展机制

### 缓动函数库

提供常用的缓动函数，支持自定义：

```typescript
type EasingFunction = (t: number) => number;

const easings = {
  linear: (t: number) => t,
  easeInOut: (t: number) => t < 0.5 
    ? 2 * t * t 
    : 1 - Math.pow(-2 * t + 2, 2) / 2,
  easeIn: (t: number) => t * t,
  easeOut: (t: number) => t * (2 - t),
  easeInOutCubic: (t: number) => 
    t < 0.5 
      ? 4 * t * t * t 
      : 1 - Math.pow(-2 * t + 2, 3) / 2,
};
```

### 动画预设（Preset）

提供常用场景的预设配置：

```typescript
const animationPresets = {
  // 快速切换（适合近距离）
  quick: {
    duration: 500,
    easing: easings.easeOut,
  },
  // 标准切换（默认）
  standard: {
    duration: 1500,
    easing: easings.easeInOut,
  },
  // 平滑切换（适合远距离）
  smooth: {
    duration: 2500,
    easing: easings.easeInOutCubic,
  },
};
```

### 策略扩展接口

新动画策略只需实现 `AnimationStrategy` 接口：

```typescript
interface AnimationStrategy {
  animate(
    map: google.maps.Map,
    target: any,
    options: AnimationOptions
  ): Promise<void>;
}

interface AnimationOptions {
  duration?: number;
  easing?: EasingFunction;
  onStart?: () => void;
  onComplete?: () => void;
  onCancel?: () => void;
}
```

---

## 性能与最佳实践

### 性能优化

1. **动画进行中暂停其他操作**
   - 动画期间禁用用户手动拖拽、缩放
   - 避免图层更新与动画冲突
   - **数据加载约束**：所有数据加载和图层渲染必须在动画完成后执行

2. **距离自适应**
   - 远距离使用更长动画时长，避免视觉跳跃
   - 近距离使用快速动画，提升响应感

3. **可中断机制**
   - 支持用户操作中断当前动画
   - 中断时平滑过渡到新动画
   - 中断时取消待执行的数据加载任务

### 最佳实践

1. **⭐ 强烈推荐：使用第三方动画库（Tween.js 或 GSAP）**
   - **这是目前最主流、最丝滑的做法**
   - 使用 `Tween.js` 或 `GSAP` 来处理数值的插值
   - 在 `onUpdate` 回调中调用 `map.moveCamera` 更新地图视图
   - 优势：
     - 提供丰富的缓动函数库，动画效果更自然
     - 自动处理 `requestAnimationFrame` 循环
     - 支持动画暂停、恢复、取消等高级功能
     - 减少手写动画循环的复杂度，代码更易维护
   - **实现示例**（使用 Tween.js）：
     ```typescript
     const cameraParams = { tilt: 0, heading: 0, zoom: 15 };
     
     new TWEEN.Tween(cameraParams)
       .to({ tilt: 45, heading: 90, zoom: 17 }, 1500)
       .easing(TWEEN.Easing.Quadratic.Out)
       .onUpdate(() => {
         map.moveCamera({
           tilt: cameraParams.tilt,
           heading: cameraParams.heading,
           zoom: cameraParams.zoom
         });
       })
       .start();
     
     // 必须在主循环中调用 TWEEN.update()
     function animate(time) {
       requestAnimationFrame(animate);
       TWEEN.update(time);
     }
     requestAnimationFrame(animate);
     ```

2. **错误处理**
   - 目标位置无效时，回退到直接切换（无动画）
   - 地图实例未初始化时，优雅降级

3. **可访问性**
   - 提供"禁用动画"选项（`prefers-reduced-motion`）
   - 动画时长可配置，适应不同用户需求

---

## 集成指南

### 与现有组件集成

#### 1. MapWorkspace 组件 - 页面初始化

```typescript
// 在 MapWorkspace 组件中，地图初始化完成后
useEffect(() => {
  if (!mapInstance || !initialRegion) return;
  
  const { initialize, isAnimating } = useMapAnimation({
    map: mapInstance,
    defaultDuration: 2500,
  });
  
  // 执行初始化动画
  initialize({
    target: {
      center: initialRegion.center,
      province: {
        country: initialRegion.country,
        province: initialRegion.province
      }
    },
    duration: 2500,
    onComplete: async () => {
      // 动画完成后，加载数据和图层
      await loadInitialData(initialRegion);
      await updateAllLayers(initialRegion);
    }
  });
}, [mapInstance, initialRegion]);
```

#### 2. MapWorkspace 组件 - 区域切换

```typescript
// 在 MapWorkspace 中使用
const { flyTo, switchMode, isAnimating } = useMapAnimation({
  map: mapInstance,
  defaultDuration: 1500,
});

// 行政区域切换时
const handleRegionChange = async (region: Region) => {
  const regionCenter = await getRegionCenter(region);
  
  // 暂停数据加载和图层更新
  setIsLoadingData(true);
  
  await flyTo({
    target: { 
      center: regionCenter,
      // 传入省份信息，自动计算省份全景 zoom
      province: {
        country: region.country,
        province: region.province
      }
    },
    strategy: 'parabolic',
    source: 'region-search',
    onComplete: async () => {
      // 动画完成后，加载数据和图层
      await loadRegionData(region);
      await updateAllLayers(region);
      setIsLoadingData(false);
    }
  });
};

// GPS 定位后
// 注意：GPS定位和反向解析功能已实现（参考 16-GPS定位功能.md）
// 此函数应在 GPS 定位成功回调中调用
const handleGPSLocation = async (lat: number, lng: number, region: Region) => {
  // 暂停数据加载和图层更新
  setIsLoadingData(true);
  
  await flyTo({
    target: { 
      center: { lat, lng },
      // 传入完整的区域信息，用于计算所选区域全景 zoom
      region: {
        country: region.country,
        province: region.province,
        district: region.district
      }
    },
    strategy: 'parabolic',
    source: 'gps-location', // GPS 定位触发特殊动画序列
    onComplete: async () => {
      // 动画完成后，加载数据和图层
      await loadRegionData(region);
      await updateAllLayers(region);
      setIsLoadingData(false);
    }
  });
};
```

#### 3. ControlPanel 组件

```typescript
// 2D/3D 模式切换
const handleModeSwitch = async (mode: '2d' | '3d') => {
  await switchMode({
    targetMode: mode,
    duration: 1500,
    preserveCenter: true,
  });
};
```


### 与现有配置协同

- **mapModeStyles.ts**：动画目标参数应与配置中的目标值一致
- **googleMaps.ts**：确保地图实例支持 `moveCamera` 方法（Vector Map）

---

## 实施计划

### 阶段 1：核心引擎（基础）
- [ ] 实现动画引擎核心（`requestAnimationFrame` 循环、缓动函数）
- [ ] 实现基础插值计算
- [ ] 创建 `useMapAnimation` Hook 框架

### 阶段 2：初始化动画策略
- [ ] 实现 `InitializeStrategy`（页面初始化动画）
- [ ] 大洲中心点计算逻辑
- [ ] 多参数同步动画（center、zoom、tilt）
- [ ] 在 MapWorkspace 组件初始化时集成

### 阶段 3：Fly-To 策略
- [ ] 实现 `FlyToStrategy`（抛物线动画）
- [ ] 集成球面几何插值（Google Maps Geometry 库）
- [ ] 距离自适应时长计算
- [ ] 实现省份全景 zoom 计算逻辑
- [ ] 实现 GPS 定位特殊动画序列（先滑动到GPS位置并zoom in，再zoom out）
- [ ] 在行政区域搜索中集成
- [ ] 在 GPS 定位中集成（GPS定位和反向解析功能已实现，参考 [16-GPS定位功能.md](./16-GPS定位功能.md)）
- [ ] 实现数据加载约束（动画完成后加载）

### 阶段 4：模式切换策略
- [ ] 实现 `ModeSwitchStrategy`（2D/3D 切换）
- [ ] 多参数同步动画
- [ ] 在 ControlPanel 中集成

### 阶段 5：优化与扩展
- [ ] 性能优化（动画期间暂停其他操作）
- [ ] 可中断机制
- [ ] 错误处理与降级
- [ ] 可访问性支持

---

## 注意事项

### 技术注意事项

1. **Google Maps Geometry 库**
   - 长距离经纬度插值应使用 Geometry 库的球面插值方法
   - 需要确保在 `googleMaps.ts` 中加载 `geometry` 库

2. **Vector Map 要求**
   - `moveCamera` 方法需要 Vector Map 支持
   - 确保 Map ID 配置正确（Vector 类型）

3. **省份边界数据**
   - 需要访问省份边界数据以计算合适的 zoom 级别
   - 可以使用现有的 `regionData.ts` 中的 `getAdministrativeRegion` 函数
   - 如果边界数据不可用，需要提供合理的降级方案（使用默认 zoom）

4. **性能考虑**
   - 动画进行中避免频繁的图层更新
   - 大量标记点场景下，考虑暂停标记渲染
   - **数据加载约束**：确保所有数据加载在动画完成后执行，避免干扰动画流畅性

5. **GPS 定位动画序列**
   - 两阶段动画（位置移动+zoom in → zoom out）需要合理的时间分配
   - 第一阶段（滑动到GPS位置并zoom in）建议 1000ms，同时进行位置移动和zoom变化
   - 第二阶段（zoom out到省份全景）建议 1200ms，位置保持不变
   - 两阶段之间可以添加短暂停留（300ms），增强用户体验

### 用户体验注意事项

1. **动画时长**
   - 不宜过长（> 3 秒）或过短（< 300 毫秒）
   - 建议范围：500ms - 2500ms

2. **视觉反馈**
   - 动画进行中提供加载状态指示（可选）
   - 允许用户取消动画

3. **降级策略**
   - 低性能设备或浏览器不支持时，回退到直接切换
   - 检测 `prefers-reduced-motion`，自动禁用动画

---

## 后续扩展场景

### 可能的扩展方向

1. **路线动画**
   - 沿路径移动视角（适合导航场景）

2. **区域聚焦动画**
   - 自动调整视角以完整显示区域边界

3. **多目标切换**
   - 依次切换多个位置（适合导览场景）

4. **自定义缓动曲线**
   - 支持用户自定义缓动函数

---

## 参考资源

- [Google Maps JavaScript API - moveCamera](https://developers.google.com/maps/documentation/javascript/reference/map#Map.moveCamera)
- [Google Maps Geometry Library](https://developers.google.com/maps/documentation/javascript/geometry)
- [Tween.js Documentation](https://github.com/tweenjs/tween.js/)
- [GSAP Documentation](https://greensock.com/docs/)

---

**文档版本**：v1.3  
**创建日期**：2025-01-27  
**最后更新**：2025-01-27

## 更新日志

### v1.1 (2025-01-27)
- 添加省份全景显示需求：切换完成后自动计算合适的 zoom 以显示省份全景
- 添加 GPS 定位特殊动画序列：先滑动到GPS位置并zoom in到街道级别，再zoom out到省份全景
- 添加数据加载约束：动画完成后才加载数据和图层
- 更新 API 接口：`FlyToOptions` 添加 `province` 和 `source` 参数
- 更新集成指南：添加数据加载约束的实现示例

### v1.2 (2025-01-27)
- 添加页面初始化动画场景：高空伪飞入效果，从大洲视图（tilt 0）切入到省份视图（tilt 45）
- 添加 `InitializeStrategy` 策略：支持同时动画化 center、zoom、tilt 三个参数
- 添加 `initialize` API 方法：用于页面初始化时的动画
- 更新核心场景列表：添加场景3（页面初始化动画）
- 更新集成指南：添加 MapWorkspace 组件初始化动画示例
- 更新实施计划：添加阶段4（初始化动画策略）

### v1.3 (2025-01-27)
- 新增"执行流程规范"章节：明确所有场景的执行顺序和时机控制
- 细化场景2执行流程：明确6个步骤（用户触发 → 获取区域 → 计算参数 → 动画 → 并行数据准备 → 验证数据 → 加载图层）
- 强调数据准备与加载的时机控制：数据准备可在动画期间并行，但加载必须在动画完成后
- 添加数据验证机制：动画完成后先验证数据完备性，再执行数据加载
- 添加错误处理与回退机制：数据准备失败、动画中断、区域获取失败的处理策略
- 添加状态管理规范：明确关键状态变量和状态转换规则
- 添加性能优化建议：数据预加载、缓存、增量更新、防抖处理

