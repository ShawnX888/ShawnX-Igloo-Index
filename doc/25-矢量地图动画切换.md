# 矢量地图动画切换方案

## 文档概述

### 文档目标
设计一套通用的地图动画系统，支持多种交互场景的平滑过渡效果，提升用户体验。

### 核心场景
1. **页面初始化动画**：页面加载时的"高空伪飞入"动画，从大洲视图切入到初始化区域省份视图
2. **远距离地址切换**：行政区域搜索切换、GPS定位反向解析后的区域切换
3. **2D/3D模式切换**：地图视图模式之间的平滑过渡
4. **扩展场景**：为未来可能的动画需求预留接口

### 技术基础
- Google Maps JavaScript API Vector Map（矢量地图）
- WebGL 渲染引擎
- `map.moveCamera()` 方法（原子化更新 camera 参数）

---

## 架构设计

### 分层架构

```
┌─────────────────────────────────────────┐
│  业务场景适配层                          │
│  (行政区域切换、GPS定位、模式切换)        │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│  动画策略层                              │
│  (Fly-To策略、2D/3D切换策略等)           │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│  动画引擎层                              │
│  (requestAnimationFrame、缓动函数、插值)  │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│  Google Maps API 层                     │
│  (moveCamera、getCenter、getZoom等)     │
└─────────────────────────────────────────┘
```

### 模块划分

1. **动画引擎核心** (`lib/mapAnimationEngine.ts`)
   - **⭐ 推荐方案**：集成第三方动画库（Tween.js 或 GSAP）
     - 使用第三方库处理 `requestAnimationFrame` 循环
     - 利用第三方库的缓动函数库（easeInOut、easeIn、easeOut 等）
     - 在 `onUpdate` 回调中调用 `map.moveCamera` 更新地图
     - **这是目前最主流、最丝滑的做法**
   - **备选方案**：手写动画循环
     - 处理 `requestAnimationFrame` 循环
     - 提供基础缓动函数库（easeInOut、easeIn、easeOut 等）
     - 数值插值计算（线性、球面几何等）
   - 动画状态管理（进行中、可中断、完成回调）

2. **动画策略接口** (`lib/mapAnimationStrategies.ts`)
   - 定义策略接口（`AnimationStrategy`）
   - 实现具体策略：
     - `FlyToStrategy`：远距离切换的抛物线动画
     - `ModeSwitchStrategy`：2D/3D 模式切换动画
     - `PanStrategy`：近距离平移动画（可选）

3. **React Hook 封装** (`hooks/useMapAnimation.ts`)
   - 提供业务层调用的 React Hook
   - 管理动画生命周期
   - 暴露简洁的 API（`flyTo`、`switchMode` 等）

4. **类型定义** (`types/animation.ts`)
   - 动画配置类型
   - 策略参数类型
   - 回调函数类型

---

## 核心 API 设计

### useMapAnimation Hook

```typescript
interface UseMapAnimationOptions {
  map: google.maps.Map | null;
  defaultDuration?: number;        // 默认动画时长（毫秒）
  defaultEasing?: EasingFunction;  // 默认缓动函数
  onAnimationStart?: () => void;   // 动画开始回调
  onAnimationComplete?: () => void; // 动画完成回调
  onAnimationCancel?: () => void;   // 动画取消回调
}

interface FlyToOptions {
  target: {
    center: google.maps.LatLng | google.maps.LatLngLiteral;
    zoom?: number;
    // 如果提供省份信息，将自动计算合适的zoom以显示省份全景
    province?: {
      country: string;
      province: string;
    };
  };
  duration?: number;
  easing?: EasingFunction;
  strategy?: 'parabolic' | 'linear'; // 动画策略
  source?: 'region-search' | 'gps-location'; // 触发来源，用于特殊处理
  onComplete?: () => void;
}

interface ModeSwitchOptions {
  targetMode: '2d' | '3d';
  duration?: number;
  easing?: EasingFunction;
  preserveCenter?: boolean;        // 是否保持当前中心点
  onComplete?: () => void;
}

interface InitializeOptions {
  target: {
    center: google.maps.LatLng | google.maps.LatLngLiteral;
    province: {
      country: string;
      province: string;
    };
  };
  duration?: number;
  easing?: EasingFunction;
  onComplete?: () => void;
}

function useMapAnimation(options: UseMapAnimationOptions) {
  return {
    // 页面初始化动画（高空伪飞入）
    initialize: (options: InitializeOptions) => Promise<void>;
    
    // 远距离地址切换
    flyTo: (options: FlyToOptions) => Promise<void>;
    
    // 2D/3D 模式切换
    switchMode: (options: ModeSwitchOptions) => Promise<void>;
    
    // 取消当前动画
    cancel: () => void;
    
    // 检查动画状态
    isAnimating: boolean;
  };
}
```

---

## 场景实现方案

### 场景 1：页面初始化动画（高空伪飞入）

#### 需求分析
- **触发场景**：页面首次加载时，地图初始化完成后
- **技术挑战**：
  - 需要从大洲级别的视图（zoom 很小，tilt 0）平滑过渡到省份视图（zoom 适合省份全景，tilt 45）
  - 同时变化 center、zoom、tilt 三个参数
  - 需要计算大洲级别的初始视图中心点
- **用户体验目标**：
  - 提供视觉冲击力，增强沉浸感
  - 让用户清楚看到从全局到局部的过渡
  - 最终停留在3D视角的省份全景视图

#### 实现策略：多参数同步动画（大洲 → 省份）

**核心思路**：
1. 初始状态：大洲视图（zoom 3-4，tilt 0，center 为大洲中心或目标区域的大致中心）
2. 目标状态：省份视图（zoom 根据省份边界计算，tilt 45，center 为省份中心）
3. 同时动画化 center、zoom、tilt 三个参数
4. 使用缓动函数确保平滑过渡

**⭐ 推荐实现方式**：
- **强烈推荐使用第三方动画库**（Tween.js 或 GSAP）来处理数值插值
- 在 `onUpdate` 回调中调用 `map.moveCamera` 更新地图视图
- 这是目前最主流、最丝滑的做法，能够提供更自然、更流畅的动画效果

**伪代码示例**：

```typescript
class InitializeStrategy implements AnimationStrategy {
  async animate(
    map: google.maps.Map,
    target: { 
      center: LatLng,
      province: { country: string; province: string }
    },
    options: AnimationOptions
  ): Promise<void> {
    // 1. 计算初始状态（大洲视图）
    const continentCenter = this.calculateContinentCenter(target.province.country);
    const continentZoom = this.getContinentZoom(target.province.country);
    const startTilt = 0;
    
    // 2. 计算目标状态（省份视图）
    const provinceCenter = target.center;
    const provinceZoom = await this.calculateProvinceZoom(
      target.province.country,
      target.province.province
    );
    const targetTilt = 45; // 3D视角
    
    // 3. 设置初始状态（立即设置，不动画）
    map.moveCamera({
      center: continentCenter,
      zoom: continentZoom,
      tilt: startTilt,
      heading: 0
    });
    
    // 4. 等待一帧，确保初始状态已应用
    await new Promise(resolve => requestAnimationFrame(resolve));
    
    // 5. 执行动画：从大洲视图切入到省份视图
    const duration = options.duration || 2500; // 默认2.5秒
    
    return new Promise((resolve) => {
      let startTime: number | null = null;
      
      const animate = (timestamp: number) => {
        if (!startTime) startTime = timestamp;
        const progress = Math.min((timestamp - startTime) / duration, 1);
        
        // 应用缓动函数（使用 easeInOutCubic 提供平滑的加速和减速）
        const eased = easingFunction(progress);
        
        // 同步插值所有参数
        const currentCenter = this.interpolateLatLng(
          continentCenter,
          provinceCenter,
          eased
        );
        const currentZoom = continentZoom + (provinceZoom - continentZoom) * eased;
        const currentTilt = startTilt + (targetTilt - startTilt) * eased;
        
        // 原子化更新所有参数
        map.moveCamera({
          center: currentCenter,
          zoom: currentZoom,
          tilt: currentTilt,
          heading: 0 // 保持正北向上
        });
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          resolve();
        }
      };
      
      requestAnimationFrame(animate);
    });
  }
  
  // 计算大洲中心点（根据国家位置估算）
  private calculateContinentCenter(country: string): LatLng {
    // 根据国家代码返回大洲的大致中心点
    const continentCenters: Record<string, LatLng> = {
      // 亚洲
      'CHN': { lat: 35.0, lng: 105.0 },  // 中国 → 亚洲中部
      'IDN': { lat: -2.0, lng: 118.0 },  // 印尼 → 东南亚
      'MYS': { lat: 4.0, lng: 102.0 },   // 马来西亚 → 东南亚
      'THA': { lat: 15.0, lng: 100.0 },  // 泰国 → 东南亚
      'VNM': { lat: 16.0, lng: 108.0 },  // 越南 → 东南亚
      // 可以添加更多国家
    };
    
    // 如果找不到精确匹配，使用国家的大致中心点并放大zoom
    return continentCenters[country] || { lat: 20.0, lng: 100.0 }; // 默认：东南亚
  }
  
  // 获取大洲级别的zoom
  private getContinentZoom(country: string): number {
    // 根据国家所在大洲返回合适的初始zoom
    const continentZooms: Record<string, number> = {
      'CHN': 4,  // 中国：亚洲较大，zoom稍大
      'IDN': 4,  // 印尼：东南亚
      'MYS': 5,  // 马来西亚：较小国家，zoom稍大
      'THA': 5,  // 泰国：中等国家
      'VNM': 5,  // 越南：中等国家
    };
    
    return continentZooms[country] || 4; // 默认 zoom 4
  }
  
  // 根据省份边界计算合适的 zoom 级别以显示省份全景
  private async calculateProvinceZoom(
    country: string,
    province: string
  ): Promise<number> {
    // 获取省份边界数据
    // 注意：可以使用现有的 regionData.ts 中的 getAdministrativeRegion 函数
    const provinceRegion = await getAdministrativeRegion({ country, province, district: '' });
    
    if (!provinceRegion || !provinceRegion.boundary || provinceRegion.boundary.length === 0) {
      // 如果无法获取边界，使用默认 zoom（根据国家大小调整）
      return this.getDefaultProvinceZoom(country);
    }
    
    // 计算边界框：遍历所有边界点，找到最小/最大经纬度
    let minLat = Infinity, maxLat = -Infinity;
    let minLng = Infinity, maxLng = -Infinity;
    
    for (const point of provinceRegion.boundary) {
      minLat = Math.min(minLat, point.lat);
      maxLat = Math.max(maxLat, point.lat);
      minLng = Math.min(minLng, point.lng);
      maxLng = Math.max(maxLng, point.lng);
    }
    
    // 计算边界框的宽度和高度（度）
    const latDiff = maxLat - minLat;
    const lngDiff = maxLng - minLng;
    
    // 使用 Google Maps 的 fitBounds 逻辑计算合适的 zoom
    // 简化版本：根据边界框大小估算 zoom
    const maxDiff = Math.max(latDiff, lngDiff);
    
    // 经验公式：根据边界框大小计算 zoom
    // 这个公式需要根据实际测试调整
    if (maxDiff > 10) return 5;      // 非常大的省份（如俄罗斯的州）
    if (maxDiff > 5) return 6;       // 大省份
    if (maxDiff > 2) return 7;       // 中等省份
    if (maxDiff > 1) return 8;       // 小省份
    if (maxDiff > 0.5) return 9;     // 更小的省份
    return 10;                        // 默认
  }
  
  // 根据国家获取默认省份 zoom（降级方案）
  private getDefaultProvinceZoom(country: string): number {
    // 根据国家大小提供合理的默认值
    const countryDefaults: Record<string, number> = {
      'CHN': 7,  // 中国：省份较大
      'USA': 6,  // 美国：州较大
      'IDN': 8,  // 印尼：省份中等
      'MYS': 8,  // 马来西亚：州中等
      'THA': 8,  // 泰国：府中等
      'VNM': 8,  // 越南：省中等
    };
    return countryDefaults[country] || 8; // 默认 8
  }
}
```

#### 集成点
- **MapWorkspace 组件**：在地图初始化完成后，调用 `initialize` 方法
- **初始化时机**：确保在地图实例创建完成、但数据加载之前执行
- **与数据加载的协调**：初始化动画完成后，再加载数据和图层（遵循数据加载约束）

---

### 场景 2：远距离地址切换（Fly-To 动画）

#### 需求分析
- **触发场景**：
  - 用户通过地图设置搜索行政区域
  - GPS 定位后反向解析到行政区域
- **技术挑战**：
  - 跨越大距离时，直接 `panTo` 会显得漫长且可能加载无效瓦片
  - 需要类似 Google Earth 的"飞行"效果
- **特殊需求**：
  1. **省份全景显示**：切换完成后，最终 zoom 需要能够显示所选区域所属省份的全景
  2. **GPS 定位特殊动画**：GPS 定位触发的切换需要先滑动到GPS定位位置的同时 zoom in 到街道级别（15-16），然后 zoom out 到省份全景
  3. **数据加载约束**：动画完成后才加载其他数据和各个图层

#### 实现策略：抛物线 Fly-To（支持省份全景和 GPS 特殊序列）

**核心思路**：
1. 先拉高视角（Zoom Out）→ 移动位置（Pan）→ 再拉近视角（Zoom In）
2. 使用抛物线曲线控制 Zoom 变化
3. 经纬度插值需要考虑球面几何
4. **省份全景计算**：根据省份边界自动计算合适的 zoom 级别
5. **GPS 定位特殊序列**：先滑动到GPS定位位置的同时 zoom in 到街道级别，再 zoom out 到省份全景

**⭐ 推荐实现方式**：
- **强烈推荐使用第三方动画库**（Tween.js 或 GSAP）来处理数值插值
- 在 `onUpdate` 回调中调用 `map.moveCamera` 更新地图视图
- 这是目前最主流、最丝滑的做法，特别适合复杂的抛物线动画和球面几何插值

**伪代码示例**：

```typescript
class FlyToStrategy implements AnimationStrategy {
  async animate(
    map: google.maps.Map,
    target: { 
      center: LatLng, 
      zoom?: number,
      province?: { country: string; province: string }
    },
    options: AnimationOptions & { source?: 'region-search' | 'gps-location' }
  ): Promise<void> {
    const startCenter = map.getCenter();
    const startZoom = map.getZoom() || 10;
    
    // 计算目标 zoom
    let targetZoom: number;
    if (target.province) {
      // 根据省份边界计算合适的 zoom 以显示省份全景
      targetZoom = await this.calculateProvinceZoom(
        target.province.country,
        target.province.province
      );
    } else {
      targetZoom = target.zoom || startZoom;
    }
    
    // GPS 定位特殊处理：两阶段动画
    if (options.source === 'gps-location') {
      return this.animateGPSSequence(map, target, targetZoom, options);
    }
    
    // 标准抛物线 Fly-To
    const distance = this.calculateDistance(startCenter, target.center);
    const duration = options.duration || this.adaptiveDuration(distance);
    
    // 计算抛物线最高点（Zoom 最小值）
    const maxZoomOut = Math.min(startZoom, targetZoom) - 2;
    
    return new Promise((resolve) => {
      let startTime: number | null = null;
      
      const animate = (timestamp: number) => {
        if (!startTime) startTime = timestamp;
        const progress = Math.min((timestamp - startTime) / duration, 1);
        
        // 应用缓动函数
        const eased = easingFunction(progress);
        
        // 经纬度插值（球面几何）
        const currentCenter = this.interpolateLatLng(
          startCenter,
          target.center,
          eased
        );
        
        // 抛物线 Zoom 曲线
        // 在进度 50% 时达到最大 Zoom Out
        const zoomArc = Math.sin(progress * Math.PI) * 2;
        const currentZoom = startZoom + 
          (targetZoom - startZoom) * eased - 
          zoomArc;
        
        // 更新地图
        map.moveCamera({
          center: currentCenter,
          zoom: currentZoom
        });
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          resolve();
        }
      };
      
      requestAnimationFrame(animate);
    });
  }
  
  // GPS 定位特殊动画序列：先滑动到GPS位置并zoom in到街道级别，再zoom out到省份全景
  private async animateGPSSequence(
    map: google.maps.Map,
    target: { center: LatLng, province?: { country: string; province: string } },
    provinceZoom: number,
    options: AnimationOptions
  ): Promise<void> {
    const startCenter = map.getCenter();
    const startZoom = map.getZoom() || 10;
    const streetZoom = 15; // 街道级别 zoom
    
    // 第一阶段：同时滑动到GPS定位位置并zoom in到街道级别
    // 使用抛物线动画，在移动位置的同时进行zoom in
    await this.animateFlyToWithZoom(map, startCenter, target.center, startZoom, streetZoom, 1000);
    
    // 短暂停留（可选，增强用户体验）
    await new Promise(resolve => setTimeout(resolve, 300));
    
    // 第二阶段：zoom out到省份全景（位置保持不变）
    await this.animateZoom(map, target.center, target.center, streetZoom, provinceZoom, 1200);
  }
  
  // 辅助方法：同时进行位置移动和zoom变化（抛物线动画）
  private async animateFlyToWithZoom(
    map: google.maps.Map,
    startCenter: LatLng,
    endCenter: LatLng,
    startZoom: number,
    endZoom: number,
    duration: number
  ): Promise<void> {
    return new Promise((resolve) => {
      let startTime: number | null = null;
      
      const animate = (timestamp: number) => {
        if (!startTime) startTime = timestamp;
        const progress = Math.min((timestamp - startTime) / duration, 1);
        
        // 应用缓动函数
        const eased = easingFunction(progress);
        
        // 经纬度插值（球面几何）
        const currentCenter = this.interpolateLatLng(startCenter, endCenter, eased);
        
        // Zoom 插值（线性或使用缓动函数）
        const currentZoom = startZoom + (endZoom - startZoom) * eased;
        
        // 原子化更新位置和zoom
        map.moveCamera({
          center: currentCenter,
          zoom: currentZoom
        });
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          resolve();
        }
      };
      
      requestAnimationFrame(animate);
    });
  }
  
  // 辅助方法：执行 zoom 动画
  private async animateZoom(
    map: google.maps.Map,
    startCenter: LatLng,
    endCenter: LatLng,
    startZoom: number,
    endZoom: number,
    duration: number
  ): Promise<void> {
    return new Promise((resolve) => {
      let startTime: number | null = null;
      
      const animate = (timestamp: number) => {
        if (!startTime) startTime = timestamp;
        const progress = Math.min((timestamp - startTime) / duration, 1);
        const eased = easingFunction(progress);
        
        const currentCenter = this.interpolateLatLng(startCenter, endCenter, eased);
        const currentZoom = startZoom + (endZoom - startZoom) * eased;
        
        map.moveCamera({
          center: currentCenter,
          zoom: currentZoom
        });
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          resolve();
        }
      };
      
      requestAnimationFrame(animate);
    });
  }
  
  // 根据省份边界计算合适的 zoom 级别以显示省份全景
  private async calculateProvinceZoom(
    country: string,
    province: string
  ): Promise<number> {
    // 获取省份边界数据
    // 注意：可以使用现有的 regionData.ts 中的 getAdministrativeRegion 函数
    // 或者使用 Google Maps Geometry 库的 LatLngBounds
    const provinceRegion = await getAdministrativeRegion({ country, province, district: '' });
    
    if (!provinceRegion || !provinceRegion.boundary || provinceRegion.boundary.length === 0) {
      // 如果无法获取边界，使用默认 zoom（根据国家大小调整）
      return this.getDefaultProvinceZoom(country);
    }
    
    // 计算边界框：遍历所有边界点，找到最小/最大经纬度
    let minLat = Infinity, maxLat = -Infinity;
    let minLng = Infinity, maxLng = -Infinity;
    
    for (const point of provinceRegion.boundary) {
      minLat = Math.min(minLat, point.lat);
      maxLat = Math.max(maxLat, point.lat);
      minLng = Math.min(minLng, point.lng);
      maxLng = Math.max(maxLng, point.lng);
    }
    
    // 计算边界框的宽度和高度（度）
    const latDiff = maxLat - minLat;
    const lngDiff = maxLng - minLng;
    
    // 使用 Google Maps 的 fitBounds 逻辑计算合适的 zoom
    // 简化版本：根据边界框大小估算 zoom
    const maxDiff = Math.max(latDiff, lngDiff);
    
    // 经验公式：根据边界框大小计算 zoom
    // 这个公式需要根据实际测试调整
    if (maxDiff > 10) return 5;      // 非常大的省份（如俄罗斯的州）
    if (maxDiff > 5) return 6;       // 大省份
    if (maxDiff > 2) return 7;       // 中等省份
    if (maxDiff > 1) return 8;       // 小省份
    if (maxDiff > 0.5) return 9;     // 更小的省份
    return 10;                        // 默认
    
    // 可选：使用 Google Maps LatLngBounds 的 fitBounds 方法
    // const bounds = new google.maps.LatLngBounds();
    // provinceRegion.boundary.forEach(point => bounds.extend(point));
    // const zoom = map.getBoundsZoomLevel(bounds); // 需要自定义实现
  }
  
  // 根据国家获取默认省份 zoom（降级方案）
  private getDefaultProvinceZoom(country: string): number {
    // 根据国家大小提供合理的默认值
    const countryDefaults: Record<string, number> = {
      'CHN': 7,  // 中国：省份较大
      'USA': 6,  // 美国：州较大
      'IDN': 8,  // 印尼：省份中等
      'MYS': 8,  // 马来西亚：州中等
      'THA': 8,  // 泰国：府中等
      'VNM': 8,  // 越南：省中等
    };
    return countryDefaults[country] || 8; // 默认 8
  }
  
  // 球面几何插值（可使用 Google Maps Geometry 库）
  private interpolateLatLng(
    start: LatLng,
    end: LatLng,
    t: number
  ): LatLng {
    // 简单线性插值（适用于短距离）
    // 长距离建议使用 Google Maps Geometry 库的球面插值
    return {
      lat: start.lat() + (end.lat() - start.lat()) * t,
      lng: start.lng() + (end.lng() - start.lng()) * t
    };
  }
  
  // 根据距离自适应动画时长
  private adaptiveDuration(distance: number): number {
    // 距离越远，动画时长越长（但有上限）
    const baseDuration = 1000; // 1秒基础时长
    const distanceFactor = Math.min(distance / 1000, 5); // 每1000km增加，最多5倍
    return baseDuration * (1 + distanceFactor);
  }
}
```

#### 集成点
- **行政区域搜索**：`MapWorkspace` 组件中，当用户选择新区域时调用 `flyTo`，传入省份信息以计算省份全景 zoom
- **GPS 定位**：`gpsLocation.ts` 中，定位成功后调用 `flyTo`，设置 `source: 'gps-location'` 触发特殊动画序列

#### 数据加载约束

**重要约束**：动画完成后才加载数据和图层

所有数据加载和图层渲染必须在动画完成后执行，确保：
1. 动画流畅性：避免数据加载过程中的地图更新干扰动画
2. 性能优化：减少动画期间的资源消耗
3. 用户体验：先看到平滑的动画，再看到数据填充

**实现方式**：
- 在 `flyTo` 的 `onComplete` 回调中触发数据加载
- 在动画进行期间，暂停所有图层更新和数据请求

---

### 场景 3：2D/3D 模式切换

#### 需求分析
- **触发场景**：用户点击 2D/3D 切换按钮
- **技术挑战**：
  - 需要同时动画化 `tilt`、`heading`、`zoom`
  - 避免突兀切换导致用户迷失方向感
  - 需要平滑的往返切换（2D → 3D → 2D）

#### 实现策略：同步多参数动画

**核心思路**：
1. 同时动画化 `tilt`、`heading`、`zoom` 三个参数
2. 使用相同的缓动函数确保同步
3. 进入 3D 时稍微放大（+1 或 +2），增强沉浸感

**⭐ 推荐实现方式**：
- **强烈推荐使用第三方动画库**（Tween.js 或 GSAP）来处理数值插值
- 在 `onUpdate` 回调中调用 `map.moveCamera` 更新地图视图
- 这是目前最主流、最丝滑的做法，能够确保多个参数同步动画的流畅性

**伪代码示例**：

```typescript
class ModeSwitchStrategy implements AnimationStrategy {
  async animate(
    map: google.maps.Map,
    targetMode: '2d' | '3d',
    options: AnimationOptions
  ): Promise<void> {
    const currentConfig = this.getCurrentCameraConfig(map);
    const targetConfig = this.getTargetConfig(targetMode, currentConfig);
    
    const duration = options.duration || 1500; // 默认1.5秒
    
    return new Promise((resolve) => {
      let startTime: number | null = null;
      
      const animate = (timestamp: number) => {
        if (!startTime) startTime = timestamp;
        const progress = Math.min((timestamp - startTime) / duration, 1);
        
        // 应用缓动函数
        const eased = easingFunction(progress);
        
        // 同步插值所有参数
        const currentTilt = this.interpolate(
          currentConfig.tilt,
          targetConfig.tilt,
          eased
        );
        const currentHeading = this.interpolate(
          currentConfig.heading,
          targetConfig.heading,
          eased
        );
        const currentZoom = this.interpolate(
          currentConfig.zoom,
          targetConfig.zoom,
          eased
        );
        
        // 原子化更新所有参数
        map.moveCamera({
          tilt: currentTilt,
          heading: currentHeading,
          zoom: currentZoom,
          // 如果 preserveCenter 为 false，可以同时改变 center
        });
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          resolve();
        }
      };
      
      requestAnimationFrame(animate);
    });
  }
  
  private getTargetConfig(
    mode: '2d' | '3d',
    current: CameraConfig
  ): CameraConfig {
    if (mode === '3d') {
      // 进入 3D 模式
      return {
        tilt: 45,                    // 倾斜 45 度
        heading: 0,                  // 正北向上
        zoom: current.zoom + 1,      // 稍微放大
        center: current.center       // 保持中心点
      };
    } else {
      // 回到 2D 模式
      return {
        tilt: 0,                     // 俯视
        heading: 0,                   // 正北向上
        zoom: current.zoom - 1,      // 稍微缩小（补偿之前的放大）
        center: current.center
      };
    }
  }
}
```

#### 集成点
- **控制面板**：`ControlPanel` 组件中，2D/3D 切换按钮调用 `switchMode`
- **地图配置**：与 `mapModeStyles.ts` 配置协同，确保目标参数一致

---

## 配置与扩展机制

### 缓动函数库

提供常用的缓动函数，支持自定义：

```typescript
type EasingFunction = (t: number) => number;

const easings = {
  linear: (t: number) => t,
  easeInOut: (t: number) => t < 0.5 
    ? 2 * t * t 
    : 1 - Math.pow(-2 * t + 2, 2) / 2,
  easeIn: (t: number) => t * t,
  easeOut: (t: number) => t * (2 - t),
  easeInOutCubic: (t: number) => 
    t < 0.5 
      ? 4 * t * t * t 
      : 1 - Math.pow(-2 * t + 2, 3) / 2,
};
```

### 动画预设（Preset）

提供常用场景的预设配置：

```typescript
const animationPresets = {
  // 快速切换（适合近距离）
  quick: {
    duration: 500,
    easing: easings.easeOut,
  },
  // 标准切换（默认）
  standard: {
    duration: 1500,
    easing: easings.easeInOut,
  },
  // 平滑切换（适合远距离）
  smooth: {
    duration: 2500,
    easing: easings.easeInOutCubic,
  },
};
```

### 策略扩展接口

新动画策略只需实现 `AnimationStrategy` 接口：

```typescript
interface AnimationStrategy {
  animate(
    map: google.maps.Map,
    target: any,
    options: AnimationOptions
  ): Promise<void>;
}

interface AnimationOptions {
  duration?: number;
  easing?: EasingFunction;
  onStart?: () => void;
  onComplete?: () => void;
  onCancel?: () => void;
}
```

---

## 性能与最佳实践

### 性能优化

1. **动画进行中暂停其他操作**
   - 动画期间禁用用户手动拖拽、缩放
   - 避免图层更新与动画冲突
   - **数据加载约束**：所有数据加载和图层渲染必须在动画完成后执行

2. **距离自适应**
   - 远距离使用更长动画时长，避免视觉跳跃
   - 近距离使用快速动画，提升响应感

3. **可中断机制**
   - 支持用户操作中断当前动画
   - 中断时平滑过渡到新动画
   - 中断时取消待执行的数据加载任务

### 最佳实践

1. **⭐ 强烈推荐：使用第三方动画库（Tween.js 或 GSAP）**
   - **这是目前最主流、最丝滑的做法**
   - 使用 `Tween.js` 或 `GSAP` 来处理数值的插值
   - 在 `onUpdate` 回调中调用 `map.moveCamera` 更新地图视图
   - 优势：
     - 提供丰富的缓动函数库，动画效果更自然
     - 自动处理 `requestAnimationFrame` 循环
     - 支持动画暂停、恢复、取消等高级功能
     - 减少手写动画循环的复杂度，代码更易维护
   - **实现示例**（使用 Tween.js）：
     ```typescript
     const cameraParams = { tilt: 0, heading: 0, zoom: 15 };
     
     new TWEEN.Tween(cameraParams)
       .to({ tilt: 45, heading: 90, zoom: 17 }, 1500)
       .easing(TWEEN.Easing.Quadratic.Out)
       .onUpdate(() => {
         map.moveCamera({
           tilt: cameraParams.tilt,
           heading: cameraParams.heading,
           zoom: cameraParams.zoom
         });
       })
       .start();
     
     // 必须在主循环中调用 TWEEN.update()
     function animate(time) {
       requestAnimationFrame(animate);
       TWEEN.update(time);
     }
     requestAnimationFrame(animate);
     ```

2. **错误处理**
   - 目标位置无效时，回退到直接切换（无动画）
   - 地图实例未初始化时，优雅降级

3. **可访问性**
   - 提供"禁用动画"选项（`prefers-reduced-motion`）
   - 动画时长可配置，适应不同用户需求

---

## 集成指南

### 与现有组件集成

#### 1. MapWorkspace 组件 - 页面初始化

```typescript
// 在 MapWorkspace 组件中，地图初始化完成后
useEffect(() => {
  if (!mapInstance || !initialRegion) return;
  
  const { initialize, isAnimating } = useMapAnimation({
    map: mapInstance,
    defaultDuration: 2500,
  });
  
  // 执行初始化动画
  initialize({
    target: {
      center: initialRegion.center,
      province: {
        country: initialRegion.country,
        province: initialRegion.province
      }
    },
    duration: 2500,
    onComplete: async () => {
      // 动画完成后，加载数据和图层
      await loadInitialData(initialRegion);
      await updateAllLayers(initialRegion);
    }
  });
}, [mapInstance, initialRegion]);
```

#### 2. MapWorkspace 组件 - 区域切换

```typescript
// 在 MapWorkspace 中使用
const { flyTo, switchMode, isAnimating } = useMapAnimation({
  map: mapInstance,
  defaultDuration: 1500,
});

// 行政区域切换时
const handleRegionChange = async (region: Region) => {
  const regionCenter = await getRegionCenter(region);
  
  // 暂停数据加载和图层更新
  setIsLoadingData(true);
  
  await flyTo({
    target: { 
      center: regionCenter,
      // 传入省份信息，自动计算省份全景 zoom
      province: {
        country: region.country,
        province: region.province
      }
    },
    strategy: 'parabolic',
    source: 'region-search',
    onComplete: async () => {
      // 动画完成后，加载数据和图层
      await loadRegionData(region);
      await updateAllLayers(region);
      setIsLoadingData(false);
    }
  });
};

// GPS 定位后
const handleGPSLocation = async (lat: number, lng: number, region: Region) => {
  // 暂停数据加载和图层更新
  setIsLoadingData(true);
  
  await flyTo({
    target: { 
      center: { lat, lng },
      // 传入省份信息，用于计算省份全景 zoom
      province: {
        country: region.country,
        province: region.province
      }
    },
    strategy: 'parabolic',
    source: 'gps-location', // GPS 定位触发特殊动画序列
    onComplete: async () => {
      // 动画完成后，加载数据和图层
      await loadRegionData(region);
      await updateAllLayers(region);
      setIsLoadingData(false);
    }
  });
};
```

#### 3. ControlPanel 组件

```typescript
// 2D/3D 模式切换
const handleModeSwitch = async (mode: '2d' | '3d') => {
  await switchMode({
    targetMode: mode,
    duration: 1500,
    preserveCenter: true,
  });
};
```


### 与现有配置协同

- **mapModeStyles.ts**：动画目标参数应与配置中的目标值一致
- **googleMaps.ts**：确保地图实例支持 `moveCamera` 方法（Vector Map）

---

## 实施计划

### 阶段 1：核心引擎（基础）
- [ ] 实现动画引擎核心（`requestAnimationFrame` 循环、缓动函数）
- [ ] 实现基础插值计算
- [ ] 创建 `useMapAnimation` Hook 框架

### 阶段 2：初始化动画策略
- [ ] 实现 `InitializeStrategy`（页面初始化动画）
- [ ] 大洲中心点计算逻辑
- [ ] 多参数同步动画（center、zoom、tilt）
- [ ] 在 MapWorkspace 组件初始化时集成

### 阶段 3：Fly-To 策略
- [ ] 实现 `FlyToStrategy`（抛物线动画）
- [ ] 集成球面几何插值（Google Maps Geometry 库）
- [ ] 距离自适应时长计算
- [ ] 实现省份全景 zoom 计算逻辑
- [ ] 实现 GPS 定位特殊动画序列（先滑动到GPS位置并zoom in，再zoom out）
- [ ] 在行政区域搜索和 GPS 定位中集成
- [ ] 实现数据加载约束（动画完成后加载）

### 阶段 4：模式切换策略
- [ ] 实现 `ModeSwitchStrategy`（2D/3D 切换）
- [ ] 多参数同步动画
- [ ] 在 ControlPanel 中集成

### 阶段 5：优化与扩展
- [ ] 性能优化（动画期间暂停其他操作）
- [ ] 可中断机制
- [ ] 错误处理与降级
- [ ] 可访问性支持

---

## 注意事项

### 技术注意事项

1. **Google Maps Geometry 库**
   - 长距离经纬度插值应使用 Geometry 库的球面插值方法
   - 需要确保在 `googleMaps.ts` 中加载 `geometry` 库

2. **Vector Map 要求**
   - `moveCamera` 方法需要 Vector Map 支持
   - 确保 Map ID 配置正确（Vector 类型）

3. **省份边界数据**
   - 需要访问省份边界数据以计算合适的 zoom 级别
   - 可以使用现有的 `regionData.ts` 中的 `getAdministrativeRegion` 函数
   - 如果边界数据不可用，需要提供合理的降级方案（使用默认 zoom）

4. **性能考虑**
   - 动画进行中避免频繁的图层更新
   - 大量标记点场景下，考虑暂停标记渲染
   - **数据加载约束**：确保所有数据加载在动画完成后执行，避免干扰动画流畅性

5. **GPS 定位动画序列**
   - 两阶段动画（位置移动+zoom in → zoom out）需要合理的时间分配
   - 第一阶段（滑动到GPS位置并zoom in）建议 1000ms，同时进行位置移动和zoom变化
   - 第二阶段（zoom out到省份全景）建议 1200ms，位置保持不变
   - 两阶段之间可以添加短暂停留（300ms），增强用户体验

### 用户体验注意事项

1. **动画时长**
   - 不宜过长（> 3 秒）或过短（< 300 毫秒）
   - 建议范围：500ms - 2500ms

2. **视觉反馈**
   - 动画进行中提供加载状态指示（可选）
   - 允许用户取消动画

3. **降级策略**
   - 低性能设备或浏览器不支持时，回退到直接切换
   - 检测 `prefers-reduced-motion`，自动禁用动画

---

## 后续扩展场景

### 可能的扩展方向

1. **路线动画**
   - 沿路径移动视角（适合导航场景）

2. **区域聚焦动画**
   - 自动调整视角以完整显示区域边界

3. **多目标切换**
   - 依次切换多个位置（适合导览场景）

4. **自定义缓动曲线**
   - 支持用户自定义缓动函数

---

## 参考资源

- [Google Maps JavaScript API - moveCamera](https://developers.google.com/maps/documentation/javascript/reference/map#Map.moveCamera)
- [Google Maps Geometry Library](https://developers.google.com/maps/documentation/javascript/geometry)
- [Tween.js Documentation](https://github.com/tweenjs/tween.js/)
- [GSAP Documentation](https://greensock.com/docs/)

---

**文档版本**：v1.2  
**创建日期**：2025-01-27  
**最后更新**：2025-01-27

## 更新日志

### v1.1 (2025-01-27)
- 添加省份全景显示需求：切换完成后自动计算合适的 zoom 以显示省份全景
- 添加 GPS 定位特殊动画序列：先滑动到GPS位置并zoom in到街道级别，再zoom out到省份全景
- 添加数据加载约束：动画完成后才加载数据和图层
- 更新 API 接口：`FlyToOptions` 添加 `province` 和 `source` 参数
- 更新集成指南：添加数据加载约束的实现示例

### v1.2 (2025-01-27)
- 添加页面初始化动画场景：高空伪飞入效果，从大洲视图（tilt 0）切入到省份视图（tilt 45）
- 添加 `InitializeStrategy` 策略：支持同时动画化 center、zoom、tilt 三个参数
- 添加 `initialize` API 方法：用于页面初始化时的动画
- 更新核心场景列表：添加场景3（页面初始化动画）
- 更新集成指南：添加 MapWorkspace 组件初始化动画示例
- 更新实施计划：添加阶段4（初始化动画策略）

