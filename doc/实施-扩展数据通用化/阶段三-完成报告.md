# 阶段三：集成到风险事件计算 - 完成报告

## 完成时间
2025-12-18

## 完成状态
✅ 已完成

---

## 步骤 3.1：在 useRiskAnalysis 中导入 Hook

### 完成内容

1. **导入语句**
   - ✅ 在 `useRiskAnalysis.ts` 中导入 `useExtendedWeatherData`
   - ✅ 更新文件注释，说明使用扩展数据

### 验证结果
- [x] 导入语句正确
- [x] 没有编译错误

---

## 步骤 3.2：在 useRiskAnalysis 中调用扩展数据获取

### 完成内容

1. **调用扩展数据获取 Hook**
   - ✅ 在 `useRiskAnalysis` 函数内部调用 `useExtendedWeatherData`
   - ✅ 传入正确的参数：`selectedRegion`, `dateRange`, `dataType`, `weatherType`, `selectedProduct`
   - ✅ 获取扩展数据：`extendedHourlyData`, `extendedDailyData`, `extendedDateRange`

2. **根据产品类型选择数据粒度**
   - ✅ 创建 `selectedRegionExtendedData` useMemo
   - ✅ 根据产品 `riskRules.timeWindow.type` 选择合适的数据：
     - `hourly` → 使用 `extendedHourlyData`
     - `daily`, `weekly`, `monthly` → 使用 `extendedDailyData`
   - ✅ 如果没有产品选择或扩展数据，回退到原始数据

### 验证结果
- [x] Hook 调用正确
- [x] 参数传递正确
- [x] 扩展数据已获取
- [x] 根据产品类型正确选择数据粒度

---

## 步骤 3.3：使用扩展数据进行风险事件计算

### 完成内容

1. **修改风险事件计算逻辑**
   - ✅ 在计算所有区域的风险事件时，区分选中区域和其他区域
   - ✅ 对于选中区域：使用扩展数据（`selectedRegionExtendedData`）和扩展时间范围（`extendedDateRange`）
   - ✅ 对于其他区域：使用原始数据（`allRegionsWeatherData[district]`）和原始时间范围（`dateRange`）

2. **计算逻辑**
   - ✅ 保持缓存机制不变
   - ✅ 计算所有区域的事件（用于地图标记）
   - ✅ 确保计算逻辑使用扩展数据

### 验证结果
- [x] 计算使用扩展数据（选中区域）
- [x] 计算逻辑正确
- [x] 其他区域仍使用原始数据

---

## 步骤 3.4：实现结果过滤逻辑

### 完成内容

1. **过滤风险事件结果**
   - ✅ 在 `riskEvents` 计算中添加过滤逻辑
   - ✅ 过滤条件：只保留时间戳在 `dateRange.from` 到 `dateRange.to` 范围内的风险事件
   - ✅ 确保过滤后的结果用于：
     - `riskEvents` 输出（选中区域的事件，已过滤）
     - `mapMarkersData` 计算（所有区域的事件，已过滤）
     - `statistics` 计算（基于已过滤的 `riskEvents`）

2. **缓存处理**
   - ✅ 缓存中存储所有事件（包括扩展时间范围内的）
   - ✅ 从缓存读取时，也进行过滤到用户选择的时间窗口

3. **地图标记数据过滤**
   - ✅ `mapMarkersData` 计算时，先过滤所有事件到用户选择的时间窗口
   - ✅ 然后基于过滤后的事件进行城市聚合

### 验证结果
- [x] 过滤逻辑正确
- [x] 只包含用户选择时间范围内的风险事件
- [x] 不影响其他输出（mapMarkersData, statistics）
- [x] 缓存机制正常工作

---

## 代码变更总结

### 修改文件
- `Next-gen-index/src/hooks/useRiskAnalysis.ts`
  - 导入 `useExtendedWeatherData` Hook
  - 调用扩展数据获取
  - 根据产品类型选择数据粒度
  - 使用扩展数据进行风险事件计算
  - 实现结果过滤逻辑

### 关键实现点

1. **扩展数据获取**
   ```typescript
   const { extendedHourlyData, extendedDailyData, extendedDateRange } = 
     useExtendedWeatherData(selectedRegion, dateRange, dataType, weatherType, selectedProduct);
   ```

2. **数据粒度选择**
   ```typescript
   const selectedRegionExtendedData = useMemo(() => {
     if (timeWindowType === 'hourly') {
       return extendedHourlyData;
     } else {
       return extendedDailyData;
     }
   }, [selectedProduct, extendedHourlyData, extendedDailyData, ...]);
   ```

3. **使用扩展数据计算**
   ```typescript
   const dataToUse = district === selectedRegion.district 
     ? selectedRegionExtendedData 
     : data;
   ```

4. **结果过滤**
   ```typescript
   return selectedDistrictEvents.filter(event => {
     const eventTime = event.timestamp.getTime();
     return eventTime >= dateRange.from.getTime() && eventTime <= dateRange.to.getTime();
   });
   ```

### 代码质量
- ✅ 无 TypeScript 编译错误
- ✅ 无 Linter 错误
- ✅ 代码注释已更新

---

## 设计决策说明

### 1. 只对选中区域使用扩展数据
**决策**：只对选中区域使用扩展数据进行风险事件计算，其他区域仍使用原始数据。

**理由**：
- 扩展数据主要用于确保时间窗口起始位置的计算准确
- 地图标记只需要显示风险事件数量，不需要精确的起始位置计算
- 减少计算量，提升性能

### 2. 缓存中存储所有事件
**决策**：缓存中存储所有事件（包括扩展时间范围内的），读取时再过滤。

**理由**：
- 保持缓存的一致性
- 避免重复计算
- 过滤逻辑简单，性能影响小

### 3. 地图标记基于过滤后的事件
**决策**：地图标记数据基于过滤后的风险事件（只包含用户选择时间范围内的事件）。

**理由**：
- 确保地图标记反映用户选择的时间范围内的风险情况
- 保持数据一致性

---

## 下一步行动

根据实施计划，下一步是：

**阶段四：更新组件引用**
- 步骤 4.1：更新 DataDashboard 组件（已在阶段二完成）
- 步骤 4.2：检查其他可能的引用

**阶段五：测试与验证**
- 步骤 5.1：功能测试 - 风险叠加示意图
- 步骤 5.2：功能测试 - 风险事件计算
- 步骤 5.3：边界测试
- 步骤 5.4：性能测试
- 步骤 5.5：集成测试

---

**文档版本**：v1.0  
**创建日期**：2025-12-18  
**完成状态**：✅ 已完成

