# 阶段五：问题修复 - 过滤逻辑优化

## 问题描述
用户指出过滤逻辑存在问题：
- 对于周度产品和月度产品（daily/weekly/monthly），如果计算得到的风险事件处于 dateRange 日期范围内（不考虑具体时刻），应该计入
- 对于日内产品（hourly），如果计算得到的风险事件处于 dateRange 时刻范围内，应该计入

## 问题分析

### 当前实现
当前所有产品类型都使用精确时间范围比较：
```typescript
const eventTime = event.timestamp.getTime();
return eventTime >= dateRange.from.getTime() && eventTime <= dateRange.to.getTime();
```

### 问题
对于 daily/weekly/monthly 产品：
- 如果 dateRange 是 `2025-12-16 17:00` 到 `2025-12-23 17:00`
- 那么 `2025-12-16 08:00` 的事件会被排除（因为 `08:00 < 17:00`）
- 但实际上，对于日级/周级/月级产品，应该按日期比较，`2025-12-16` 的任何时刻都应该计入

### 正确的逻辑
1. **hourly 产品**：精确时间范围比较
   - 事件时间戳必须在 `dateRange.from` 和 `dateRange.to` 之间（包括边界）

2. **daily/weekly/monthly 产品**：日期范围比较（不考虑时刻）
   - 事件日期必须在 `dateRange.from` 的日期和 `dateRange.to` 的日期之间（包括边界）
   - 例如：dateRange 是 `2025-12-16 17:00` 到 `2025-12-23 17:00`
   - 那么 `2025-12-16 00:00` 到 `2025-12-16 23:59` 的所有事件都应该计入
   - `2025-12-23 00:00` 到 `2025-12-23 23:59` 的所有事件也应该计入

## 修复方案

### 创建辅助函数 `filterRiskEventsByDateRange`

**文件**: `Next-gen-index/src/hooks/useRiskAnalysis.ts`

**实现**:
```typescript
// 辅助函数：根据产品类型过滤风险事件
// - 对于 hourly 产品：精确时间范围比较
// - 对于 daily/weekly/monthly 产品：日期范围比较（不考虑时刻）
const filterRiskEventsByDateRange = useMemo(() => {
  if (!selectedProduct) {
    return (events: RiskEvent[]) => events;
  }
  
  const fullProduct = productLibrary.getProduct(selectedProduct.id);
  const productTimeWindowType = fullProduct?.riskRules?.timeWindow?.type || 'hourly';
  
  return (events: RiskEvent[]): RiskEvent[] => {
    if (productTimeWindowType === 'hourly') {
      // 精确时间范围比较
      return events.filter(event => {
        const eventTime = event.timestamp.getTime();
        return eventTime >= dateRange.from.getTime() && eventTime <= dateRange.to.getTime();
      });
    } else {
      // 日期范围比较（不考虑时刻）
      // 对于 daily/weekly/monthly 产品，如果事件日期在 dateRange 的日期范围内，就计入
      const rangeStartDate = startOfDay(dateRange.from);
      const rangeEndDate = startOfDay(dateRange.to);
      
      return events.filter(event => {
        const eventDate = startOfDay(event.timestamp);
        // 事件日期 >= 范围起始日期 && 事件日期 <= 范围结束日期
        return eventDate >= rangeStartDate && eventDate <= rangeEndDate;
      });
    }
  };
}, [selectedProduct, dateRange]);
```

### 应用修复

在所有过滤风险事件的地方使用 `filterRiskEventsByDateRange`：

1. **缓存事件过滤**（第 136 行）
   ```typescript
   return filterRiskEventsByDateRange(cachedEvents);
   ```

2. **主要风险事件过滤**（第 215 行）
   ```typescript
   const filteredEvents = filterRiskEventsByDateRange(selectedDistrictEvents);
   ```

3. **地图标记数据过滤**（第 271 行）
   ```typescript
   const filteredEvents = filterRiskEventsByDateRange(allEvents);
   ```

### 导入依赖

添加 `startOfDay` 导入：
```typescript
import { format, startOfDay, isSameDay } from 'date-fns';
```

注意：`isSameDay` 已导入但未使用，可以保留以备将来使用。

## 修复验证

### 测试用例

1. **hourly 产品（Daily Heavy Rain）**
   - dateRange: `2025-12-16 17:00` 到 `2025-12-23 17:00`
   - 事件 `2025-12-16 16:00`：应该被排除（不在精确时间范围内）
   - 事件 `2025-12-16 17:00`：应该计入
   - 事件 `2025-12-23 17:00`：应该计入
   - 事件 `2025-12-23 18:00`：应该被排除（不在精确时间范围内）

2. **daily/weekly 产品（Weekly Accumulation）**
   - dateRange: `2025-12-16 17:00` 到 `2025-12-23 17:00`
   - 事件 `2025-12-16 08:00`：应该计入（在日期范围内）
   - 事件 `2025-12-16 23:59`：应该计入（在日期范围内）
   - 事件 `2025-12-23 00:00`：应该计入（在日期范围内）
   - 事件 `2025-12-23 23:59`：应该计入（在日期范围内）
   - 事件 `2025-12-15 23:59`：应该被排除（不在日期范围内）
   - 事件 `2025-12-24 00:00`：应该被排除（不在日期范围内）

3. **monthly 产品（Drought Defense）**
   - dateRange: `2025-12-16 17:00` 到 `2025-12-23 17:00`
   - 事件 `2025-12-16 08:00`：应该计入（在日期范围内）
   - 事件 `2025-12-23 23:59`：应该计入（在日期范围内）
   - 事件 `2025-12-15 23:59`：应该被排除（不在日期范围内）
   - 事件 `2025-12-24 00:00`：应该被排除（不在日期范围内）

## 修复文件清单

1. `Next-gen-index/src/hooks/useRiskAnalysis.ts`
   - 添加 `filterRiskEventsByDateRange` 辅助函数
   - 更新所有过滤逻辑使用新的辅助函数
   - 添加 `startOfDay` 导入

## 注意事项

1. **日期比较**
   - 使用 `startOfDay` 确保日期比较时忽略时刻
   - 对于 daily/weekly/monthly 产品，只比较日期部分

2. **边界处理**
   - 对于 hourly 产品：包括边界时刻（`>=` 和 `<=`）
   - 对于 daily/weekly/monthly 产品：包括边界日期（`>=` 和 `<=`）

3. **性能考虑**
   - `filterRiskEventsByDateRange` 使用 `useMemo` 缓存，避免重复创建函数
   - 依赖项包括 `selectedProduct` 和 `dateRange`，确保产品或时间范围变化时重新创建

---

**文档版本**：v1.0  
**创建日期**：2025-12-18  
**修复状态**：✅ 已修复

