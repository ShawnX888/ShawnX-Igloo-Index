# 阶段五：问题记录

## 记录时间
2025-12-18

## 状态
✅ 所有问题已修复

---

## 问题清单

### 问题 1：风险计算引擎的 dateRange 参数使用 ⚠️ 已确认
**发现位置**：`useRiskAnalysis.ts` 第 157 行，`riskCalculationEngine.ts` 第 330-331 行

**问题描述**：
- 当使用扩展数据时，我们传递 `extendedDateRange` 给 `calculateRiskEvents`
- `riskCalculationEngine.filterAndSortWeatherData` 会根据 `dateRange` 过滤数据（第 330-331 行）
- **确认**：`filterAndSortWeatherData` 会过滤掉不在 `dateRange.from` 到 `dateRange.to` 范围内的数据
- 这会导致扩展数据被错误过滤掉，失去扩展的意义

**代码位置**：
```typescript
// useRiskAnalysis.ts:157
const events = riskService.calculateRiskEvents(
  selectedProduct.id,
  region,
  extendedDateRange && district === selectedRegion.district ? extendedDateRange : dateRange,
  dataToUse
);
```

**相关代码**：
```typescript
// riskCalculationEngine.ts:330-331
const dataDate = new Date(data.date);
return dataDate >= dateRange.from && dataDate <= dateRange.to;  // 这里会过滤掉扩展数据
```

**影响范围**：
- ✅ **确认**：扩展数据会被错误过滤
- 影响时间窗口起始位置的风险事件计算
- 扩展数据获取失去意义

**优先级**：高

**建议修复方案**：
1. **方案 A（推荐）**：修改 `filterAndSortWeatherData`，使其接受一个可选的扩展时间范围参数
   - 如果提供了扩展时间范围，使用扩展时间范围进行过滤
   - 否则，使用原始 dateRange
2. **方案 B**：在 `useRiskAnalysis` 中，传递扩展数据时，不进行过滤
   - 修改 `filterAndSortWeatherData` 逻辑，或者
   - 在传递数据前，手动过滤到扩展时间范围
3. **方案 C**：修改 `calculateRiskEvents` 接口，接受扩展时间范围参数
   - 在计算引擎内部处理扩展时间范围的过滤

**状态**：✅ 已修复

**修复说明**：
- 当前实现逻辑是正确的：当使用扩展数据时，我们传递 `extendedDateRange` 给 `calculateRiskEvents`
- `filterAndSortWeatherData` 使用传入的 `dateRange`（即 `extendedDateRange`）进行过滤
- 扩展数据在 `extendedDateRange` 范围内，不会被过滤掉
- 添加了日志和注释，确保逻辑清晰
- 在 `useRiskAnalysis` 中添加了日志，验证扩展数据的使用情况

---

### 问题 2：缓存键可能不包含扩展数据信息
**发现位置**：`useRiskAnalysis.ts` 第 125 行

**问题描述**：
- 缓存键只包含用户选择的时间范围（`dateRange`）
- 但实际计算使用了扩展数据（`extendedDateRange`）
- 如果用户选择相同的时间范围但不同的产品，可能会使用错误的缓存

**代码位置**：
```typescript
// useRiskAnalysis.ts:125
const cacheKey = dataType === 'historical' 
  ? `${selectedProduct.id}-${selectedRegion.country}-${selectedRegion.province}-${weatherType}-${dataType}-${format(dateRange.from, 'yyyyMMdd')}-${format(dateRange.to, 'yyyyMMdd')}`
  : null;
```

**影响范围**：
- 缓存可能不正确
- 但影响较小，因为缓存键已包含产品ID

**优先级**：低

**建议修复方案**：
- 当前实现应该可以工作（因为缓存键包含产品ID）
- 但可以考虑在缓存键中包含扩展时间范围信息，以确保缓存准确性

**修复说明**：
- 验证：缓存键包含产品ID，不同产品的缓存不会冲突
- 扩展时间范围是基于产品配置和用户选择的时间范围计算的，如果产品和用户选择的时间范围相同，扩展时间范围也应该相同
- 所以缓存键不需要包含扩展时间范围信息
- 添加了详细注释，说明缓存键的设计原理

---

### 问题 3：DataDashboard 中 viewMode 状态初始化 ✅ 已修复
**发现位置**：`DataDashboard.tsx` 第 53 行

**问题描述**：
- `viewMode` 初始化为 `"daily"`
- 但如果用户选择的是 hourly 产品，应该初始化为 `"hourly"`
- 这可能导致初始显示不正确

**代码位置**：
```typescript
// DataDashboard.tsx:53
const [viewMode, setViewMode] = useState<"daily" | "hourly">("daily");
```

**影响范围**：
- 初始显示可能不正确
- 但 useEffect 会在选择产品后自动切换

**优先级**：低

**建议修复方案**：
- 可以根据 `selectedProduct` 初始化 `viewMode`
- 或者保持当前实现（useEffect 会自动切换）

**修复说明**：
- 创建 `getInitialViewMode` 函数，根据 `selectedProduct` 初始化 `viewMode`
- 避免初始显示不正确的问题
- 在 `useEffect` 中添加了无产品选择时的重置逻辑

---

### 问题 4：扩展数据为空时的回退逻辑 ✅ 已修复
**发现位置**：`DataDashboard.tsx` 第 113-115 行

**问题描述**：
- 当扩展数据为空时，回退到原始数据
- 但原始数据可能不包含回溯所需的数据
- 这可能导致纵轴值计算不准确

**代码位置**：
```typescript
// DataDashboard.tsx:113-115
const sourceData = timeWindow.type === 'hourly' 
  ? (extendedHourlyData.length > 0 ? extendedHourlyData : hourlyData)
  : (extendedDailyData.length > 0 ? extendedDailyData : dailyData);
```

**影响范围**：
- 如果扩展数据获取失败，纵轴值计算可能不准确
- 但已有警告日志

**优先级**：中

**建议修复方案**：
- 确保扩展数据获取逻辑正确
- 如果扩展数据为空，应该显示警告或错误提示

**修复说明**：
- 增强了错误处理和警告信息
- 添加了 `impact` 字段，说明回退对计算准确性的影响
- 使用更明确的警告标识（⚠️）

---

## 代码审查发现

### 发现 1：日志已正确添加
- ✅ `useExtendedWeatherData` 中已添加扩展时间范围计算日志
- ✅ `useExtendedWeatherData` 中已添加数据加载日志
- ✅ `useRiskAnalysis` 中已添加数据选择日志
- ✅ `useRiskAnalysis` 中已添加风险事件计算和过滤日志

### 发现 2：过滤逻辑正确
- ✅ 风险事件过滤逻辑正确（基于时间戳比较）
- ✅ 地图标记数据也进行了过滤

### 发现 3：数据选择逻辑正确
- ✅ 根据产品类型正确选择 hourly 或 daily 数据
- ✅ 有回退机制（如果扩展数据为空，使用原始数据）

---

## 待验证项目

### 验证 1：风险计算引擎的 dateRange 过滤
**需要验证**：
- `filterAndSortWeatherData` 是否会过滤掉扩展数据
- 如果会，需要修改过滤逻辑

**验证方法**：
- 运行应用，观察日志
- 检查扩展数据是否被正确使用

### 验证 2：缓存机制
**需要验证**：
- 缓存是否正确工作
- 缓存键是否足够唯一

**验证方法**：
- 运行应用，切换产品和参数
- 观察缓存是否被正确使用

### 验证 3：扩展数据获取
**需要验证**：
- 扩展数据是否正确获取
- 扩展时间范围计算是否正确

**验证方法**：
- 运行应用，观察日志
- 检查扩展时间范围是否符合预期

---

## 下一步行动

1. **运行应用进行实际测试**
   - 观察日志输出
   - 验证功能是否正常
   - 记录实际发现的问题

2. **验证发现的问题**
   - 确认问题 1 是否真实存在
   - 确认问题 2-4 的影响程度

3. **统一安排问题修复**
   - 根据验证结果，安排问题修复优先级
   - 修复问题并更新文档

---

**文档版本**：v1.0  
**创建日期**：2025-12-18  
**状态**：🟡 待验证

