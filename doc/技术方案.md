# 东南亚 Index Insurance 门户网站 - 技术方案文档

## 1. 项目概述

### 1.1 项目背景
基于需求分析文档，本项目需要将现有的 SVG 模拟地图替换为真实的 Google Maps JavaScript API 实现，并集成 Google Contextual View AI kit，打造一个功能完整的东南亚 Index Insurance 门户网站。

### 1.2 技术目标
- 集成 Google Maps JavaScript API 实现真实地图渲染
- 实现 4 个数据图层（历史/预测降雨量热力图、历史/预测风险事件）
- 集成 Google Contextual View AI kit 实现智能对话功能
- 保持现有 UI/UX 设计风格（参考 Google Maps Platform 和 Apple App Store）
- 优化数据计算和渲染性能

### 1.3 技术约束
- 前端代码已存在于 `Next-gen-index/src` 目录
- 必须使用 Google Maps JavaScript API 构建地图
- AI 咨询窗口必须使用 Google Contextual View AI kit 和 Grounding Lite MCP
- 目前仅使用 Mock rainfall data，不接入真实天气 API

---

## 2. 技术架构

### 2.1 技术栈

#### 2.1.1 前端框架（已存在）
- **React 19**：用于构建用户界面
- **TypeScript**：提供类型安全
- **Vite**：构建工具和开发服务器
- **Tailwind CSS**：样式框架
- **Recharts**：数据可视化图表库
- **Framer Motion**：动画库

#### 2.1.2 地图与 AI 集成（需新增）
- **Google Maps JavaScript API**：地图渲染和交互
- **Google Contextual View AI kit**：AI 对话界面
- **Grounding Lite MCP**：自然语言理解和参数提取

### 2.2 架构设计

#### 2.2.1 组件架构
```
App
├── Header
└── Main
    ├── Dashboard (首页)
    │   ├── MapWorkspace (地图工作区)
    │   │   ├── Google Maps Container
    │   │   ├── Layer Controls (图层控制)
    │   │   └── Overlays (数据图层)
    │   ├── ControlPanel (手动选择面板)
    │   ├── ContextualAssistant (AI 对话面板)
    │   ├── ProductSelector (产品选择器)
    │   └── DataDashboard (数据面板)
    └── ProductIntro (产品介绍页)
```

#### 2.2.2 数据流设计
```
用户操作 (手动/AI)
    ↓
参数变更 (selectedRegion, rainfallType, dateRange, selectedProduct)
    ↓
Mock 数据生成/补充 (useMemo 缓存)
    ↓
风险计算引擎 (从产品库获取产品规则)
    ↓
风险事件计算 (基于产品级规则)
    ↓
地图渲染更新 (图层更新)
    ↓
数据面板更新 (图表更新)
```

#### 2.2.3 核心模块架构
```
保险产品库 (Product Library)
    ├── 产品定义 (产品级规则)
    │   ├── 触发条件
    │   ├── 阈值配置
    │   └── 风险级别定义
    └── 保单定义 (保单级规则) [未来扩展]
        ├── 赔付金额
        ├── 赔付次数限制
        └── 赔付条件

风险计算引擎 (Risk Calculation Engine)
    ├── 产品规则解析器
    ├── 风险事件计算器
    └── 结果格式化器

数据层
    ├── Mock 数据生成器
    └── 区域数据管理
```

---

## 3. Google Maps JavaScript API 集成方案

### 3.1 地图初始化

#### 3.1.1 API 加载方式
使用动态库加载（`importLibrary`）而非静态 script 标签，符合 Google Maps Platform 最佳实践：

```typescript
// 动态加载 Google Maps JavaScript API
const { Map } = await google.maps.importLibrary("maps") as google.maps.MapsLibrary;
const { AdvancedMarkerElement } = await google.maps.importLibrary("marker");
const { Data } = await google.maps.importLibrary("maps/data");
```

#### 3.1.2 地图配置
- **Map ID**：创建自定义 Map ID 用于样式定制
- **API Key**：使用项目配置的 Google API Key（开发/测试环境）
- **版本**：使用 `weekly` 版本以获取最新功能
- **Attribution**：包含 `internal-usage-attribution-ids: "gmp_mcp_codeassist_v0.1_github"`

#### 3.1.3 地图容器替换
将现有的 `MapWorkspace` 组件中的 SVG 模拟地图替换为真实的 Google Maps 容器：

```typescript
// 替换策略
<div id="map-container" className="w-full h-full" />
// 使用 useEffect 初始化地图实例
```

### 3.2 数据图层实现方案

#### 3.2.1 图层 1 & 2：降雨量热力图

**技术选型：Data Layer + Polygon + 自定义渐变**

**方案对比：**
- ❌ **HeatmapLayer（官方热力图）**：难以实现"从中心往边界逐渐变浅"的晕染效果，难以精确控制行政区域边界
- ✅ **Data Layer + Polygon + Gradient**：完全可控，可以实现精确的行政区域边界和渐变效果（推荐）
- ⚠️ **WebGL Overlay View + deck.gl**：性能最佳但实现复杂度高，适合未来大数据量场景

**实现要点：**
1. 使用 `google.maps.Data` 加载行政区域边界数据（GeoJSON 格式）
2. 为每个行政区域创建 Polygon，设置自定义样式
3. 使用径向渐变（Radial Gradient）实现"从中心往边界逐渐变浅"效果
4. 根据降雨量数据动态调整颜色深度和透明度
5. 历史数据使用蓝色系，预测数据使用紫色系

**数据结构：**
```typescript
interface RainfallHeatmapData {
  district: string;
  center: { lat: number; lng: number };
  boundary: google.maps.LatLngLiteral[]; // Polygon 路径
  rainfall: number; // 降雨量值
  type: 'historical' | 'predicted';
}
```

#### 3.2.2 图层 3 & 4：风险事件标记

**技术选型：Advanced Markers + 自定义 Overlay**

**实现要点：**
1. 使用 `AdvancedMarkerElement` 创建可自定义的标记
2. 使用 HTML/CSS 创建圆形标记，支持动态大小和颜色
3. 使用 Framer Motion 或 CSS 动画实现"风险从无到有"的动画效果
4. 标记大小和颜色深度根据风险事件数量动态计算
5. 选中区域在标记中心显示事件数量文本

**动画实现：**
```typescript
// 使用 CSS 动画或 Framer Motion
const animationStyle = {
  animation: 'risk-emerge 2.5s ease-out infinite',
  '@keyframes risk-emerge': {
    '0%': { scale: 0, opacity: 0 },
    '50%': { scale: 1.1, opacity: 1 },
    '100%': { scale: 1, opacity: 0.8 }
  }
};
```

#### 3.2.3 图层控制

**实现要点：**
1. 使用 Popover 组件（已存在）创建图层控制菜单
2. 根据 `rainfallType` 动态显示可操作的图层
3. 历史数据模式：仅"Historical Rainfall"可操作
4. 预测数据模式：仅"Predicted Rainfall"可操作
5. 风险事件图层：仅在选中产品时可用
6. UI 设计参考 Google Maps 的图层控制样式

### 3.3 行政区域数据处理

#### 3.3.1 区域数据结构
```typescript
interface AdministrativeRegion {
  country: string;
  province: string;
  district: string;
  center: { lat: number; lng: number };
  boundary: google.maps.LatLngLiteral[]; // GeoJSON 格式的边界坐标
}
```

#### 3.3.2 区域边界数据获取

**挑战：**
- Google Maps JavaScript API 本身不直接提供行政区域边界
- 需要外部数据源或使用 Places API 的边界信息

**解决方案：**
1. **方案 A（推荐）**：预处理边界数据
   - 从 OpenStreetMap 或其他地理数据源获取行政区域边界
   - 转换为 GeoJSON 格式
   - 存储为静态 JSON 文件或通过 API 提供
   - 按"省/州"级别组织数据，包含所有"市/区"的边界

2. **方案 B（备选）**：使用 Places API
   - 使用 Places API (New) 获取地点边界信息
   - 成本较高，需要评估 API 调用量

3. **方案 C（临时）**：使用简化边界
   - 对于演示阶段，可以使用简化的矩形或圆形边界
   - 后续再替换为真实边界数据

#### 3.3.3 区域选择交互

**手动选择：**
- 模糊搜索：使用本地搜索算法匹配区域名称
- 层级选择：三级下拉选择器（国家 → 省/州 → 市/区）
- 地图点击：点击地图上的区域 Polygon 直接选择
- GPS 一键定位：获取用户 GPS 坐标并转换为行政区域

**AI 选择：**
- 通过 Grounding Lite MCP 解析区域名称
- 支持自然语言描述（如"印尼雅加达的南部"）

#### 3.3.4 GPS 定位与反向地理编码

**功能概述：**
实现地图上的一键定位功能，能够识别用户的 GPS 定位并自动转换为对应的"国家 - 省/州 - 市/区"行政区域。

**技术实现方案：**

1. **GPS 定位获取**
   - 使用浏览器原生 Geolocation API（`navigator.geolocation.getCurrentPosition()`）
   - 请求用户位置权限（首次使用时）
   - 获取经纬度坐标（lat, lng）
   - 处理定位失败情况（用户拒绝、定位超时、设备不支持等）

2. **反向地理编码（Reverse Geocoding）**
   - 使用 Google Geocoding API 的 Reverse Geocoding 功能
   - 将 GPS 坐标（lat, lng）转换为地址信息
   - 从地址信息中提取行政区域层级：
     - 国家（country）
     - 省/州（administrative_area_level_1）
     - 市/区（administrative_area_level_2 或 locality）

3. **区域匹配与验证**
   - 验证定位结果是否在东南亚国家范围内
   - 如果不在范围内，提示用户并保持当前选择
   - 如果定位成功，自动设置选中的区域
   - 更新地图视图，自动缩放到定位区域

4. **UI 交互设计**
   - 定位按钮：位于地图控制区域（图层控制附近）
   - 定位状态反馈：
     - 定位中：显示加载动画
     - 定位成功：显示成功提示，地图自动定位
     - 定位失败：显示错误提示（权限被拒绝、定位超时等）

**API 使用：**
- **Geolocation API**：浏览器原生 API，无需额外配置
- **Google Geocoding API**：已开启，使用 Reverse Geocoding 端点
  - 端点：`https://maps.googleapis.com/maps/api/geocode/json?latlng={lat},{lng}&key={API_KEY}`
  - 返回结果中包含 `address_components`，可提取行政区域信息

**错误处理：**
- 用户拒绝位置权限：提示用户需要位置权限才能使用此功能
- 定位超时：提示用户定位超时，请重试
- 设备不支持：提示浏览器不支持定位功能
- 定位位置不在东南亚：提示用户当前定位不在服务范围内
- API 调用失败：提示网络错误，请稍后重试

**性能考虑：**
- 缓存定位结果，避免频繁请求
- 使用防抖（debounce）避免重复点击
- 定位成功后，自动触发数据加载和地图更新

---

## 4. Google Contextual View AI kit 集成方案

### 4.1 Contextual View 组件集成

#### 4.1.1 组件结构
根据 Google Maps Platform 文档，Contextual View 使用 Web Component 方式集成：

```html
<gmp-place-contextual id="widget"></gmp-place-contextual>
```

#### 4.1.2 React 集成方式
在 React 组件中使用 `useEffect` 和 `useRef` 集成 Web Component：

```typescript
useEffect(() => {
  const widget = document.querySelector('#contextual-widget') as any;
  if (widget && contextToken) {
    widget.contextToken = contextToken;
  }
}, [contextToken]);
```

#### 4.1.3 布局设计
- **位置**：地图右侧，1/4 宽度
- **高度**：`calc(100% - 2rem)`，与地图容器等高
- **样式**：参考 Google Maps 的侧边栏设计
- **交互**：支持最小化/最大化，与手动选择面板互斥

### 4.2 Grounding Lite MCP 集成

#### 4.2.1 自然语言理解
使用 Grounding Lite MCP 解析用户输入，提取以下参数：
- **行政区域**：国家、省/州、市/区
- **数据类型**：历史降雨量 / 预测降雨量
- **时间范围**：起止日期和时刻
- **保险产品**：产品 ID 或名称

#### 4.2.2 API 调用方式
根据 Google Maps Platform 文档，需要调用 Vertex AI API 并配置 Google Maps grounding：

```typescript
// 伪代码示例
const response = await fetch(vertexAIEndpoint, {
  method: 'POST',
  body: JSON.stringify({
    contents: [{ role: 'user', parts: [{ text: userInput }] }],
    systemInstruction: { parts: { text: systemInstructions } },
    tools: {
      googleMaps: {
        authConfig: {
          apiKeyConfig: { name: 'api_key', apiKeyString: apiKey }
        }
      }
    },
    model: `projects/${projectNumber}/locations/us-central1/publishers/google/models/${modelId}`
  })
});

const { googleMapsWidgetContextToken } = response;
```

#### 4.2.3 状态同步机制
1. AI 对话解析参数 → 更新全局状态
2. 全局状态变更 → 触发地图重新渲染和数据重新计算
3. 手动选择修改参数 → 更新全局状态 → AI 对话界面显示当前参数

---

## 5. 数据计算与性能优化

### 5.1 Mock 数据生成策略

#### 5.1.1 数据生成时机
- **触发条件**：用户选择"市/区"后
- **生成范围**：选择的"市/区"所属的"省/州"下所有的"市/区"
- **时间范围**：过去 40 天至未来 10 天
- **数据粒度**：小时级数据和日级数据

#### 5.1.2 缓存优化
使用 `useMemo` 缓存已生成的数据：

```typescript
const allRegionsData = useMemo(() => {
  // 检查缓存
  // 如果存在且完整，直接返回
  // 如果部分缺失，只补充缺失部分
  // 如果完全缺失，生成新数据
}, [selectedRegion, dateRange, rainfallType]);
```

#### 5.1.3 数据格式
```typescript
interface RainfallData {
  date: string; // ISO 格式
  amount: number; // 降雨量 (mm)
  risk?: 'low' | 'medium' | 'high';
}

interface RegionData {
  [districtName: string]: RainfallData[];
}
```

### 5.2 保险产品库设计

#### 5.2.1 产品库架构

**设计目标：**
- 支持多种不同类型的保险产品
- 产品级和保单级规则分离，便于维护和扩展
- 支持未来添加新产品类型，无需修改核心计算逻辑
- 产品配置与业务逻辑解耦

**产品库结构：**

1. **产品级定义（Product-Level Definition）**
   - **产品基本信息**：产品 ID、名称、描述、图标、产品类型
   - **风险事件触发条件**：
     - 触发规则类型（日内/周度/月度等）
     - 时间窗口定义（如 4 小时、7 天、1 个月）
     - 阈值配置（多档阈值及对应的风险级别）
     - 计算逻辑（累计方式、比较运算符等）
   - **风险级别定义**：low、medium、high 的判定标准

2. **保单级定义（Policy-Level Definition）**（未来扩展）
   - **赔付原则**：
     - 赔付金额计算规则（固定金额/按比例/分级赔付）
     - 赔付次数限制（每日/每月/每年最多赔付次数）
     - 赔付条件（是否叠加、是否互斥等）
   - **保单配置**：
     - 保额设置
     - 保费计算规则
     - 免赔额设置

#### 5.2.2 产品库数据模型

**产品级数据模型：**
```
产品 (Product)
├── id: 产品唯一标识
├── name: 产品名称
├── type: 产品类型 (daily/weekly/monthly/...)
├── description: 产品描述
├── icon: 产品图标
└── riskRules: 风险事件触发规则
    ├── triggerType: 触发类型
    ├── timeWindow: 时间窗口配置
    ├── thresholds: 阈值配置数组
    │   ├── value: 阈值数值
    │   ├── level: 风险级别
    │   └── label: 阈值标签
    └── calculation: 计算逻辑配置
        ├── aggregation: 累计方式
        ├── operator: 比较运算符
        └── unit: 数据单位
```

**保单级数据模型**（未来扩展）：
```
保单 (Policy)
├── id: 保单唯一标识
├── productId: 关联的产品 ID
├── coverage: 保额配置
├── premium: 保费配置
└── payoutRules: 赔付规则
    ├── payoutAmount: 赔付金额计算规则
    ├── payoutLimit: 赔付次数限制
    └── payoutConditions: 赔付条件
```

#### 5.2.3 产品库管理方式

**存储方式：**
- **当前阶段**：使用静态 JSON 配置文件存储产品定义
- **未来扩展**：可迁移到数据库或配置服务，支持动态更新

**产品注册机制：**
- 产品定义遵循统一的数据模型和接口规范
- 新增产品时，只需添加产品定义配置，无需修改核心代码
- 支持产品版本管理（如果需要）

**产品类型扩展：**
- 通过配置化的方式支持新的产品类型
- 风险计算引擎通过产品类型动态选择计算策略
- 支持自定义计算逻辑（通过配置或插件方式）

### 5.3 风险计算引擎设计

#### 5.3.1 引擎架构

**设计原则：**
- 与产品库解耦：引擎不直接依赖具体产品实现
- 可扩展性：支持新增产品类型和计算规则
- 高性能：支持实时计算和批量计算
- 可测试性：计算逻辑独立，便于单元测试

**引擎组件：**

1. **产品规则解析器（Product Rule Parser）**
   - 从产品库加载产品定义
   - 解析产品级风险触发规则
   - 验证规则配置的有效性
   - 生成可执行的计算配置

2. **风险事件计算器（Risk Event Calculator）**
   - 根据产品类型选择计算策略
   - 执行时间窗口滑动计算
   - 应用阈值判断逻辑
   - 生成风险事件列表

3. **结果格式化器（Result Formatter）**
   - 格式化风险事件数据
   - 计算风险统计信息（事件数量、级别分布等）
   - 生成可视化所需的数据结构

#### 5.3.2 计算流程

**产品级风险事件计算流程：**

1. **输入参数**
   - 选中的产品（从产品库获取产品定义）
   - 选中的区域（市/区）
   - 数据类型（历史/预测）
   - 时间范围（起止日期和时刻）
   - 降雨量数据（Mock 数据或真实数据）

2. **规则加载**
   - 从产品库获取产品的风险触发规则
   - 解析时间窗口配置
   - 加载阈值配置数组

3. **数据预处理**
   - 根据产品类型选择数据粒度（小时级/日级）
   - 按时间窗口要求组织数据
   - 执行数据累计计算（如 4 小时累计、7 天累计等）

4. **风险事件计算**
   - 遍历时间窗口，执行滑动计算
   - 对每个窗口应用阈值判断
   - 记录触发的事件（时间、级别、类型）

5. **结果输出**
   - 风险事件列表（包含时间、区域、级别、产品信息）
   - 风险统计信息（总事件数、级别分布、时间分布等）
   - 可视化数据（用于地图标记和数据面板图表）

#### 5.3.3 计算策略

**日内产品计算策略：**
- 数据粒度：小时级数据
- 时间窗口：4 小时滑动窗口
- 累计方式：包含当前小时和此前连续 3 小时的累计值
- 阈值判断：累计值 > 阈值（多档阈值对应不同风险级别）
- 触发限制：每天最多触发一次

**周度产品计算策略：**
- 数据粒度：日级数据
- 时间窗口：7 天滑动窗口
- 累计方式：包含当天和此前连续 6 天的累计值
- 阈值判断：累计值 > 阈值（多档阈值对应不同风险级别）
- 触发限制：每月最多触发一次

**月度产品计算策略：**
- 数据粒度：日级数据
- 时间窗口：完整自然月
- 累计方式：当月所有日期的累计值
- 阈值判断：累计值 < 阈值（多档阈值对应不同风险级别）
- 触发限制：每月最多触发一次

**扩展性设计：**
- 通过配置化的计算策略，支持新增产品类型
- 计算策略可注册到引擎的策略注册表中
- 支持自定义计算函数（通过配置或插件方式）

#### 5.3.4 保单级计算引擎（未来扩展）

**设计预留：**
- 在风险计算引擎中预留保单级计算接口
- 保单级计算依赖产品级风险事件结果
- 赔付计算逻辑：
  - 输入：风险事件列表、保单配置
  - 处理：应用赔付规则（金额计算、次数限制、条件判断）
  - 输出：赔付金额、赔付次数、赔付时间线

**协同关系：**
- 产品级计算：生成风险事件
- 保单级计算：基于风险事件计算赔付
- 两层计算相互独立，可单独启用或组合使用

#### 5.3.5 性能优化

**计算优化：**
- 使用 `useMemo` 缓存计算结果
- 参数变更时只重新计算受影响的部分
- 使用增量计算，只计算新增时间窗口
- 考虑使用 Web Worker 进行复杂计算（如果数据量很大）

**产品库优化：**
- 产品定义预加载，避免运行时加载延迟
- 产品规则缓存，避免重复解析
- 支持产品定义的热更新（未来扩展）

### 5.4 产品库与风险计算引擎协同

#### 5.4.1 协同机制

**数据流向：**
```
产品选择
    ↓
产品库 (获取产品定义)
    ↓
风险计算引擎 (解析规则)
    ↓
执行计算 (使用降雨量数据)
    ↓
生成风险事件 (产品级)
    ↓
[未来] 保单级计算 (基于风险事件)
    ↓
输出结果 (可视化数据)
```

**接口设计：**
- 产品库提供统一的产品查询接口
- 风险计算引擎提供统一的计算接口
- 两者通过标准化的数据模型交互
- 支持依赖注入，便于测试和扩展

#### 5.4.2 扩展性支持

**新产品类型扩展：**
1. 在产品库中添加新产品定义（遵循数据模型）
2. 在风险计算引擎中注册新的计算策略（如果需要）
3. 无需修改现有产品和计算逻辑

**保单级功能扩展：**
1. 在产品库中添加保单级定义
2. 在风险计算引擎中实现保单级计算逻辑
3. 与产品级计算结果协同，生成赔付数据

**计算逻辑扩展：**
- 支持自定义计算函数（通过配置或插件）
- 支持复杂计算规则（多条件组合、时间序列分析等）
- 支持机器学习模型集成（未来扩展）

### 5.5 地图渲染优化

#### 5.5.1 图层管理
- 使用图层可见性控制，而非重新创建
- 数据更新时使用增量更新，只更新变更的区域
- 图层切换时使用淡入淡出动画

#### 5.5.2 动画性能
- 使用 CSS `transform` 和 GPU 加速
- 使用 `will-change` 属性提示浏览器优化
- 限制同时播放的动画数量

#### 5.5.3 大数据量处理
- 如果区域数量很多，考虑使用聚类（Clustering）
- 使用数据采样，只渲染可见区域的数据
- 使用虚拟滚动或分页加载

---

## 6. UI/UX 设计实现

### 6.1 设计参考

#### 6.1.1 Google Maps Platform 设计元素
- **图层控制**：圆形按钮 + Popover 菜单，位于地图右下角
- **搜索框**：简洁的输入框，支持自动完成
- **侧边栏**：右侧滑出面板，1/4 宽度
- **Overlay 设计**：不超出地图边界，半透明背景

#### 6.1.2 Apple App Store 设计元素
- **产品卡片**：圆角卡片，图标 + 文字描述
- **页面布局**：清晰的视觉层次
- **交互反馈**：平滑的过渡动画

### 6.2 组件样式实现

#### 6.2.1 手动选择面板（ControlPanel）
- **位置**：地图左上角（激活时）
- **样式**：白色背景，圆角，阴影
- **功能区域**：
  - 区域选择（模糊搜索 + 下拉）
  - 数据类型切换（单选按钮）
  - 时间范围选择（日期选择器 + 小时选择器）
  - 产品选择（产品卡片）

#### 6.2.2 AI 对话面板（ContextualAssistant）
- **位置**：地图右侧，1/4 宽度
- **样式**：白色背景，圆角，阴影
- **功能**：
  - 对话输入框
  - 消息列表
  - 参数显示（当前选择的区域、时间、产品等）

#### 6.2.3 图层控制
- **位置**：地图右下角
- **样式**：圆形按钮，点击展开 Popover
- **内容**：
  - Historical Rainfall（历史降雨量）
  - Predicted Rainfall（预测降雨量）
  - Risk Events（风险事件）

#### 6.2.4 GPS 定位按钮
- **位置**：地图控制区域，位于图层控制附近（右下角）
- **样式**：圆形按钮，参考 Google Maps 的定位按钮设计
- **功能**：
  - 点击后获取用户 GPS 位置
  - 显示定位状态（定位中/成功/失败）
  - 定位成功后自动设置区域并更新地图视图
- **交互反馈**：
  - 定位中：按钮显示加载动画
  - 定位成功：短暂显示成功提示
  - 定位失败：显示错误提示（权限被拒绝、超时等）

### 6.3 响应式设计

#### 6.3.1 桌面端
- 地图固定高度：600px
- 数据面板：流式布局，自适应宽度
- Overlay 面板：固定宽度（1/4 或根据内容）

#### 6.3.2 移动端
- 地图：全屏高度
- Overlay 面板：自适应宽度，可滑动
- 数据面板：垂直堆叠

---

## 7. 关键技术决策

### 7.1 地图图层实现

**决策：使用 Data Layer + Polygon + 自定义渐变**

**理由：**
1. 可以精确控制行政区域边界
2. 可以实现"从中心往边界逐渐变浅"的渐变效果
3. 性能可接受，实现复杂度适中
4. 未来可以升级到 WebGL Overlay View + deck.gl

### 7.2 AI 对话集成

**决策：使用 Google Contextual View AI kit + Grounding Lite MCP**

**理由：**
1. 符合需求文档要求
2. 官方支持，文档完善
3. 与 Google Maps 深度集成
4. 支持自然语言理解和参数提取

### 7.3 状态管理

**决策：使用 React useState + useMemo，不引入 Redux**

**理由：**
1. 状态结构相对简单，不需要复杂的状态管理
2. 减少依赖，保持项目轻量
3. 使用 `useMemo` 可以满足性能需求

### 7.4 数据存储

**决策：客户端实时生成 Mock 数据，使用 useMemo 缓存**

**理由：**
1. 符合当前需求（仅使用 Mock 数据）
2. 无需后端服务，简化架构
3. 未来可以轻松替换为真实 API 调用

### 7.5 保险产品库与风险计算引擎分离

**决策：设立独立的保险产品库和风险计算引擎，两者协同工作**

**理由：**
1. **可扩展性**：支持未来添加更多不同类型的产品，无需修改核心计算逻辑
2. **可维护性**：产品配置与业务逻辑分离，便于产品管理和规则更新
3. **可测试性**：产品库和计算引擎独立，便于单元测试和集成测试
4. **灵活性**：支持产品级和保单级两层定义，当前实现产品级，未来可扩展保单级
5. **解耦设计**：产品定义通过配置化方式管理，计算引擎通过接口调用，降低耦合度

---

## 8. 实施优先级

### 8.1 高优先级（核心功能）
1. ✅ Google Maps JavaScript API 基础集成
2. ✅ 地图容器替换（SVG → Google Maps）
3. ✅ 行政区域边界绘制（Polygon）
4. ✅ 降雨量热力图图层实现
5. ✅ 风险事件标记图层实现
6. ✅ 图层控制功能
7. ✅ 保险产品库设计与实现（产品级定义）
8. ✅ 风险计算引擎设计与实现（产品级计算）
9. ✅ 产品库与计算引擎协同机制

### 8.2 中优先级（增强功能）
1. ⚠️ AI 对话集成（Contextual View + Grounding Lite）
2. ⚠️ 行政区域数据获取和处理
3. ⚠️ 区域选择交互（手动 + AI + 地图点击）
4. ⚠️ GPS 定位与反向地理编码功能
5. ⚠️ 产品库扩展（支持更多产品类型）
6. ⚠️ 计算引擎优化（性能优化、策略扩展）
7. ⚠️ 动画效果优化
8. ⚠️ 性能优化（缓存、增量更新）

### 8.3 低优先级（优化功能）
1. 📋 响应式设计完善
2. 📋 错误处理和边界情况
3. 📋 可访问性（Accessibility）优化
4. 📋 国际化支持（如果需要）

### 8.4 未来扩展（保单级功能）
1. 🔮 保单级定义添加到产品库
2. 🔮 保单级计算引擎实现
3. 🔮 赔付可视化功能
4. 🔮 保单管理界面（如果需要）

---

## 9. 技术风险与应对

### 9.1 行政区域边界数据获取

**风险：** Google Maps 不直接提供行政区域边界，需要外部数据源

**应对：**
1. 使用 OpenStreetMap 或其他地理数据源
2. 预处理边界数据，转换为 GeoJSON 格式
3. 存储为静态文件或通过 API 提供
4. 临时方案：使用简化边界（矩形/圆形）

### 9.2 Google Contextual View AI kit 集成

**风险：** API 文档可能不完整，集成方式需要探索

**应对：**
1. 查阅最新官方文档
2. 参考官方示例代码
3. 使用 MCP 工具查询相关文档
4. 如果遇到问题，考虑使用替代方案（自定义对话界面 + Grounding Lite）

### 9.3 地图渲染性能

**风险：** 大量区域和数据的渲染可能导致性能问题

**应对：**
1. 使用图层可见性控制
2. 实现增量更新机制
3. 使用数据采样和聚类
4. 优化动画性能（GPU 加速）
5. 考虑使用 WebGL Overlay View（未来升级）

### 9.4 数据计算性能

**风险：** 复杂的产品规则计算可能阻塞 UI 线程

**应对：**
1. 使用 `useMemo` 缓存计算结果
2. 参数变更时只重新计算受影响部分
3. 如果数据量很大，考虑使用 Web Worker
4. 实现加载状态和进度提示

---

## 10. 参考文档与资源

### 10.1 Google Maps Platform 文档
- [Maps JavaScript API 文档](https://developers.google.com/maps/documentation/javascript?utm_source=gmp-code-assist)
- [Advanced Markers 文档](https://developers.google.com/maps/documentation/javascript/advanced-markers?utm_source=gmp-code-assist)
- [Data Layer 文档](https://developers.google.com/maps/documentation/javascript/data?utm_source=gmp-code-assist)
- [Geocoding API 文档](https://developers.google.com/maps/documentation/geocoding?utm_source=gmp-code-assist)
- [Grounding with Google Maps 文档](https://cloud.google.com/vertex-ai/generative-ai/docs/grounding/grounding-with-google-maps)
- [Contextual View Widget 文档](https://developers.google.com/maps/documentation/javascript/maps-grounding-widget)

### 10.2 项目文档
- 需求分析文档：`doc/需求分析.md`
- Figma 详细设计：`doc/figma-make详细设计.md`
- 前端代码：`Next-gen-index/src/`

### 10.3 技术资源
- React 19 文档：https://react.dev/
- TypeScript 文档：https://www.typescriptlang.org/
- Tailwind CSS 文档：https://tailwindcss.com/
- Recharts 文档：https://recharts.org/

---

## 11. 附录

### 11.1 术语表
- **Index Insurance**：指数保险，基于客观指数（如降雨量）而非实际损失来触发理赔的保险产品
- **风险事件**：满足保险产品触发条件的事件，会记录时间、区域、级别等信息
- **产品级（Product-Level）**：保险产品的风险事件触发条件定义，包括触发条件、阈值配置、风险级别等
- **保单级（Policy-Level）**：具体保单的赔付原则定义，包括赔付金额、赔付次数限制、赔付条件等（未来扩展）
- **保险产品库（Product Library）**：统一管理保险产品定义的模块，包含产品级和保单级配置
- **风险计算引擎（Risk Calculation Engine）**：执行风险事件计算的模块，从产品库获取规则并执行计算
- **Mock Data**：模拟数据，用于开发和演示
- **Data Layer**：Google Maps JavaScript API 的数据图层，用于叠加自定义数据
- **Advanced Markers**：Google Maps 的新一代标记组件，支持 HTML/CSS 自定义
- **Contextual View**：Google Maps 的 AI 对话界面组件
- **Grounding Lite**：Google 的自然语言理解服务，用于参数提取

### 11.2 API Key 配置
- **Google Cloud Project**：`axinan-dev`
- **API Key**：`AIzaSyDySKOyx0ilGmORM-8px8Hx45jb9s28zms`
- **已开启的 API**：
  - Maps JavaScript API
  - Geocoding API（用于反向地理编码，将 GPS 坐标转换为行政区域）
  - Weather API

**注意**：此 API Key 仅用于开发和测试环境，生产环境应使用环境变量或安全的密钥管理服务。

### 11.3 GPS 定位相关技术
- **Geolocation API**：浏览器原生 API，用于获取用户 GPS 位置
- **Reverse Geocoding**：Google Geocoding API 的反向地理编码功能，将坐标转换为地址
- **地址组件解析**：从 Geocoding API 返回的 `address_components` 中提取行政区域信息

---

**文档版本**：v1.0  
**创建日期**：2025-01-27  
**最后更新**：2025-01-27
