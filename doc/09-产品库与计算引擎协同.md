# 09-产品库与计算引擎协同

## 步骤概述

### 步骤编号和名称
**步骤09**：产品库与计算引擎协同

### 步骤目标
实现产品库与风险计算引擎的协同机制，确保产品定义可以正确传递给计算引擎，计算结果可以正确返回，完成端到端的数据流转和计算流程验证。

### 预期成果
- 产品库与计算引擎接口对接完成
- 产品定义可以正确传递给计算引擎
- 计算引擎可以正确解析产品规则并执行计算
- 计算结果可以正确返回和格式化
- 端到端的计算流程验证通过

---

## 前置条件

### 依赖的步骤
- **步骤07**：风险计算引擎核心（需要计算引擎架构）
- **步骤08**：产品库完整实现（需要完整的产品配置）

### 需要完成的前置工作
- 风险计算引擎核心架构已实现
- 产品库完整实现已完成
- 产品规则解析器已实现
- 基础计算逻辑已实现

### 需要的数据/接口
- 产品定义：`Product`类型（从产品库获取）
- 天气数据：`WeatherData[]`类型（从Mock数据生成器获取，目前主要为降雨量数据）
- 计算引擎接口：`RiskCalculationEngine`类

---

## 实现要点

### 核心功能点

1. **接口对接**
   - 定义产品库与计算引擎的标准接口
   - 实现产品定义的传递机制
   - 实现计算结果的返回机制

2. **数据流转验证**
   - 验证产品定义可以正确传递
   - 验证计算引擎可以正确解析产品规则
   - 验证计算结果可以正确返回
   - 验证数据格式的一致性

3. **计算流程验证**
   - 验证日内产品的计算流程
   - 验证周度产品的计算流程
   - 验证月度产品的计算流程
   - 验证不同阈值档位的计算逻辑

4. **错误处理**
   - 处理产品不存在的情况
   - 处理产品配置错误的情况
   - 处理计算失败的情况
   - 提供清晰的错误信息

### 技术实现方案

#### 1. 接口定义
```typescript
// 伪代码示例
interface RiskCalculationEngine {
  calculateRiskEvents(
    product: Product,
    region: Region,
    dateRange: DateRange,
    weatherData: WeatherData[]
  ): RiskEvent[];
}

interface ProductLibrary {
  getProduct(id: string): Product | null;
  getProductsByType(type: string): Product[];
  getAllProducts(): Product[];
}
```

#### 2. 协同机制实现
```typescript
// 伪代码示例
class RiskCalculationService {
  constructor(
    private productLibrary: ProductLibrary,
    private calculationEngine: RiskCalculationEngine
  ) {}
  
  calculateRisk(
    productId: string,
    region: Region,
    dateRange: DateRange,
    weatherData: WeatherData[]
  ): RiskEvent[] {
    // 1. 从产品库获取产品定义
    const product = this.productLibrary.getProduct(productId);
    if (!product) {
      throw new Error(`Product not found: ${productId}`);
    }
    
    // 2. 传递给计算引擎
    const events = this.calculationEngine.calculateRiskEvents(
      product,
      region,
      dateRange,
      weatherData
    );
    
    // 3. 返回计算结果
    // 注意：返回的 RiskEvent 包含以下字段：
    // - dataType: 'historical' | 'predicted' - 标识数据类型
    // - weatherType: WeatherType - 标识对应的天气类型（如 'rainfall'），对应产品的weatherType字段
    // - level: 'tier1' | 'tier2' | 'tier3' - 对应阈值档位
    return events;
  }
}
```

#### 3. 计算流程验证
```typescript
// 伪代码示例
function validateCalculationFlow() {
  // 测试降雨量日内产品
  const dailyProduct = productLibrary.getProduct('daily');
  const dailyEvents = calculationEngine.calculateRiskEvents(
    dailyProduct,
    testRegion,
    testDateRange,
    testWeatherData
  );
  // 验证计算结果
  
  // 测试降雨量周度产品
  // 测试降雨量月度产品
}
```

### 关键代码结构

#### 协同服务模块
```typescript
// 伪代码示例
// lib/riskCalculationService.ts
export class RiskCalculationService {
  // 产品库与计算引擎的协同逻辑
  // 计算流程的封装
  // 错误处理
}
```

---

## 输入输出

### 输入
- **产品ID**：`string`类型
- **区域信息**：`Region`类型
- **时间范围**：`DateRange`类型
- **天气数据**：`WeatherData[]`类型（目前主要为降雨量数据）

### 输出
- **风险事件列表**：`RiskEvent[]`类型
- **风险统计信息**：包含事件数量、级别分布等
- **可视化数据**：用于地图标记和数据面板图表

---

## 验收标准

### 功能验收标准
- [ ] 产品库与计算引擎接口对接完成
- [ ] 产品定义可以正确传递给计算引擎
- [ ] 计算引擎可以正确解析产品规则
- [ ] 计算结果可以正确返回和格式化
- [ ] 降雨量日内产品的计算流程验证通过
- [ ] 降雨量周度产品的计算流程验证通过
- [ ] 降雨量月度产品的计算流程验证通过

### 数据质量验收标准
- [ ] 数据格式统一，符合接口定义
- [ ] 计算结果准确，符合产品规则
- [ ] 风险事件数据包含所有必要字段（包括 dataType 和 weatherType）
- [ ] 不同阈值档位的计算逻辑正确
- [ ] dataType 字段正确标识历史/预测数据
- [ ] weatherType 字段正确标识对应的天气类型，与产品的weatherType字段一致

### 性能验收标准
- [ ] 计算流程执行时间在1秒内（对于默认时间范围）
- [ ] 接口调用不会阻塞UI线程
- [ ] 内存使用合理，不会导致内存泄漏

---

## 注意事项

### 常见问题
1. **产品定义传递失败**
   - 确保产品库可以正确查询产品
   - 确保产品定义格式正确

2. **计算引擎解析失败**
   - 确保产品规则配置正确
   - 确保规则解析器可以正确处理所有产品类型

3. **计算结果不正确**
   - 验证计算逻辑是否正确
   - 验证时间窗口计算是否正确
   - 验证阈值判断是否正确

### 技术难点
- **接口设计**：需要设计清晰的接口，便于维护和扩展
- **数据格式统一**：确保产品定义和计算结果的数据格式一致
- **错误处理**：需要提供清晰的错误信息，便于调试

### 扩展性考虑
- 接口设计支持未来添加新的产品类型
- 支持未来添加新的计算策略
- 预留保单级计算接口（未来扩展）

---

## 下一步

### 后续步骤的准备工作
- 产品库与计算引擎协同已实现，可以在步骤13中使用进行风险事件标记
- 计算流程已验证，可以在步骤20中使用进行图表可视化

### 数据/接口的传递
- 风险事件数据通过`RiskEvent[]`类型传递给地图组件
- 统计信息通过`RiskStatistics`类型传递给数据面板

---

**文档版本**：v1.0  
**创建日期**：2025-01-27  
**最后更新**：2025-01-27
