# 16 - 项目结构与类型定义（Frontend: Next.js 基线）- v2 实施细则

> 对应 `docs/v2/v2实现步骤总览.md` Step 16  
> 状态：Draft（可开工）  
> 版本：v2.0  
> 创建日期：2026-01-16  
> 最后更新：2026-01-16

---

## 模块名称

Frontend 基线：Next.js（App Router）项目结构 + TypeScript 严格类型 + Shared Contract 类型对齐

---

## 目标 / 非目标

### 目标

- 建立 v2 前端工程骨架（与 `v2架构升级-全栈方案.md` 对齐）：
  - Next.js（App Router）+ React 19 + TypeScript + Tailwind
  - Zustand（UI/会话/模式）+ TanStack Query（Server State）
- 固化“契约先行”落地方式：前端必须直接消费 Shared Contract 的类型/DTO（避免自行定义导致口径漂移）。
- 为后续 FE 模块（Map Stage、L0/L1/L2、Orchestration、AI）提供稳定的目录与依赖边界，降低返工率。

### 非目标

- 不在本细则实现任何具体业务 UI（地图/面板/图层在后续步骤实现）。
- 不在本细则定义 Google Maps API Key（合规与配置在 Step 17/42 处理）。

---

## 关联的数据产品（Data Product）

前端会消费全部数据产品，本细则的目标是保证消费方式一致：

- L0 Dashboard
- L1 Region Intelligence
- L2 Evidence（后续）
- Map Overlays
- AI Insights（后续）

---

## 输入维度（最小集合）

> 前端的“输入维度”体现为：View State + Access State，必须与 Shared Contract 的字段命名一致。

- `region_scope` / `region_code`
- `time_range`
- `data_type`
- `weather_type`
- `product_id`
- `access_mode`
- `prediction_run_id`（predicted）

---

## 输出形态

本模块的输出是“工程结构与类型基线”，包括：

- 统一的 DTO/类型定义入口（供 hooks 与 query 使用）
- 统一的 API client 层（只处理 transport，不做业务口径推断）
- 统一的状态域建模（View/Access/Server State 三域）

---

## Mode 规则（必须写）

前端必须把 Mode 当成“跨层契约”，而不是仅 UI 开关：

- `access_mode` 必须成为：
  - Query key 的一部分（避免串数据）
  - Orchestration/能力矩阵的输入
  - UI 的默认展开策略依据（Demo 默认更轻）

硬规则：
- 前端隐藏不算权限；任何敏感数据依赖后端裁剪（Step 02）。

---

## predicted 规则（必须写）

- 前端切到 predicted 时，所有数据产品请求必须携带 `prediction_run_id`（或由服务端 active_run 解析后在响应中显式回填，再由前端锁定使用）。
- 前端不得自行实现“选最新 run”的权威逻辑（反例见 `RD-分层职责与协作边界.md`）。

---

## 性能与缓存策略

前端数据获取硬规则（与 `v2技术方案.md` 对齐）：

- **禁止**用 `useEffect` 拉数据：必须使用 TanStack Query 管理 Server State（缓存/并发取消/重试/失效）。
- hover 不触发重请求：Hover 只使用已加载数据。

缓存/查询 key 必含：

- `access_mode`
- `data_type`
- `prediction_run_id`（predicted）
- 以及会改变口径的维度（region/time_range/weather_type/product_id…）

---

## 可观测性

前端必须在关键交互触发时携带/生成：

- `trace_id/correlation_id`
- `access_mode`
- `prediction_run_id`（predicted）
- `region_code/time_range/weather_type/product_id`

并形成可追溯链路（与 `v2技术方案.md` 对齐）：

- `ui_intent` → `orchestration_state_update` → `dp_request` → `dp_response` → `ui_render_done`

---

## 复用声明（必须写清楚）

### Reuse Digest（必填引用）

- `docs/v2/v2复用逻辑摘录/RD-分层职责与协作边界.md`（Orchestration/Query/组件边界）
- `docs/v2/v2复用逻辑摘录/RD-共享类型与接口契约.md`（共享 DTO/维度命名）
- `docs/v2/v2复用逻辑摘录/RD-性能优化.md`（hover 红线、节流与缓存）

### 来自 v1 的可复用资产（R0/R1）

- 复用 v1 “中心化入口管理复杂状态/逻辑”的思想，但 v2 改为：
  - Zustand 管 View/Access State
  - TanStack Query 管 Server State

### 来自 v1 的可复用逻辑（R2）

- 不适用（本模块是工程基线）。

### 不复用内容（R3）

- 不复用“组件内散落口径推断与重计算”的实现方式。

---

## 验收用例（可勾选）

### 工程基线（必须）

- [ ] TypeScript 严格模式开启，禁止 any 漫延（类型收敛到 Shared Contract DTO）。
- [ ] TanStack Query 与 Zustand 的职责边界清晰（View/Access/Server State 分离）。

### 一致性/批次（必须）

- [ ] query key 必含 access_mode；predicted 必含 prediction_run_id（避免串数据/混批次）。
- [ ] 前端没有“自行选择预测批次”的权威逻辑实现。

---

## 两个“最常见失败模式”（必须写进每个模块）

### 失败模式 A：前端隐藏当权限

症状：前端认为隐藏了字段就安全，结果 API 仍返回敏感数据。  
硬规则：敏感数据必须由后端裁剪；前端只做呈现与“可见但不可用”降级。

### 失败模式 B：predicted 混批次

症状：前端对不同 query 使用了不同 prediction_run_id，导致 UI/AI 解释断裂。  
硬规则：prediction_run_id 作为顶层状态域的一部分，统一传递；query key 必含 run_id。

---

## 风险与回滚策略

### 风险

- 未强制使用 Query 管理数据 → 请求风暴/竞态/难排障（P0/P1）。
- 类型不对齐 Shared Contract → 口径漂移、缓存错命中（P0）。

### 回滚策略

- 若出现严重竞态：先收敛到“只允许少数关键 Query”与更保守的刷新策略，恢复稳定后再扩展。
- 若出现类型漂移：以 Shared Contract 为准回滚前端私有类型定义，统一迁移到共享 DTO。

