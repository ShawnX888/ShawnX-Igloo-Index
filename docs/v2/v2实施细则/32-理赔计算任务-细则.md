# 32 - 理赔计算任务（claim_calculation / Celery）- v2 实施细则

> 对应 `docs/v2/v2实现步骤总览.md` Step 32  
> 状态：Draft（可开工）  
> 版本：v2.0  
> 创建日期：2026-01-16  
> 最后更新：2026-01-16

---

## 模块名称

理赔计算任务（Celery Beat 定时 + Worker 执行）：批量生成 historical claims（幂等 + 并发控制 + 可回溯）

---

## 目标 / 非目标

### 目标

- 以 Celery 任务方式定期生成理赔事实（写入 `claims` 表）：
  - 输入：policies + risk_events（historical）+ products.payoutRules
  - 计算：Claim Calculator（Step 31，纯计算）
  - 写入：Claim Service（Step 30，幂等写入/追溯）
- 满足 v2 的两条“后端任务红线”：
  - **CPU 隔离**：批量计算不得在 FastAPI 路由执行
  - **幂等与并发安全**：重试/并发触发不产生重复 claims（Redis 锁 + DB 唯一约束/Upsert）
- 支持历史回溯与修复：
  - backfill：指定 policy/time_range 重新计算（可多次重跑，不产生重复）
  - repair：支持作废/重算（需审计）

### 非目标

- 不生成 predicted claims（predicted 约束：不得污染事实表）。
- 不在本细则定义 L2 Evidence 的查询形态（由 Step 33 承接）。

---

## 关联的数据产品（Data Product）

claims 作为事实输入，间接影响：

- L0 Dashboard（Claims tab 聚合）
- L1 Region Intelligence（Claims 泳道聚合序列）
- L2 Evidence（风险事件 ↔ 理赔关联明细）
- Map Overlays（Claims Overlay 的聚合来源）

---

## 输入维度（最小集合）

### 任务参数（建议）

> 任务参数不等同于 Data Product 入参，但必须能回放与审计。

- `task_scope`：`daily` | `backfill` | `repair`
- `time_range`（UTC）：本次结算范围（建议日/周/月窗口）
- `policy_selector`（可选）：
  - `policy_id`（单保单回溯）
  - 或 `region_code` / `product_id`（分片）
- `dry_run`（可选）：仅计算不落库（用于验证/压测）
- `trace_id/correlation_id`（必带）

### 计算输入（由任务内部组装）

- Policy（见 Step 06/31）：`coverage_amount(Decimal)`、`timezone`、保障期
- payoutRules（Product Service，见 Step 05/31）
- risk_events（Risk Service，**仅 historical**，见 Step 09/31）

---

## 输出形态

- 写入 `claims` 表（通过 Claim Service 幂等写入）
- 任务执行报告（可观测）：
  - processed_policies
  - input_risk_events_count
  - generated_claims_count
  - upsert_conflicts_count
  - duration_ms
  - error_summary（分类）

---

## 责任归属（写入与协作边界）

- **写入责任**：本任务负责 historical claims 的生成与写入（通过 Claim Service）
- **predicted 责任**：predicted 不进入本任务；模拟赔付需独立链路与存储
- **接口边界**：不提供对外写接口，写入仅由任务链路执行
- **审计责任**：必须记录规则版本与幂等键，支持回溯与复算

---

## Mode 规则（必须写）

任务生成 claims 为事实写入，不按 Mode 分叉计算；但需要满足：

- 任务日志/审计必须可追溯（未来支持“谁触发回溯计算”）
- 下游数据产品必须 Mode-aware 裁剪（失败模式 A）

---

## predicted 规则（必须写）

硬规则：

- 本任务只处理 `risk_events.data_type = historical`
- **禁止**读取/写入 predicted claims
- 若输入 time_range 与页面选择为 predicted：任务不得尝试“用 predicted 风险事件生成 claims”（必须拒绝/忽略）

---

## 任务流程（推荐实现顺序）

### 1) 任务分片与批处理（强制）

- 按 policy 分片处理（避免全量一次性在单 Worker 中跑爆）
- 每批次使用 pagination（policy_id cursor）
- 并发策略：同一 policy 不允许并发结算（见并发控制）

### 2) 取数与校验（强制）

- 取 policy：只包含保障期与必要字段（timezone/coverage_amount/product_id）
- 取 payoutRules：按 product_id 获取，记录 rules_hash/product_version
- 取 risk_events：严格过滤 historical + time_range（必要时扩展窗口由 Calculator/Service 定义）
- 校验：
  - policy.timezone 必须存在
  - payoutRules 必须完整

### 3) 计算（强制）

- 调用 Claim Calculator（Step 31）：
  - 输入统一使用 Decimal
  - 频次限制按 policy.timezone 的自然日/月边界
- 产出 ClaimDraft（含 idempotency_key）

### 4) 写入（强制）

- 通过 Claim Service 批量 upsert：
  - 命中幂等键 → 更新/忽略（策略需明确）
  - 写入时必须落 `rules_hash/product_version`、source=task、时间字段 UTC

---

## 幂等与并发控制（强制）

### Redis 分布式锁（task-level）

建议锁粒度（至少满足“同一 policy + 同一结算窗口”互斥）：

- lock key 示例：`claim_calc:{policy_id}:{time_range_start_utc}:{time_range_end_utc}`
- 获取失败策略：
  - 若是 daily 定时任务：跳过并记录（避免任务风暴）
  - 若是 backfill：允许排队重试（指数退避）

### DB 唯一约束/Upsert（write-level）

必须存在唯一约束（由 Step 30 claims 表承接）使得：

- 任务重试不会产生重复 claims
- 并发 worker 不会双写成功

---

## 性能与重试策略

- 超时：外部依赖（DB/Redis）必须有超时与错误分类
- 重试：仅对可恢复错误重试（网络抖动/短暂 DB 锁冲突），使用指数退避
- 降级：
  - 若某个 product 的 payoutRules 不完整：跳过该产品并报警（避免污染）
  - 若某个 policy timezone 缺失：跳过并进入修复队列（人工/修复任务）

---

## 可观测性

必须记录：

- `task_claim_calculation_start/end`
- `task_claim_calculation_policy_batch`（batch_size、cursor）
- `claim_calc_skipped_due_to_lock`
- `claim_upsert_conflict`
- `claim_calc_error`（error_class）

必带字段：

- `task_id`
- `trace_id/correlation_id`
- `policy_id`（可摘要化）
- `product_id`
- `time_range`
- `rules_hash/product_version`
- counts（见输出形态）

---

## 复用声明（必须写清楚）

### Reuse Digest（必填引用）

- `docs/v2/v2复用逻辑摘录/RD-分层职责与协作边界.md`（CPU 隔离与职责边界）
- `docs/v2/v2复用逻辑摘录/RD-性能优化.md`（任务风暴/缓存治理）
- `docs/v2/v2复用逻辑摘录/RD-时间与时区口径统一.md`（自然日/月边界）
- `docs/v2/v2复用逻辑摘录/RD-产品库与规则契约.md`（payoutRules 频次/精度）

---

## 验收用例（可勾选）

### 可靠性（必须）

- [ ] 定时任务可执行且可追踪（task_id + correlation_id）。
- [ ] 任务重试/并发触发不产生重复 claims（Redis 锁 + DB 唯一约束/Upsert 生效）。

### 正确性（必须）

- [ ] 频次限制按 policy.timezone 生效（非 UTC）。
- [ ] 金额精度全链路 Decimal（无 float）。

### predicted 约束（必须）

- [ ] predicted 风险事件不会触发 claims 写入（事实表不污染）。

---

## 两个“最常见失败模式”（必须写进每个模块）

### 失败模式 A：前端隐藏当权限

症状：Demo/Public 能拿到 claims 明细/精确金额，或命中非本 Mode 缓存。  
硬规则：claims 的展示与证据链必须由数据产品按 Mode 强裁剪；任务只负责事实生成与审计。

### 失败模式 B：predicted 混批次

症状：把 predicted 风险事件用于生成 claims，导致事实污染与解释断裂。  
硬规则：任务严格过滤 historical；predicted 模拟赔付必须走独立链路/独立存储（不属于 claims 表）。

---

## 风险与回滚策略

### 风险

- 幂等缺失或锁策略错误 → 重复 claims（P0）
- 时区边界错误 → 赔付周期错误（P0）

### 回滚策略

- 立即暂停 beat 任务；修复唯一约束/幂等键；清理重复数据（必须审计）
- 修复时区口径后回溯重跑：允许重复执行但不重复写（幂等保证）

