# 15 - 风险事件计算任务（Celery Beat）- v2 实施细则

> 对应 `docs/v2/v2实现步骤总览.md` Step 15  
> 状态：Draft（可开工）  
> 版本：v2.0  
> 创建日期：2026-01-16  
> 最后更新：2026-01-16

---

## 模块名称

风险事件计算任务（`risk_event_calculation`：历史风险事件批量计算）

---

## 目标 / 非目标

### 目标

- 用 Celery Beat + Worker 定期计算 **historical 风险事件**，并持久化到 `risk_events`（data_type=historical）。
- 支持历史数据回溯计算（按时间窗/按产品/按区域分片）。
- 严格遵守 CPU 隔离：风险计算内核（Risk Calculator）必须在任务内执行，不得阻塞 FastAPI event loop。
- 幂等与并发控制：
  - 重试/重复触发不产生重复 risk_events
  - 通过 Redis 锁 + DB 唯一约束闭环

### 非目标

- **不在本任务中计算 predicted 风险事件**：predicted 风险事件必须在 `weather_sync` 更新预测数据时触发计算（见 `v2架构升级-全栈方案.md` 的约束）。
- 不在本任务中生成 claims（理赔生成属于 Phase 3）。

---

## 关联的数据产品（Data Product）

风险事件计算结果供给：

- L1 Region Intelligence（Risk 泳道 + events）
- L2 Evidence（风险事件明细）
- Map Overlays（Risk overlays 聚合输入）
- AI Insights（洞察证据点）

---

## 输入维度（最小集合）

任务入参至少要能表达“计算范围”，并能被追溯：

- `product_id`（或产品集合）
- `region_scope/region_code`（可选；支持分区计算）
- `time_range`（UTC；展示窗/回溯窗）
- `calculation_range`（UTC；扩展窗，至少覆盖 timeWindow 回溯）
- `weather_type`（可从产品推导）
- `access_mode`（一般不影响 risk_events 写入，但会影响缓存生成与日志维度；建议任务日志仍带）
- `data_type='historical'`（固定）
- `trace_id/correlation_id`

---

## 输出形态

### 1) 写入 risk_events（historical）

写入字段必须满足 Step 09 的事件模型，并建议包含：

- `rules_hash`/`product_version`
- `threshold_value`、`trigger_value`
- `event_time_utc`

### 2) 任务执行结果（可观测）

- 处理产品数/区域数/时间点数
- 新增/更新（若允许 upsert）的 risk_events 数量
- 耗时、失败原因、重试次数

---

## Mode 规则（必须写）

该任务写入的是“事实事件”，不应按 Mode 写入不同内容；但任务必须避免产生“权限旁路缓存”：

- 若任务顺带刷新/写缓存（可选优化），缓存 key 必含 `access_mode`
- 推荐：risk_events 写入与缓存刷新解耦（任务只产事实，数据产品层按 Mode 缓存）

---

## predicted 规则（必须写）

硬规则：

- 本任务只负责 historical 风险事件。
- predicted 风险事件的计算必须在 `weather_sync` 中，当预测数据更新时一并计算并写入（data_type=predicted + prediction_run_id）。

与 Step 03/10 的一致性要求：

- predicted 写入必须绑定 prediction_run_id
- 禁止覆盖旧预测批次（必须版本化）

---

## 性能与缓存策略

### 执行策略（建议）

- 按产品分片（每个产品一组任务）
- 按时间窗分片（避免单任务跨度过大）
- 按区域分片（可选：数据量大时）

### 幂等与并发控制（强制）

至少两层：

- Redis 任务锁（例如 lock:risk_calc:{product_id}:{time_bucket}:{region_scope}:{region_code}）
- DB 唯一约束：
  - historical：product + region + timestamp + weather_type + tier_level 唯一

---

## 可观测性

必须记录：

- task_id、task_name
- trace_id/correlation_id
- product_id、weather_type
- time_range、calculation_range
- region_scope/region_code（如适用）
- rules_hash/product_version
- 写入计数、耗时、失败原因

---

## 复用声明（必须写清楚）

### Reuse Digest（必填引用）

- `docs/v2/v2复用逻辑摘录/RD-风险计算引擎核心与策略.md`
- `docs/v2/v2复用逻辑摘录/RD-计算窗口与扩展数据.md`
- `docs/v2/v2复用逻辑摘录/RD-分层职责与协作边界.md`

### 来自 v1 的可复用资产（R0/R1）

- 不适用（v1 无后端任务体系）。

### 来自 v1 的可复用逻辑（R2）

- 风险计算算法逻辑可复用（由 Risk Calculator 实现），但 v2 必须落在任务/服务层，并满足幂等与可观测。

### 不复用内容（R3）

- 不复用“前端边渲染边计算并作为事实源”的模式。

---

## 验收用例（可勾选）

### 正确性（必须）

- [ ] 使用扩展窗口计算，输出裁剪回 time_range（写入事件时间与阈值解释一致）。

### 幂等与并发（必须）

- [ ] 任务重试不产生重复 risk_events（唯一约束 + 锁生效）。
- [ ] 并发触发同一任务不会重复写入。

### predicted 约束（必须）

- [ ] 本任务不写入 predicted risk_events；predicted 写入由 weather_sync 触发并绑定 prediction_run_id。

---

## 两个“最常见失败模式”（必须写进每个模块）

### 失败模式 A：前端隐藏当权限

症状：任务顺手写入/刷新了不含 access_mode 的缓存，导致 Demo 命中高权限缓存。  
硬规则：缓存 key 必含 access_mode；建议缓存生成由数据产品层负责。

### 失败模式 B：predicted 混批次

症状：有人把 predicted 风险事件也塞进该任务，导致 run_id 缺失或覆盖旧预测。  
硬规则：predicted 计算只在 weather_sync 触发；必须版本化并绑定 prediction_run_id。

---

## 风险与回滚策略

### 风险

- 任务无分片 → 单任务过重、超时、阻塞队列（P0/P1）。
- 幂等缺失 → 重试产生重复事件，污染解释闭环（P0）。

### 回滚策略

- 发现重复写入：暂停 Beat + 修复锁/唯一约束 + 清理重复数据（需审计脚本与可回放策略）。
- 发现口径错误：回滚产品规则版本（或禁用产品），重跑回溯计算并核对差异。

