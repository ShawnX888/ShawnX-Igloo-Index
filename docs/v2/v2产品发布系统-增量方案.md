# v2 产品发布系统（Product Publish）增量方案

> 状态：Draft（作为后续“产品发布”开发基线）  
> 版本：v2.0  
> 创建日期：2026-01-23  
> 最后更新：2026-01-23  
> 目标读者：架构 / 后端 / 前端 / 测试 / 后续 Agent  

---

## 0. 背景与动机

v2 当前实现将产品配置作为 `products` 单表权威源，使用 `version`（字符串）+ `is_active` 管理启用；`risk_events/claims` 通过 `product_version` 字段做审计追溯。

为了支持“**Admin 可视化上架（发布）**”、并满足以下新增需求，本方案引入“**产品身份（Product）**”与“**发布版本（Product Release）**”分层，并将“发布”与“激活（切换 current）”拆成两阶段，确保页面不会出现半生成/混口径数据：

- **产品（身份）全局可见性控制**：决定产品是否在页面出现（与 access_mode 无关）。
- **release 不分 access_mode**：全局只有“published 版本”概念即可。
- **页面只展示 published 版本相关联的风险/保单/理赔**：即“当前发布版本口径”。
- **发布新版本需触发风险重算**；如强制对现有保单 backfill，则需废掉旧 claims 并重算。
- **关键约束（你已确认）**：**重算完成后再切 current_release**（强一致、可演示、可审计）。

---

## 1. 范围与非目标（Scope / Non-goals）

### 1.1 范围（本方案必须覆盖）

- 数据模型：引入 `product_releases` 表；`products` 增加 `is_visible/current_release_id`；`policies/risk_events/claims` 增加 `product_release_id`。
- 发布状态机：draft → publish → recompute → activate（切 current）。
- 风险重算任务编排：发布后自动触发，幂等、可观测、可回滚。
- 强制 backfill：更新 policies 版本绑定、void 旧 claims、重算新 claims（historical only）。
- 页面读路径口径：只展示“产品可见 + 当前发布版本”的事实数据。
- 缓存与一致性：cache key 维度纳入 `product_release_id`（或通过 current_release 推导后固化到 key）。

### 1.2 非目标（明确不做，避免 scope 爆炸）

- 不建设重型 IAM / 组织权限体系（仍沿用 v2 的 Access Mode 作为跨层裁剪契约；此方案只额外引入 Admin 发布接口的鉴权约束）。
- 不做“按 access_mode 发布不同 release”。
- 不承诺“发布后秒级完成全量历史重算”。重算范围必须可配置（见 §6.2）。
- 不改变 v2 既有“predicted 不生成正式 claims”的硬规则。

---

## 2. 统一语言（必须用这些词）

- **Product（产品身份）**：稳定实体（product_id），承载全局可见性与“当前发布版本指针”。
- **Product Release（发布版本）**：不可变发布包，包含当时的 `risk_rules/payout_rules` 与审计元信息。
- **Publish（发布）**：将 draft release 标记为 published（immutable），并触发“重算”流水线。
- **Activate（激活/切换 current）**：把 `products.current_release_id` 指向某个 release，使页面与事实口径切换到该版本。
- **Activation Run（激活批次）**：一次发布驱动的“重算→激活”工作流实例（用于观测/审计/回滚）。
- **Backfill（强制回填）**：将一批现有 `policies` 绑定到新 release，并 void 旧 claims，重算新 claims。

---

## 3. 目标行为（Business Rules）

### 3.1 全局可见性（Product-level）

- `products.is_visible=false`：产品不出现在前端（Product Selector、面板、图层 legend 等均不可见）。
- `products.is_visible=true`：产品可见，但仍必须满足“存在 current_release 且已激活”才能参与事实展示与计算。

### 3.2 Release 全局发布（不分 mode）

- 一个 release 一旦 `published`，其规则内容 **不可变**（immutable）。
- 同一产品同一时刻最多一个“当前发布版本”（`products.current_release_id`）。

### 3.3 页面展示口径（强制）

页面与数据产品查询必须满足：

- 产品维度：`products.is_visible = true`
- 版本维度：只展示 `product_release_id = products.current_release_id` 的 `policies/risk_events/claims`
- release 必须是 `published`（避免 draft 漏出）

> 结果：页面永远不会展示“旧版本事实 + 新版本规则解释”或“新版本 current 已切但事实未生成”的混口径。

### 3.4 发布触发与切换策略（你已确认）

- Publish 后自动开始重算，但 **不立即切换 current_release**。
- 仅当重算完成（满足 Go/No-Go 门槛）才执行 Activate（原子切换 current_release）。

### 3.5 Backfill（强制回填）策略

- Backfill 会改变 policies 的版本绑定：`policies.product_release_id` 更新为新 release。
- Backfill 必须：
  - 将旧 claims 标记 `voided`（或 `superseded`）并写明原因/关联 release；
  - 重算并写入新 claims（`product_release_id = new_release_id`）。

> 注意：不建议物理删除旧 claims/risk_events（会破坏审计与回放）；页面只需过滤 current_release 即可“看不见旧事实”。

---

## 4. 数据模型（Target Schema）

### 4.1 `products`（产品身份）

新增字段（在保留旧字段的前提下增量迁移）：

- `is_visible` BOOLEAN NOT NULL DEFAULT TRUE  
  - 全局可见性开关（替代/并行于旧 `is_active` 语义，最终以 `is_visible` 为准）。
- `current_release_id` (FK → `product_releases.id`, nullable)  
  - 当前激活版本指针；为 NULL 时表示“尚未激活任何 release”，页面不展示该产品的事实域内容。

### 4.2 `product_releases`（发布版本）

新表：

- `id`（release_id，建议 BIGSERIAL/UUID）
- `product_id` (FK → products.id)
- `version`（INT 或 semver TEXT；建议从现有 `products.version` 迁移为 v1.0.0 → 1 的映射策略）
- `status`：draft/published/archived（published 后 immutable）
- `risk_rules` JSONB NOT NULL
- `payout_rules` JSONB NOT NULL
- `created_by`, `published_by`, `published_at`, `changelog`
- `created_at`

约束：

- `UNIQUE(product_id, version)`
- （建议）只能存在 0/1 个 active published 指针由 `products.current_release_id` 保证，而不是在 releases 表内做 is_active。

### 4.3 `policies` 增量字段

- 新增 `product_release_id` (FK → product_releases.id) NOT NULL（最终态）  
  - 表示该 policy 按哪个 release 版本解释与计算（Backfill 会更新它）。

### 4.4 `risk_events` 增量字段

- 新增 `product_release_id` (FK → product_releases.id) NOT NULL（最终态）
- `product_version` 可保留用于日志/兼容期，但最终以 `product_release_id` 为主键维度。

### 4.5 `claims` 增量字段

- 新增 `product_release_id` (FK → product_releases.id) NOT NULL（最终态）
- 已有 `status` 含 `voided`，本方案建议补齐审计字段（可选）：
  - `voided_at`, `void_reason`, `superseded_by_release_id`

---

## 5. 必须补的“坑”（不补会直接实现失败）

### 5.1 Risk events 的“唯一约束/幂等”必须纳入版本维度

现状风险：
- 当前 `risk_events` 的 unique 约束（historical）**未包含 `product_version`**，意味着你无法为同一 product 在不同版本同时保留两套历史 risk_events（会触发唯一约束冲突）。

目标行为需要：
- **允许不同 release 的 risk_events 并存**（用于审计/回放/比较），但页面只展示 current_release。

因此必须：
- 将 historical risk_events 的唯一约束改为包含 `product_release_id`（或至少包含 `product_version`，但推荐 release_id）。
- 幂等 ID 生成与锁 key 也必须包含 `product_release_id`（避免新旧版本互相“认为自己已计算过”）。

### 5.2 Claims 的“唯一约束/幂等”必须纳入版本维度

现状风险：
- 当前 claims unique 为 `(policy_id, triggered_at, tier_level)`。即便你把旧 claims 标记 voided，新 claims 仍会插入失败（唯一约束冲突）。

因此必须：
- 将 claims unique 改为包含 `product_release_id`：`(policy_id, product_release_id, triggered_at, tier_level)`。
- 幂等 claim_id 生成建议也纳入 `product_release_id`（否则不同 release 可能生成同一个 claim_id）。

### 5.3 “发布后不切 current”需要一个可观测的工作流实体

发布与激活分离意味着你需要能回答：
- 重算进行到哪里了？
- 哪些分片成功/失败？
- 什么时候可以切 current？
- 失败后如何重试/回滚？

因此建议引入一个 DB 表记录工作流（见 §7），而不是只依赖 Celery 返回值日志。

### 5.4 缓存 key 必须纳入 release 维度，否则“命中即错口径”

只要 release 会改变结果集：
- 所有 Data Products cache key 必须含 `product_release_id`（或 current_release_id 展开后的固定值）
- 否则发布/激活后命中旧缓存会导致页面展示旧口径数据。

---

## 6. 发布工作流（Publish → Recompute → Activate）

### 6.1 总体状态机

```
Draft Release
  └─(Publish)→ Published Release (immutable)
                └─(Auto)→ Activation Run: RECOMPUTE_RUNNING
                             ├─ risk recompute shards...
                             ├─ (optional) backfill requested? (separate op)
                             └─ RECOMPUTE_SUCCEEDED
                                     └─(Activate)→ products.current_release_id = release_id
```

### 6.2 重算范围（Recompute Scope）

重算“全量历史”通常不现实，必须显式定义 scope：

- **默认建议**：以业务演示为目标，先重算“可视化窗口”范围（例如最近 N 天/月）+ 必要的扩展窗口（rolling window 起点需要）。
- **可选策略**：
  - 按 `region_scope`/`region_code` 分片；
  - 按时间范围分片（比如按月）；
  - predicted 的 risk_events 是否随发布重算：建议至少对“当前 active_run”补一轮重算，避免规则升级后 predicted 仍用旧规则。

> 与 v2 现有约束对齐：predicted 仍受 `prediction_run_id/active_run` 管控；发布工作流不得造成混批次。

### 6.3 Activate 的原子性（强一致）

Activate 操作建议是一个“短事务”：

- 前置检查：
  - Activation Run 状态为 `RECOMPUTE_SUCCEEDED`
  - 目标 release 为 `published`
  - 必要的“必选 region/time 分片”全部成功（Go/No-Go）
- 原子更新：
  - `products.current_release_id = <release_id>`
  - 写审计日志（操作者/原因/关联 activation_run_id）
- 缓存策略：
  - 推荐通过“cache key 纳入 release_id”自然隔离；
  - 也可额外做 namespace bump 或 selective invalidation（可选）。

---

## 7. 工作流与任务编排（后端实现建议）

### 7.1 新增表：`product_activation_runs`（建议）

字段（建议最小集）：
- `id`
- `product_id`
- `release_id`
- `status`: queued/running/succeeded/failed/aborted
- `scope`: JSON（region/time/data_type/prediction_run_id 等）
- `started_at/ended_at`
- `created_by`
- `error_summary`（失败原因摘要）

### 7.2 新增表：`product_activation_shards`（建议）

用于记录分片重算结果（可重试）：
- `activation_run_id`
- `shard_key`（例如 `region_code + month`）
- `status`: queued/running/succeeded/failed
- `celery_task_id`（可选）
- `attempts`
- `error`

### 7.3 Celery 任务（建议拆分）

为了“发布后不切 current、且可重试可审计”，建议任务按职责拆开：

- `recompute_risk_events_shard(activation_run_id, shard_key, release_id, ...)`
  - 幂等锁 key 必须包含 `release_id + shard_key`
  - 写入 `risk_events.product_release_id = release_id`
- `finalize_activation_run(activation_run_id)`
  - 检查 shards 全部成功 → 标记 succeeded
- `activate_release(product_id, release_id, activation_run_id)`
  - 只做短事务更新 current 指针（强一致）

> Backfill claims 建议是另一条工作流（管理员显式触发），不要强绑在 publish 的默认路径里（否则发布会变成“不可控的超长任务”）。

---

## 8. Backfill（强制回填）工作流（Policy + Claims）

### 8.1 目标

在你明确选择的一批 policies 上：
- 将其绑定到新 release；
- void 掉旧 release 生成的 claims；
- 重算并落库新 claims（historical only）；
- 页面只展示 current_release 的 claims。

### 8.2 推荐工作流

1) 创建 `policy_backfill_run`（可选表，或复用 activation_runs 的类型字段）  
2) 对 policies 分片（按 region / policy_id range）：
   - 更新 `policies.product_release_id = new_release_id`
   - 将旧 claims `status = voided`（只针对 old_release）
   - enqueue `calculate_claims_for_policy_task`（需改造为按 release 读规则/按 release 写入）
3) 完成后写 run 状态与审计

### 8.3 必须保持的硬规则

- predicted 不生成 claims：backfill 只作用于 historical 事实域。
- void 旧 claims 不可物理删除（建议）。

---

## 9. 读路径改造（前端/数据产品/服务）

### 9.1 Product Selector 与产品列表

返回规则：
- 仅返回 `products.is_visible=true` 且 `current_release_id` 非空的产品
- 附带 `current_release_id/version` 作为解释与缓存维度

### 9.2 风险/理赔/保单查询

所有对外数据产品（L0/L1/L2/Overlays）都必须在查询条件中加入：
- `product_release_id = products.current_release_id`

并确保：
- 不会出现跨 release 聚合（除非专门做“跨版本对比”数据产品，非本方案范围）。

---

## 10. 安全与审计（最低要求）

- 发布/激活/backfill 操作必须是 **Admin/Internal** 权限（实现方式可先简单，但必须服务端强制）。
- 每次 publish/activate/backfill 必须记录：
  - 操作者、时间、原因、目标 release、影响范围（scope）
- 所有任务日志必须带：
  - `trace_id/correlation_id`（与 v2 可观测性约束对齐）
  - `product_id/release_id/shard_key`

---

## 11. 增量迁移计划（从当前实现平滑演进）

> 目标：先让系统在“只改读路径口径 + 可发布可重算可激活”的最小闭环下跑起来，再逐步清理旧字段（product.version/is_active/product_version）。

### Step A：DB 迁移（新增表/字段，不改旧读写）
- 新增 `product_releases`
- `products` 新增 `is_visible/current_release_id`
- `policies/risk_events/claims` 新增 `product_release_id`（先允许 NULL）
- 调整 `risk_events` unique（纳入 release）
- 调整 `claims` unique（纳入 release）

### Step B：数据回填（一次性脚本/迁移）
- 对每个现有 `products` 行创建一个 `product_release`（version=1, status=published）
- `products.current_release_id` 指向该 release
- 为现有 `risk_events/claims` 回填 `product_release_id`（按 product_id 关联 current_release）
- 为现有 `policies` 回填 `product_release_id`

### Step C：读路径切换（不影响写路径）
- `ProductService.list/get` 改为按 `is_visible + current_release_id` 返回
- 风险/理赔/保单查询统一按 release 过滤
- Data Product cache key 纳入 release（避免错口径）

### Step D：发布系统最小闭环
- Admin API：create draft → publish → 自动创建 activation_run → enqueue risk recompute shards → finalize → activate
- UI：最小管理页（列表、发布、查看重算状态、激活）

### Step E：Backfill 闭环（可延后）
- Admin API：选择 policies → backfill → void old claims → recompute claims
- UI：backfill 任务发起与状态查看

### Step F：清理与收敛（可选）
- 逐步将业务逻辑从 `product.version/product_version` 迁移到 `product_release_id`
- 保留 `version` 仅作为 release 的展示字段

---

## 11.5 现有代码库改造点清单（文件级，指导后续代码生成）

> 目的：把“坑”落到可执行的文件改造点，避免后续实现遗漏关键约束。

### Backend Models（SQLAlchemy）

- `packages/v2-fullstack/backend/app/models/product.py`
  - 增加 `is_visible`、`current_release_id`
  - 逐步弱化 `is_active` 语义（最终由 `is_visible` 承载“页面可见性”）
- 新增：`packages/v2-fullstack/backend/app/models/product_release.py`（或同目录文件）
  - 建模 `product_releases` 表（draft/published/archived）
  - 强制 published immutable（应用层禁止 update）
- `packages/v2-fullstack/backend/app/models/policy.py`
  - 增加 `product_release_id` 外键（并在查询/聚合中用它过滤）
- `packages/v2-fullstack/backend/app/models/risk_event.py`
  - 增加 `product_release_id`
  - 调整 historical unique index：纳入 `product_release_id`
  - 幂等 ID / 索引查询维度纳入 release（否则版本共存会冲突）
- `packages/v2-fullstack/backend/app/models/claim.py`
  - 增加 `product_release_id`
  - 调整 unique：纳入 `product_release_id`（否则 backfill 产生新 claims 会被唯一约束挡住）
  - 复用既有 `status`（含 voided），必要时补 `void_reason/voided_at`

### Backend Tasks（Celery）

- `packages/v2-fullstack/backend/app/tasks/risk_calculation.py`
  - 当前实现以 `product_id + product.version` 生成幂等 ID，并且 historical unique 不含版本维度：发布后“保留旧事实并重算新版本”会失败（§5.1）。
  - 需要改造为以 `release_id` 为核心维度：
    - 任务入参：`release_id`（或 `product_id + release_id`）
    - 读取规则：从 `product_releases` 取规则，而不是直接从 `products` 取 `risk_rules`
    - 写入：`risk_events.product_release_id = release_id`
    - lock key / idempotency key 纳入 `release_id`
  - 现状限制：任务明确拒绝 predicted（`prediction_run_id` 非空直接 skipped）。若未来要支持“发布后对 active_run 的 predicted 补算”，需要新增/扩展任务入口，但不作为本方案上线硬门槛（见 §6.2）。

- `packages/v2-fullstack/backend/app/tasks/claim_calculation.py`
  - 需要改造为按 `policy.product_release_id` 读取 payoutRules，并按 release 写入 claims：
    - 入参：`policy_id + release_id`（或只入 policy_id，由任务内部读取 policy.current release binding）
    - 写入：`claims.product_release_id = release_id`
    - idempotency key 纳入 `release_id`
  - Backfill 的 “void 旧 claims” 不应由原计算任务隐式完成：建议由 backfill orchestration 先 void，再 enqueue 计算任务。

### Backend Services / APIs

- `packages/v2-fullstack/backend/app/services/product_service.py`
  - 读路径：产品列表/详情应只对外暴露 `products.is_visible=true` 且存在 `current_release_id` 的产品；并在响应中返回 `current_release_id/version` 用于审计与缓存维度。
  - 写路径：新增 Admin 发布 API（draft/publish/activate/backfill），并与现有“对外读、内部写”的策略对齐。

- Data Products（L0/L1/L2/Overlays）
  - 所有聚合/查询必须加入 `product_release_id = products.current_release_id` 的过滤，以满足“页面只展示 published/current 版本事实”的硬规则（§3.3）。
  - cache key 维度必须纳入 `product_release_id`（§5.4）。

---

## 12. Go/No-Go 验收清单（用于上线门槛）

### 一致性（必须）
- [ ] 页面只展示 `product_release_id = current_release_id` 的 risk/policy/claim
- [ ] 切换 current_release 后，不会命中旧缓存展示旧口径（cache key 含 release）

### 发布闭环（必须）
- [ ] publish 不会立即切 current_release
- [ ] risk 重算完成后才能 activate（强一致）
- [ ] activation_run 可观测：可看到分片进度/失败原因/可重试

### Backfill（必须，若启用该功能）
- [ ] backfill 后旧 claims 被 voided，新 claims 可生成且不被唯一约束阻塞
- [ ] 旧 claims 不在页面出现但仍可审计追溯

### 安全（必须）
- [ ] 发布/激活/backfill 必须服务端鉴权（Admin/Internal）
- [ ] 操作审计可追溯（who/when/why/scope）

---

## 13. 风险与回滚策略

### 13.1 失败模式与规避

- **失败模式：激活过早导致页面空/错口径**  
  - 规避：必须通过 activation_run succeeded gate 才允许 activate。

- **失败模式：唯一约束未纳入 release 导致无法保留旧事实**  
  - 规避：按 §5 调整 risk/claim unique；并在迁移时回填 release_id。

- **失败模式：缓存维度缺失导致“命中即错口径”**  
  - 规避：cache key 含 release_id；必要时 namespace bump。

### 13.2 回滚策略

- 若新 release 重算失败：保持 current_release 不变（页面不受影响）。
- 若已激活但发现问题：切回旧 release（activate 回滚），并保留审计记录。

---

## 14. 与 v2 现有文档的关系（后续需要同步更新的真源点）

本方案是新增模块的“基线增量设计”，后续落地时需要回写/更新（按真源优先级）：

- `v2架构升级-全栈方案.md`：products 表从“单表 version”演进为 “products + product_releases”
- `v2实现步骤总览.md`：新增“产品发布系统”相关 steps（含验收锚点：Data Product / Observability / Reliability / Security）
- `v2迁移分层矩阵.md`：标注新模块归属（BE + Governance + FE Admin Page）
- `v2实施细则/05`：从“version 或 rules_hash”升级为“release_id/version + publish/activate/backfill”治理

