# 11-行政区域边界绘制

## 步骤概述

### 步骤编号和名称
**步骤11**：行政区域边界绘制

### 步骤目标
使用Google Maps Data Layer加载GeoJSON格式的行政区域边界数据，绘制Polygon图层显示行政区域边界，支持区域选择和交互。

### 预期成果
- 行政区域边界可以正确绘制在地图上
- 区域边界使用Polygon显示
- 点击区域可以切换选中区域
- 选中区域有明显的视觉区分
- 边界数据可以正确加载和渲染

---

## 前置条件

### 依赖的步骤
- **步骤10**：地图容器替换（需要地图实例）
- **步骤05**：行政区域数据管理（需要区域边界数据）

### 需要完成的前置工作
- 地图实例已创建
- 区域边界数据已准备（GADM GeoJSON格式）
- 区域数据结构已定义
- Google 名称与 GADM 名称映射表已建立

### 需要的数据/接口
- 地图实例：`google.maps.Map`类型
- 区域边界数据：GADM 格式（从 `xxx_index.json` 获取）
- 区域信息：`AdministrativeRegion[]`类型
- 名称映射：`googleToGadmName()` 和 `gadmToGoogleName()` 函数

---

## 数据架构

### 双数据源设计

| 数据源 | 用途 | 文件位置 |
|--------|------|----------|
| **Google 名称** | UI 下拉选项、Weather API 调用 | `src/data/google/xxx_google_hierarchy.json` |
| **GADM 数据** | 边界渲染、中心点、GPS 定位归属 | `src/data/gadm/xxx_index.json`, `xxx_centers.json` |
| **名称映射** | Google ↔ GADM 名称转换 | `src/data/google/xxx_mapping.json` |

### 数据流程

```
用户选择区域（Google 名称）
       ↓
googleToGadmName() 转换
       ↓
查询 GADM 边界数据
       ↓
渲染到地图（保留 Google 名称用于 UI）
```

---

## 实现要点

### 核心功能点

1. **名称转换**
   - 使用 `googleToGadmName()` 将 UI 名称转换为 GADM 名称
   - 边界数据查询使用 GADM 名称
   - Feature properties 保留 Google 名称用于 UI 显示

2. **GeoJSON数据加载**
   - 从 GADM 数据异步获取边界点
   - 转换为 GeoJSON 格式
   - 使用 `google.maps.Data.addGeoJson()` 加载

3. **Polygon图层绘制**
   - 为每个行政区域创建 Polygon Feature
   - 设置 Polygon 的样式（填充色、边框、透明度）
   - 根据选中状态设置不同的样式

4. **区域选择交互**
   - 点击 Polygon 切换选中区域
   - 鼠标悬停高亮效果
   - 选中区域通过动画系统自动定位（参考 [25-矢量地图动画切换.md](./25-矢量地图动画切换.md)）
     - 使用 `FlyToStrategy` 实现抛物线动画
     - 自动计算所选区域全景 zoom 级别
     - 最终视图以所选区域的GADM中心位置为核心，显示区域全景

### 技术实现方案

#### 1. 名称转换与数据查询
```typescript
// 将 Google 名称转换为 GADM 名称
const gadmProvince = googleToGadmName(province);
const gadmDistrict = googleToGadmName(district);

// 使用 GADM 名称查询边界数据
const region: Region = { country, province: gadmProvince, district: gadmDistrict };
const adminRegion = await getAdministrativeRegion(region);
```

#### 2. GeoJSON 转换
```typescript
async function convertRegionsToGeoJSON(
  country: string,
  province: string,
  districts: string[]
): Promise<GeoJSON> {
  const features: GeoJSONFeature[] = [];
  const gadmProvince = googleToGadmName(province);

  for (const district of districts) {
    const gadmDistrict = googleToGadmName(district);
    const region: Region = { country, province: gadmProvince, district: gadmDistrict };
    const adminRegion = await getAdministrativeRegion(region);

    if (adminRegion.boundary && adminRegion.boundary.length > 0) {
      // 转换坐标格式：LatLngLiteral[] → [lng, lat][]
      const coordinates = adminRegion.boundary.map(p => [p.lng, p.lat]);
      
      // 闭合多边形
      const first = coordinates[0];
      const last = coordinates[coordinates.length - 1];
      if (first[0] !== last[0] || first[1] !== last[1]) {
        coordinates.push([first[0], first[1]]);
      }

      features.push({
        type: 'Feature',
        properties: {
          country: adminRegion.country,
          province: province,  // 保留 Google 名称
          district: district,  // 保留 Google 名称
        },
        geometry: {
          type: 'Polygon',
          coordinates: [coordinates],
        },
      });
    }
  }

  return { type: 'FeatureCollection', features };
}
```

#### 3. Data Layer 加载与样式设置

**填充规则**（与热力图图层配合）：
| 区域状态 | 热力图可见 | 填充效果 |
|----------|------------|----------|
| 未选中区域 | 任意 | 透明（opacity: 0） |
| 选中区域 | 是 | 透明（热力图颜色透过显示） |
| 选中区域 | 否 | 蓝色高亮（#E3F2FD, opacity: 0.6） |

```typescript
const dataLayer = new google.maps.Data();

// 加载 GeoJSON 数据
dataLayer.addGeoJson(geoJSON, { idPropertyName: 'district' });

// 设置样式（支持 Google/GADM 名称匹配，配合热力图图层）
dataLayer.setStyle((feature) => {
  const featureDistrict = feature.getProperty('district');
  const gadmSelectedDistrict = googleToGadmName(selectedRegion.district);
  const isSelected = featureDistrict === selectedRegion.district || 
                    featureDistrict === gadmSelectedDistrict;

  // 填充规则：未选中始终透明，选中时根据热力图可见性决定
  let fillColor = 'transparent';
  let fillOpacity = 0;
  if (isSelected && !heatmapVisible) {
    fillColor = '#E3F2FD';
    fillOpacity = 0.6;
  }

  return {
    fillColor,
    fillOpacity,
    strokeColor: isSelected ? '#4285F4' : '#C0C0C0',
    strokeWeight: isSelected ? 3 : 1,
    strokeOpacity: isSelected ? 1 : 0.4,
  };
});

dataLayer.setMap(map);
```

#### 4. 区域选择交互
```typescript
// 点击事件
dataLayer.addListener('click', (event) => {
  const clickedRegion: Region = {
    country: event.feature.getProperty('country'),
    province: event.feature.getProperty('province'),
    district: event.feature.getProperty('district'),
  };
  onRegionSelect?.(clickedRegion);
  
  // 自动缩放到该区域
  const geometry = event.feature.getGeometry();
  if (geometry && 'getBounds' in geometry) {
    map.fitBounds(geometry.getBounds());
  }
});

// 鼠标悬停效果
dataLayer.addListener('mouseover', (event) => {
  dataLayer.overrideStyle(event.feature, {
    strokeColor: '#4285F4',
    strokeWeight: 2,
    strokeOpacity: 0.8,
  });
});

dataLayer.addListener('mouseout', (event) => {
  const isSelected = selectedRegion.district === event.feature.getProperty('district');
  dataLayer.overrideStyle(event.feature, {
    strokeColor: isSelected ? '#4285F4' : 'transparent',
    strokeWeight: isSelected ? 3 : 0,
    strokeOpacity: isSelected ? 1 : 0,
  });
});
```

### 关键代码结构

#### useRegionBoundaryLayer Hook

```typescript
interface RegionBoundaryLayerConfig {
  map: google.maps.Map | null;
  selectedRegion: Region;
  districts: string[];      // Google 名称的区域列表
  country: string;
  province: string;         // Google 名称
  onRegionSelect?: (region: Region) => void;
  heatmapVisible?: boolean; // 热力图图层是否可见（影响填充样式）
}

export function useRegionBoundaryLayer({
  map, selectedRegion, districts, country, province, onRegionSelect
}: RegionBoundaryLayerConfig) {
  const dataLayerRef = useRef<google.maps.Data | null>(null);
  const isInitializedRef = useRef(false);

  // 初始化数据图层
  useEffect(() => {
    if (!map || !window.google?.maps?.Data) return;

    // 清理旧图层
    if (dataLayerRef.current) {
      dataLayerRef.current.setMap(null);
    }

    const dataLayer = new google.maps.Data();
    dataLayerRef.current = dataLayer;

    const loadBoundaries = async () => {
      const geoJSON = await convertRegionsToGeoJSON(country, province, districts);
      if (geoJSON.features.length === 0) return;

      dataLayer.addGeoJson(geoJSON, { idPropertyName: 'district' });
      // 设置样式、事件监听...
      dataLayer.setMap(map);
      isInitializedRef.current = true;
    };

    loadBoundaries();

    return () => {
      dataLayerRef.current?.setMap(null);
      dataLayerRef.current = null;
      isInitializedRef.current = false;
    };
  }, [map, country, province, districts.join(','), selectedRegion.district]);

  // 更新选中区域样式
  useEffect(() => {
    if (!dataLayerRef.current || !isInitializedRef.current) return;

    dataLayerRef.current.forEach((feature) => {
      const isSelected = selectedRegion.district === feature.getProperty('district');
      dataLayerRef.current!.overrideStyle(feature, {
        fillColor: isSelected ? '#E3F2FD' : '#F5F5F5',
        fillOpacity: isSelected ? 0.6 : 0.3,
        strokeColor: isSelected ? '#4285F4' : 'transparent',
        strokeWeight: isSelected ? 3 : 0,
      });
    });
  }, [selectedRegion]);

  return { dataLayer: dataLayerRef.current };
}
```

---

## 输入输出

### 输入
- **地图实例**：`google.maps.Map` 类型
- **区域边界数据**：GADM 格式（通过 `getAdministrativeRegion()` 获取）
- **区域列表**：`string[]`（Google 名称）
- **选中区域**：`Region` 类型

### 输出
- **区域边界图层**：显示在地图上的 Polygon 图层
- **图层实例**：`google.maps.Data` 实例
- **区域选择事件**：通过 `onRegionSelect` 回调传递

---

## 验收标准

### 功能验收标准
- [x] 行政区域边界可以正确绘制在地图上
- [x] 区域边界使用 Polygon 显示
- [x] 点击区域可以切换选中区域
- [x] 选中区域有明显的视觉区分
- [x] 边界数据可以正确加载和渲染
- [x] 从控制面板选择区域后，地图自动定位到该区域
- [x] Google 名称与 GADM 名称正确映射

### 视觉验收标准
- [x] 未选中区域：透明填充，亮银色边框（#C0C0C0）
- [x] 选中区域（无热力图）：蓝色高亮填充（#E3F2FD），蓝色边框（#4285F4）
- [x] 选中区域（有热力图）：透明填充，蓝色边框（#4285F4）
- [x] 鼠标悬停时边框高亮
- [x] 边界样式符合 Google Maps 设计风格

### 性能验收标准
- [x] 边界数据加载时间在 2 秒内
- [x] 区域选择响应时间在 100ms 内
- [x] 样式更新流畅，无明显卡顿

---

## 注意事项

### 常见问题

1. **名称不匹配导致边界无法加载**
   - 问题：UI 使用 Google 名称，GADM 数据使用 GADM 名称
   - 解决：使用 `googleToGadmName()` 转换后查询

2. **边界显示为正方形**
   - 问题：GADM 数据未找到，回退到简化边界
   - 解决：检查映射表是否包含该区域的映射

3. **GeoJSON 坐标格式**
   - 问题：GADM 使用 `{ lat, lng }`，GeoJSON 需要 `[lng, lat]`
   - 解决：在 `convertBoundaryToGeoJSONCoordinates()` 中转换

### 技术难点
- **双数据源管理**：Google 名称用于 UI/API，GADM 名称用于边界数据
- **异步边界加载**：需要等待 GADM 数据加载完成
- **性能优化**：大量区域的渲染需要优化

### 扩展性考虑
- Hook 设计可复用于其他地图图层
- 样式配置可提取为常量
- 支持未来添加更多国家/区域数据

---

## 相关文件

| 文件路径 | 说明 |
|----------|------|
| `src/hooks/useRegionBoundaryLayer.ts` | 边界图层 Hook |
| `src/lib/gadmDataLoader.ts` | GADM 数据加载器 |
| `src/lib/regionData.ts` | 区域数据管理 |
| `src/data/regions.ts` | 数据导入和名称转换 |
| `src/data/google/xxx_mapping.json` | 名称映射表 |
| `src/data/gadm/xxx_index.json` | GADM 边界数据 |

---

## 下一步

### 后续步骤的准备工作
- 区域边界已绘制，可以在步骤12中添加热力图图层
- 区域选择功能已实现，可以在步骤15中使用

### 数据/接口的传递
- 区域选择事件通过 `onRegionSelect` 回调传递给 Dashboard 组件
- 选中区域通过 props 传递给其他组件

---

**文档版本**：v2.0  
**创建日期**：2025-01-27  
**最后更新**：2025-12-17
