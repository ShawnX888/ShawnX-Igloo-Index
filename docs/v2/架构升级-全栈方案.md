# 全栈架构升级方案

**文档版本**：v2.0  
**创建日期**：2025-01-27  
**最后更新**：2025-01-27  
**目标**：将纯前端应用升级为全栈应用，支持保单管理、理赔计算、统计展示和AI Agent集成

---

## 1. 架构总览

### 1.1 架构模式
采用**前后端分离**的微服务架构，支持水平扩展和模块化开发。

```
┌─────────────────────────────────────────────────────────────┐
│                        前端层 (Frontend)                      │
│  React 19 + TypeScript + Vite + Tailwind CSS                │
│  - 地图可视化（Google Maps + 粒子效果）                       │
│  - 数据面板（统计、图表）                                     │
│  - AI对话界面（Google Contextual View）                      │
└─────────────────────────────────────────────────────────────┘
                            ↕ HTTP/WebSocket
┌─────────────────────────────────────────────────────────────┐
│                      API网关层 (API Gateway)                  │
│  FastAPI (Python) - 统一入口、认证、限流                      │
└─────────────────────────────────────────────────────────────┘
                            ↕
        ┌───────────────────┼───────────────────┐
        ↓                   ↓                   ↓
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│  业务服务层   │  │  计算服务层   │  │  AI Agent层   │
│  (Services)  │  │  (Compute)   │  │  (Agents)    │
│              │  │              │  │              │
│ - 保单服务   │  │ - 风险计算   │  │ - Chat Agent │
│ - 理赔服务   │  │ - 理赔计算   │  │ - Orchestrator│
│ - 风险服务   │  │ - 天气计算   │  │ - 专业团队   │
│ - 统计服务   │  │              │  │              │
│ - 天气服务   │  │              │  │              │
└──────────────┘  └──────────────┘  └──────────────┘
        ↓                   ↓                   ↓
┌─────────────────────────────────────────────────────────────┐
│                      数据层 (Data Layer)                      │
│  PostgreSQL + PostGIS (地理空间数据)                          │
│  Redis (缓存)                                                │
│  Celery + Redis (任务队列)                                   │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 技术栈选型

#### 前端技术栈（保持现有）
- **框架**：React 19 + TypeScript
- **构建工具**：Vite
- **样式**：Tailwind CSS
- **动画**：Framer Motion + Three.js（粒子效果）
- **地图**：Google Maps JavaScript API
- **AI界面**：Google Contextual View AI kit
- **图表**：Recharts

#### 后端技术栈（新增）
- **框架**：FastAPI (Python 3.10+)
- **数据库**：PostgreSQL 15+ + PostGIS 3.3+
- **缓存**：Redis 7+
- **任务队列**：Celery 5.3+ + Redis
- **ORM**：SQLAlchemy 2.0+ + GeoAlchemy2
- **数据验证**：Pydantic 2.0+
- **AI Agent**：Google ADK (Agent Development Kit)

#### 基础设施
- **容器化**：Docker + Docker Compose
- **部署**：支持云部署（GCP/AWS/Azure）
- **监控**：Prometheus + Grafana（可选）

---

## 2. 数据库设计

### 2.1 核心表结构

#### 2.1.1 保单表 (policies)
存储保单基本信息，包括保单号、保障计划、投保人信息、保障区域、保障期限和保额。

**关键字段**：
- `policy_number`：保单号（唯一标识）
- `product_id`：保障计划ID（关联产品）
- `coverage_region`：被保区域（JSONB格式，包含country、province、district）
- `coverage_start/end`：保障起止时间（TIMESTAMPTZ）
- `coverage_amount`：保额（DECIMAL类型，避免浮点误差）

**索引策略**：
- 按产品ID、保障日期范围、区域建立索引，优化查询性能

#### 2.1.2 理赔单表 (claims)
存储理赔单信息，关联保单和风险事件，记录理赔金额和tier级别。

**关键字段**：
- `policy_id`：关联保单（外键）
- `risk_event_id`：关联风险事件（可选）
- `tier_level`：风险级别（tier1/tier2/tier3）
- `payout_percentage`：赔付百分比（如2.00, 8.00）
- `payout_amount`：理赔金额（DECIMAL类型）
- `trigger_timestamp`：触发时间

**索引策略**：
- 按保单ID、触发时间、状态、tier级别建立索引

#### 2.1.3 风险事件表 (risk_events)
持久化风险事件计算结果，用于理赔计算和历史查询。

**关键字段**：
- `product_id`：产品ID
- `region`：区域信息（JSONB）
- `timestamp`：事件时间
- `data_type`：数据类型（historical/predicted）
- `weather_type`：天气类型（rainfall/wind/temperature等）
- `tier_level`：风险级别
- `trigger_value`：触发时的累计值
- `threshold_value`：触发的阈值

**唯一约束**：同一产品、区域、时间、天气类型、tier级别只能有一条记录

#### 2.1.4 历史天气数据表 (historical_weather_data)
存储历史天气数据，支持多种天气类型。

**关键字段**：
- `region`：区域信息（JSONB）
- `timestamp`：时间戳
- `weather_type`：天气类型
- `value`：数值（DECIMAL类型）
- `unit`：单位（mm/kmh/celsius等）
- `data_source`：数据来源（mock/api/manual）

**唯一约束**：同一区域、时间、天气类型只能有一条记录

### 2.2 数据关系图

```
policies (保单)
    ├── claims (理赔单) [1:N]
    └── risk_events (风险事件) [间接关联，通过product_id和region]

claims (理赔单)
    ├── policies (保单) [N:1，外键关联]
    └── risk_events (风险事件) [可选关联，通过risk_event_id]

risk_events (风险事件)
    ├── historical_weather_data (历史天气数据) [间接关联，通过region和timestamp]
    └── claims (理赔单) [可选关联，通过risk_event_id]

historical_weather_data (历史天气数据)
    └── risk_events (风险事件) [间接关联]
```

### 2.3 数据迁移策略

1. **初始数据导入**：使用 Alembic 管理数据库迁移
2. **Mock数据生成**：提供数据生成脚本，支持批量导入
3. **数据备份**：定期备份策略（建议每日）

---

## 3. 后端服务设计

### 3.1 服务架构概览

```
backend/
├── app/
│   ├── api/                    # API路由层
│   │   └── v1/                 # API版本管理
│   │       ├── policies.py     # 保单API
│   │       ├── claims.py        # 理赔API
│   │       ├── statistics.py   # 统计API
│   │       ├── weather.py      # 天气数据API
│   │       ├── risk_events.py  # 风险事件API
│   │       └── agents.py       # AI Agent API
│   │
│   ├── services/               # 业务逻辑层
│   │   ├── policy_service.py   # 保单服务
│   │   ├── claim_service.py    # 理赔服务
│   │   ├── risk_service.py     # 风险服务
│   │   ├── statistics_service.py # 统计服务
│   │   └── weather_service.py  # 天气数据服务
│   │
│   ├── compute/                 # 计算引擎层
│   │   ├── risk_calculator.py  # 风险计算引擎
│   │   ├── claim_calculator.py  # 理赔计算引擎
│   │   └── weather_calculator.py # 天气数据计算
│   │
│   ├── agents/                 # AI Agent层
│   │   ├── chat_agent.py       # Chat Agent（外层）
│   │   ├── orchestrator_agent.py # Orchestrator Agent（协调层）
│   │   └── expertise_agents/    # 专业团队Agent
│   │       ├── product_expertise_agent.py
│   │       ├── risk_claim_expertise_agent.py
│   │       └── policy_expertise_agent.py
│   │
│   ├── tasks/                   # Celery任务
│   │   ├── risk_event_calculation.py # 风险事件计算任务
│   │   ├── claim_calculation.py # 理赔计算任务
│   │   └── weather_sync.py     # 天气数据同步任务
│   │
│   └── models/                  # 数据模型（SQLAlchemy）
│       ├── policy.py
│       ├── claim.py
│       ├── risk_event.py
│       └── weather_data.py
```

### 3.2 业务服务层详细说明

#### 3.2.1 保单服务 (Policy Service)
**职责**：管理保单的完整生命周期

**核心功能**：
- **保单CRUD**：创建、查询、更新、删除保单
- **保单查询**：支持多维度查询（按产品、区域、时间范围、投保人等）
- **保单验证**：验证保单数据的完整性和合法性（如保障日期、区域有效性）
- **保单统计**：按产品、区域、时间范围统计保单数量和保额
- **产品关联**：获取保单关联的产品配置信息

**数据访问**：
- 直接操作 `policies` 表
- 通过产品ID关联产品配置

#### 3.2.2 理赔服务 (Claim Service)
**职责**：管理理赔单的完整生命周期

**核心功能**：
- **理赔单创建**：创建理赔单记录（主要供理赔计算引擎调用）
  - 验证理赔单数据的完整性和合法性
  - 生成理赔单号
  - 关联保单和风险事件
- **理赔查询**：支持多维度查询（按保单、区域、时间范围、tier级别等）
- **理赔统计**：按产品、区域、时间范围统计理赔数量和理赔额
- **理赔关联**：关联保单和风险事件信息
- **理赔状态管理**：管理理赔单状态（generated/approved/rejected）
- **理赔单更新**：更新理赔单信息（如状态变更）

**数据访问**：
- 直接操作 `claims` 表（创建、查询、更新）
- 关联查询 `policies` 和 `risk_events` 表

#### 3.2.3 风险服务 (Risk Service)
**职责**：管理风险事件的完整生命周期

**核心功能**：
- **风险事件创建**：创建风险事件记录（主要供风险计算引擎调用）
  - 验证风险事件数据的完整性和合法性
  - 检查唯一性约束（避免重复创建）
  - 关联产品、区域和天气数据
- **风险事件查询**：支持多维度查询（按产品、区域、时间范围、天气类型、tier级别等）
- **风险事件统计**：按产品、区域、时间范围统计风险事件数量和分布
- **风险事件关联**：关联天气数据和产品配置
- **风险事件批量创建**：批量创建风险事件（提高性能）

**数据访问**：
- 直接操作 `risk_events` 表（创建、查询）
- 关联查询 `historical_weather_data` 表

#### 3.2.4 统计服务 (Statistics Service)
**职责**：提供聚合统计和数据分析功能

**核心功能**：
- **保单统计**：
  - 按产品、区域、时间范围统计保单数量和保额
  - 支持时间区间与保单保障期的交集计算
  - 支持地图级别（省份）和数据面板级别（district）的统计
- **理赔统计**：
  - 按产品、区域、时间范围统计理赔数量和理赔额
  - 支持时间趋势分析（时间序列数据）
  - 与风险事件图表对应
- **风险统计**：
  - 按产品、区域、时间范围统计风险事件数量和分布
  - 支持按tier级别分组统计
- **综合统计**：
  - 保单与理赔的关联分析
  - 风险与理赔的关联分析

**数据访问**：
- 聚合查询多个表（policies、claims、risk_events）
- 使用数据库聚合函数（COUNT、SUM、AVG等）

#### 3.2.5 天气服务 (Weather Service)
**职责**：管理天气数据的存储和查询

**核心功能**：
- **天气数据查询**：支持按区域、时间范围、天气类型查询
- **天气数据导入**：支持批量导入历史天气数据（MVP阶段使用mock数据）
- **天气数据统计**：计算天气数据的统计指标（均值、总量、最大值、最小值等）
- **天气数据缓存**：使用Redis缓存常用查询结果

**数据访问**：
- 直接操作 `historical_weather_data` 表
- 使用Redis缓存查询结果

### 3.3 计算服务层详细说明

#### 3.3.1 风险计算引擎 (Risk Calculator)
**职责**：基于产品规则和天气数据计算风险事件

**核心功能**：
- **产品规则解析**：解析产品的风险事件触发条件（riskRules）
  - 时间窗口配置（hourly/daily/weekly/monthly）
  - 阈值配置（tier1/tier2/tier3）
  - 计算逻辑（聚合方式、比较运算符）
- **天气数据聚合**：根据产品规则聚合天气数据
  - 滑动窗口计算（如4小时累计、7天累计）
  - 时间窗口匹配（如日内产品限制在00:00-23:59）
- **风险事件生成**：判断是否触发风险事件
  - 比较聚合值与阈值
  - 确定触发的tier级别
  - 生成风险事件记录
- **扩展数据支持**：支持扩展数据回溯（用于风险叠加示意图和风险事件计算）

**输入**：
- 产品配置（riskRules）
- 天气数据（hourly/daily）
- 区域信息
- 时间范围

**输出**：
- 风险事件列表（包含tier级别、触发值、阈值等）

**与服务的协作**：
- 调用风险服务的 `create_risk_event()` 或 `batch_create_risk_events()` 方法将计算结果持久化到数据库

#### 3.3.2 理赔计算引擎 (Claim Calculator)
**职责**：基于风险事件和产品赔付规则计算理赔单

**核心功能**：
- **产品赔付规则解析**：解析产品的赔付规则（payoutRules）
  - 赔付百分比配置（以产品配置为准，例如：tier1: 20%, tier2: 50%, tier3: 100%）
  - 赔付频率限制（如once per day per policy）
- **Tier差额理赔计算逻辑**：实现tier差额理赔计算，确保总赔付金额满足payoutRules
  - **规则1**：若满足理赔条件时，同时期没有低档位的claim，则新生成claim的赔付为该档位原始比例
  - **规则2**：若满足理赔条件时，同时期已有低档位的claim，则新生成claim的赔付为差额（当前档位比例 - 已有最高档位比例）
  - **规则3**：同一时间点同时触发多个tier时，一定以最高tier为准，只生成最高tier的claim
  - **同时期定义**：特指同一个保单的赔付频率限制所定义的时间窗口
    - 例如："once per day per policy"中的"per day"表示同一天内的风险事件属于同一时期
    - 例如："once per month per policy"中的"per month"表示同一月内的风险事件属于同一时期
    - 同时期内的多个风险事件，按照tier差额逻辑计算理赔
- **理赔单生成**：生成理赔单记录
  - 关联保单和风险事件
  - 计算理赔金额（保额 × 赔付百分比）
  - 记录触发时间和计算时间
- **重复理赔检查**：检查是否已存在该时间点的理赔单，避免重复生成

**计算逻辑示例**（假设产品配置：tier1: 20%, tier2: 50%, tier3: 100%，赔付频率限制：once per day per policy or once per month per policy）：

**示例1：按顺序触发（tier1 → tier2 → tier3）**
- 假设所有风险事件发生在同一天（同一时期，per day）
- 时间点T1：触发tier1风险事件，同时期（同一天）没有其他claim
  - 生成claim：赔付比例 = 20%（原始比例）
- 时间点T2：触发tier2风险事件，同时期（同一天）已有tier1的claim
  - 生成claim：赔付比例 = 50% - 20% = 30%（差额）
- 时间点T3：触发tier3风险事件，同时期（同一天）已有tier2的claim
  - 生成claim：赔付比例 = 100% - 50% = 50%（差额）
- **总赔付**：20% + 30% + 50% = 100% ✓

**示例2：跳过tier1，直接触发tier2和tier3**
- 假设所有风险事件发生在同一天（同一时期，per day）
- 时间点T1：触发tier2风险事件，同时期（同一天）没有其他claim
  - 生成claim：赔付比例 = 50%（原始比例）
- 时间点T2：触发tier3风险事件，同时期（同一天）已有tier2的claim
  - 生成claim：赔付比例 = 100% - 50% = 50%（差额）
- **总赔付**：50% + 50% = 100% ✓

**示例3：跳过tier1和tier2，直接触发tier3**
- 时间点T1：触发tier3风险事件，同时期（同一天）没有其他claim
  - 生成claim：赔付比例 = 100%（原始比例）
- **总赔付**：100% ✓

**示例4：先触发tier2，后触发tier1（逆序触发）**
- 假设所有风险事件发生在同一天（同一时期，per day）
- 时间点T1：触发tier2风险事件，同时期（同一天）没有其他claim
  - 生成claim：赔付比例 = 50%（原始比例）
- 时间点T2：触发tier1风险事件，同时期（同一天）已有tier2的claim
  - 不生成新claim（因为tier1 < tier2，已有更高档位的claim）
- **总赔付**：50%（注意：这种情况下，tier1的风险事件不会生成claim，因为已有更高档位的claim）

**示例5：同一时间点同时触发多个tier（一定以最高tier为准）**
- 时间点T1：同时触发tier1、tier2、tier3风险事件（同一时间点）
  - **处理规则**：一定以最高tier为准
  - 只生成最高档位tier3的claim：赔付比例 = 100%（原始比例）
  - 不生成tier1和tier2的claim（因为同一时间点已有更高档位的风险事件）
- **总赔付**：100% ✓

**示例6：同一时期（per day）内不同时间点触发多个tier**
- 假设产品配置：赔付频率限制为"once per day per policy"
- 日期D1的08:00：触发tier1风险事件，同时期（同一天）没有其他claim
  - 生成claim：赔付比例 = 20%（原始比例）
- 日期D1的14:00：触发tier2风险事件，同时期（同一天）已有tier1的claim
  - 生成claim：赔付比例 = 50% - 20% = 30%（差额）
- 日期D1的20:00：触发tier3风险事件，同时期（同一天）已有tier2的claim
  - 生成claim：赔付比例 = 100% - 50% = 50%（差额）
- **总赔付**：20% + 30% + 50% = 100% ✓
- **注意**：日期D2的风险事件属于新的时期，可以重新开始计算

**示例7：同一时期（per month）内不同日期触发多个tier**
- 假设产品配置：赔付频率限制为"once per month per policy"
- 2025年1月5日：触发tier1风险事件，同时期（同一月）没有其他claim
  - 生成claim：赔付比例 = 20%（原始比例）
- 2025年1月15日：触发tier2风险事件，同时期（同一月）已有tier1的claim
  - 生成claim：赔付比例 = 50% - 20% = 30%（差额）
- 2025年1月25日：触发tier3风险事件，同时期（同一月）已有tier2的claim
  - 生成claim：赔付比例 = 100% - 50% = 50%（差额）
- **总赔付**：20% + 30% + 50% = 100% ✓
- **注意**：2025年2月的风险事件属于新的时期，可以重新开始计算

**输入**：
- 保单信息（包含保额）
- 风险事件列表
- 产品配置（payoutRules）

**输出**：
- 理赔单列表（包含理赔金额、tier级别等）

**与服务的协作**：
- 调用理赔服务的 `create_claim()` 方法将计算结果持久化到数据库

#### 3.3.3 天气数据计算引擎 (Weather Calculator)
**职责**：处理天气数据的计算和转换

**核心功能**：
- **天气数据生成**：MVP阶段生成mock天气数据
  - 支持多种天气类型（rainfall、wind、temperature等）
  - 基于区域种子生成确定性随机数据
  - 支持历史数据和预测数据
- **天气数据聚合**：按时间粒度聚合天气数据
  - 小时级数据聚合为日级数据
  - 支持多种聚合方式（sum、avg、max、min）
- **天气数据转换**：单位转换和格式转换
  - 单位转换（如mm到inch、celsius到fahrenheit）
  - 数据格式转换（适配不同API需求）

**输入**：
- 区域信息
- 时间范围
- 天气类型
- 数据粒度（hourly/daily）

**输出**：
- 天气数据列表（包含时间戳、数值、单位等）

### 3.4 Celery定时任务

#### 3.4.1 风险事件计算任务 (risk_event_calculation)
**执行频率**：根据产品类型的不同计算频率和逻辑，由Celery Beat动态调度

**职责**：
- 定期计算所有产品的历史风险事件
- 支持历史数据回溯计算
- **注意**：预测数据的风险事件不在本任务中计算，而是在天气数据同步任务中，当预测数据更新时一并计算

**执行流程**：
1. 获取所有需要计算的产品
2. 对每个产品：
   - 获取该产品的风险规则配置
   - 获取相关的历史天气数据（仅历史数据）
   - 调用风险计算引擎计算风险事件
   - 调用风险服务的批量创建方法将风险事件保存到数据库（data_type标记为'historical'）
3. 记录任务执行结果

#### 3.4.2 理赔计算任务 (claim_calculation)
**执行频率**：每天23:00执行

**职责**：
- 定期计算所有保单的理赔单
- 支持历史保单回溯计算
- 支持保障中保单的实时计算

**执行流程**：
1. 获取所有需要计算的保单（保障中或历史保单）
2. 对每个保单：
   - 获取该保单的风险事件（基于产品规则和天气数据）
   - 调用理赔计算引擎计算理赔单
   - 调用理赔服务的创建方法将理赔单保存到数据库
3. 记录任务执行结果

#### 3.4.3 天气数据同步任务 (weather_sync)
**执行频率**：根据数据源配置（未来扩展，预测数据定时更新）

**职责**：
- 同步外部天气数据API的数据（包括历史数据和预测数据）
- 将同步的数据保存到数据库
- **预测数据风险事件计算**：当预测数据更新时，自动计算基于预测数据的风险事件
  - 获取所有产品的风险规则配置
  - 基于更新的预测天气数据计算风险事件
  - 调用风险服务的批量创建方法将风险事件保存到数据库（data_type标记为'predicted'）
- 清理过期的缓存数据

### 3.5 API设计

#### 3.5.1 RESTful API规范

**基础URL**：`/api/v1`

**保单管理**：
- `GET /policies` - 获取保单列表（支持筛选）
- `GET /policies/{id}` - 获取保单详情
- `POST /policies` - 创建保单（MVP用mock data）
- `PUT /policies/{id}` - 更新保单
- `DELETE /policies/{id}` - 删除保单

**理赔管理**：
- `GET /claims` - 获取理赔单列表（支持筛选）
- `GET /claims/{id}` - 获取理赔单详情
- `POST /claims` - 创建理赔单（内部接口，供计算引擎调用，或用于数据修复/测试）
- `PUT /claims/{id}` - 更新理赔单（如状态变更）
- `GET /policies/{id}/claims` - 获取保单的理赔单列表

**统计查询**：
- `GET /statistics/policies` - 保单统计（数量、保额）
- `GET /statistics/claims` - 理赔统计（数量、理赔额）
- `GET /statistics/trends` - 趋势统计（时间序列）

**天气数据**：
- `GET /weather/historical` - 获取历史天气数据
- `POST /weather/historical` - 导入历史天气数据（MVP用mock）

**风险事件**：
- `GET /risk-events` - 获取风险事件列表
- `GET /risk-events/{id}` - 获取风险事件详情
- `POST /risk-events` - 创建风险事件（内部接口，供计算引擎调用，或用于数据修复/测试）
- `POST /risk-events/batch` - 批量创建风险事件（内部接口，提高性能）
- `GET /risk-events/calculate` - 实时计算风险事件（触发计算，结果通过POST接口保存）

**AI Agent**：
- `POST /agents/chat` - AI对话接口

---

## 4. AI Agent架构设计

### 4.1 架构模式：Tool Use / Function Calling

AI Agent采用**工具调用（Tool Use / Function Calling）**模式，通过调用后端业务服务层的功能来实现AI能力，而不是作为独立的孤岛。这种方式确保：
- **业务逻辑复用**：AI Agent复用后端已有的业务逻辑，避免重复实现
- **数据一致性**：AI Agent和API使用相同的数据源和计算逻辑
- **可维护性**：业务逻辑集中管理，便于维护和扩展

### 4.2 多Agent协作架构

```
┌─────────────────────────────────────────────────────────┐
│           表现层 (Presentation Layer)                     │
│         Google Contextual View AI kit                    │
│         (前端集成，用户交互界面)                           │
└─────────────────────────────────────────────────────────┘
                        ↕
┌─────────────────────────────────────────────────────────┐
│          Chat Agent (外层对话Agent)                      │
│         - 处理用户自然语言输入                            │
│         - 管理对话上下文                                  │
│         - 调用Orchestrator Agent                         │
└─────────────────────────────────────────────────────────┘
                        ↕
┌─────────────────────────────────────────────────────────┐
│       Orchestrator Agent (协调Agent)                      │
│         - 意图识别和路由                                  │
│         - 协调多个专业Agent的协作                         │
│         - 管理Agent间的对话流程                           │
└─────────────────────────────────────────────────────────┘
        ↕              ↕              ↕
┌──────────────┐ ┌──────────────┐ ┌──────────────┐
│ Product      │ │ Risk & Claim │ │ Policy       │
│ Expertise    │ │ Expertise     │ │ Expertise    │
│ Agent        │ │ Agent         │ │ Agent        │
│              │ │               │ │              │
│ - 产品说明   │ │ - 历史风险查询│ │ - 保单查询   │
│ - 产品规则   │ │ - 风险预测试算│ │ - 保单统计   │
│ - 产品对比   │ │ - 理赔查询   │ │ - 保单分析   │
│              │ │ - 理赔解释   │ │              │
│              │ │ - 理赔预测   │ │              │
└──────────────┘ └──────────────┘ └──────────────┘
        ↕              ↕              ↕
┌─────────────────────────────────────────────────────────┐
│             工具层 (Tools Layer)                         │
│  通过Function Calling调用后端业务服务                      │
│  - Policy Service (保单服务)                             │
│  - Claim Service (理赔服务)                              │
│  - Risk Service (风险服务)                               │
│  - Statistics Service (统计服务)                        │
│  - Weather Service (天气服务)                            │
│  - Risk Calculator (风险计算引擎)                         │
│  - Claim Calculator (理赔计算引擎)                        │
└─────────────────────────────────────────────────────────┘
        ↕
┌─────────────────────────────────────────────────────────┐
│             数据层 (Data Layer)                           │
│         PostgreSQL + Redis (缓存)                         │
└─────────────────────────────────────────────────────────┘
```

### 4.3 Agent详细说明

#### 4.3.1 Chat Agent (外层对话Agent)
**职责**：作为用户交互的第一层，处理自然语言对话

**核心功能**：
- **自然语言理解**：理解用户的自然语言输入
- **对话上下文管理**：维护对话历史和上下文
- **意图初步识别**：初步判断用户意图（产品相关、风险相关、理赔相关、保单相关等）
- **调用Orchestrator**：将用户请求转发给Orchestrator Agent
- **响应格式化**：将Agent的响应格式化为用户友好的自然语言

**技术实现**：
- 使用Google ADK实现
- 集成Google Contextual View AI kit作为前端界面

#### 4.3.2 Orchestrator Agent (协调Agent)
**职责**：协调多个专业Agent的协作，路由请求到合适的Agent

**核心功能**：
- **意图识别和路由**：
  - 识别用户意图（产品查询、风险查询、理赔查询、保单查询、风险预测、理赔预测等）
  - 路由到合适的专业Agent
    - 产品相关 → Product Expertise Agent
    - 风险和理赔相关 → Risk & Claim Expertise Agent
    - 保单相关 → Policy Expertise Agent
- **多Agent协作**：
  - 协调多个专业Agent共同完成复杂任务
  - 管理Agent间的对话流程
- **工具调用管理**：
  - 管理对后端业务服务的工具调用
  - 处理工具调用的结果和错误
- **上下文传递**：
  - 在Agent间传递对话上下文
  - 维护全局对话状态

**技术实现**：
- 使用Google ADK实现
- 实现Function Calling机制，调用后端业务服务

#### 4.3.3 Product Expertise Agent (产品专业Agent)
**职责**：处理产品相关的专业问题

**核心功能**：
- **产品说明**：解释产品的定义、特点、适用场景
- **产品规则解释**：解释产品的风险事件触发条件和赔付规则（仅说明规则本身，不涉及实际风险事件查询）
- **产品对比**：对比不同产品的差异和特点
- **产品推荐**：根据用户需求推荐合适的产品

**工具调用**：
- 调用产品库获取产品配置

#### 4.3.4 Risk & Claim Expertise Agent (风险与理赔专业Agent)
**职责**：处理风险事件和理赔相关的专业问题

**核心功能**：
- **历史风险查询**：查询历史风险事件信息（按产品、区域、时间范围、天气类型、tier级别等）
- **风险预测试算**：基于预测天气数据实时计算潜在风险事件
  - 调用风险计算引擎进行预测计算
  - 使用预测天气数据作为输入
  - 返回预测的风险事件结果
- **理赔查询**：查询理赔单信息（按保单、区域、时间范围等）
- **理赔解释**：解释理赔单的生成原因和计算逻辑
- **理赔预测**：基于预测风险事件预测潜在理赔
- **理赔统计**：提供理赔统计和分析
- **风险统计**：提供风险事件统计和分析

**工具调用**：
- 调用风险服务查询历史风险事件
- 调用风险计算引擎进行风险预测试算
- 调用理赔服务查询理赔单
- 调用统计服务获取理赔和风险统计
- 调用理赔计算引擎进行理赔预测

#### 4.3.5 Policy Expertise Agent (保单专业Agent)
**职责**：处理保单相关的专业问题

**核心功能**：
- **保单查询**：查询保单信息（按产品、区域、时间范围、投保人等）
- **保单统计**：提供保单统计和分析
- **保单分析**：分析保单的保障情况（不涉及风险事件查询）

**工具调用**：
- 调用保单服务查询保单
- 调用统计服务获取保单统计

### 4.4 工具调用机制

#### 4.4.1 Function Calling规范
每个后端业务服务提供标准化的Function接口，供AI Agent调用：

**Function定义格式**：
- Function名称：清晰描述功能
- Function描述：详细说明功能用途和参数
- 参数定义：使用JSON Schema定义参数结构
- 返回值定义：定义返回值的结构和格式

**示例Function**：
- `get_policy_statistics`：获取保单统计
- `get_claim_statistics`：获取理赔统计
- `get_risk_events`：查询历史风险事件
- `calculate_risk_prediction`：计算风险预测（基于预测天气数据）
- `explain_claim_calculation`：解释理赔计算逻辑

#### 4.4.2 工具调用流程
1. **Agent识别需求**：Agent理解用户需求，确定需要调用的工具
2. **Function Calling**：Agent调用后端业务服务的Function
3. **业务逻辑执行**：后端服务执行业务逻辑，返回结果
4. **结果处理**：Agent处理返回结果，生成用户友好的响应
5. **响应返回**：Agent将响应返回给Chat Agent，最终返回给用户

---

## 5. 前端架构升级

### 5.1 新增组件和功能

**组件结构**：
- `PolicyStatistics.tsx`：保单统计组件（新增）
- `ClaimStatistics.tsx`：理赔统计组件（新增）
- `WeatherParticleLayer.tsx`：天气粒子效果图层（新增）
- `PolicyList.tsx`：保单列表组件（新增）
- `PolicyDetail.tsx`：保单详情组件（新增）
- `PolicyImport.tsx`：保单导入组件（新增）

**Hooks结构**：
- `usePolicyStatistics.ts`：保单统计Hook（新增）
- `useClaimStatistics.ts`：理赔统计Hook（新增）
- `usePolicies.ts`：保单数据Hook（新增）
- `useClaims.ts`：理赔数据Hook（新增）
- `useWeatherParticles.ts`：天气粒子效果Hook（新增）

**API客户端**：
- `policies.ts`：保单API客户端
- `claims.ts`：理赔API客户端
- `statistics.ts`：统计API客户端
- `weather.ts`：天气数据API客户端

**粒子效果库**：
- `rainParticles.ts`：降雨粒子效果（参考Windy.com）
- `windParticles.ts`：风速粒子效果（参考Windy.com）
- `typhoonParticles.ts`：台风粒子效果（未来扩展）

### 5.2 动画效果重构

**参考Windy.com的粒子效果**：
- 使用Three.js实现粒子系统
- 支持风和雨的粒子效果
- 粒子根据天气数据（风速、风向）动态更新
- 支持实时数据流动画

**技术实现**：
- Three.js用于3D粒子渲染
- WebGL用于高性能渲染
- 与Google Maps集成，作为地图图层

### 5.3 天气类型扩展

**支持风速数据**：
- 新增风速数据可视化
- 使用粒子效果展示风速和风向
- 支持风速数据的热力图展示（非传统热力图，使用粒子效果）

**未来扩展**：
- 台风气旋和轨迹可视化
- 支持更多天气类型（温度、湿度、气压等）

---

## 6. 部署架构

### 6.1 Docker容器化

**服务容器**：
- `postgres`：PostgreSQL + PostGIS数据库
- `redis`：Redis缓存
- `backend`：后端API服务（FastAPI）
- `celery_worker`：Celery Worker（执行异步任务）
- `celery_beat`：Celery Beat（定时任务调度）
- `frontend`：前端服务（Vite开发服务器或Nginx生产服务器）

**数据持久化**：
- PostgreSQL数据卷：持久化数据库数据
- Redis数据卷：持久化缓存数据

### 6.2 环境变量配置

**后端环境变量**：
- `DATABASE_URL`：数据库连接字符串
- `REDIS_URL`：Redis连接字符串
- `GOOGLE_MAPS_API_KEY`：Google Maps API密钥
- `CELERY_BROKER_URL`：Celery消息队列URL
- `CELERY_RESULT_BACKEND`：Celery结果后端URL

**前端环境变量**：
- `VITE_API_BASE_URL`：后端API地址
- `VITE_GOOGLE_MAPS_API_KEY`：Google Maps API密钥

---

## 7. 实施计划

### 7.1 阶段一：后端基础架构（2-3周）
1. 搭建FastAPI项目结构
2. 配置PostgreSQL + PostGIS数据库
3. 实现数据模型和迁移
4. 实现基础API（保单、理赔、统计、风险、天气）

### 7.2 阶段二：计算引擎和定时任务（2-3周）
1. 实现风险计算引擎（复用前端逻辑）
2. 实现理赔计算引擎（tier差额逻辑）
3. 实现天气数据计算引擎
4. 实现Celery定时任务（风险事件计算、理赔计算、天气同步）

### 7.3 阶段三：前端集成（2-3周）
1. 实现API客户端
2. 实现保单统计和理赔统计组件
3. 集成到现有Dashboard
4. 实现数据面板联动

### 7.4 阶段四：AI Agent集成（2-3周）
1. 搭建Google ADK Agent架构
2. 实现Chat Agent和Orchestrator Agent
3. 实现专业团队Agent（Product、Claim、Policy）
4. 实现Function Calling机制，集成后端业务服务
5. 集成到ContextualAssistant组件

### 7.5 阶段五：动画效果和天气扩展（2-3周）
1. 实现粒子效果系统（降雨、风速）
2. 支持风速数据可视化
3. 实现台风气旋和轨迹（未来扩展）
4. 性能优化

### 7.6 阶段六：测试和优化（1-2周）
1. 端到端测试
2. 性能优化
3. 文档完善
4. 部署准备

---

## 8. 技术风险和注意事项

### 8.1 金融计算精度
- **风险**：使用float可能导致精度误差
- **解决方案**：使用Python `decimal.Decimal` 和 PostgreSQL `DECIMAL` 类型

### 8.2 定时任务可靠性
- **风险**：Celery任务可能失败或重复执行
- **解决方案**：
  - 实现任务幂等性
  - 添加任务重试机制
  - 监控任务执行状态

### 8.3 数据一致性
- **风险**：理赔计算依赖风险事件，需要保证数据一致性
- **解决方案**：
  - 使用数据库事务
  - 实现数据版本控制
  - 添加数据校验

### 8.4 性能优化
- **风险**：大量保单和理赔数据可能导致查询慢
- **解决方案**：
  - 添加数据库索引
  - 使用Redis缓存
  - 实现数据分页
  - 考虑数据分区（按时间）

### 8.5 AI Agent稳定性
- **风险**：Agent可能返回错误结果
- **解决方案**：
  - 实现结果验证
  - 添加错误处理
  - 提供fallback机制
  - 通过Function Calling确保业务逻辑的一致性

---

## 9. 后续扩展方向

1. **用户认证系统**：支持多租户、角色权限管理
2. **实时通知**：理赔生成后通知投保人（邮件、短信）
3. **数据导入导出**：支持CSV/Excel批量导入保单
4. **报表系统**：生成保单和理赔报表
5. **移动端应用**：React Native应用
6. **更多天气类型**：温度、湿度、气压等
7. **台风预测**：集成台风轨迹预测API
8. **机器学习**：使用ML模型优化风险预测

---

**文档版本**：v2.0  
**创建日期**：2025-01-27  
**最后更新**：2025-01-27
