# v2 迁移分层矩阵（v1 → v2）

> 目的：在规划 `v2项目总览 / v2实现步骤总览 / v2实现细则` 时，把 v1 已实现资产的去向说清楚：哪些能复用、哪些要重构、哪些逻辑正确但必须后端重写、哪些应废弃。  
> 本文档仅用于“迁移判定与拆解导航”，**v2 的真源口径**仍以：  
> - `docs/v2/v2需求分析.md`  
> - `docs/v2/v2页面设计提案.md`  
> - `docs/v2/v2架构升级-全栈方案.md`  
> 为准。

---

## 0. 迁移分类（必须统一）

### 0.1 Reuse Type（复用类型）
- **R0 直接复用**：代码/组件几乎不动（只做少量适配：目录/依赖/样式/配置）
- **R1 复用但重构**：核心思路/部分代码可用，但需要适配 v2 架构（Next.js、TanStack Query、Zustand、数据产品化、Mode/批次）
- **R2 逻辑复用但后端重写**：算法/规则/口径正确，但必须迁到后端（服务/计算引擎/任务/持久化），前端只消费结果
- **R3 不复用（废弃/归档）**：v1 假设与 v2 冲突或会误导，应删除或仅保留为历史参考

### 0.2 Target Home（落点）
- **FE**：前端（Next.js + React）
- **BE**：后端（FastAPI + Postgres/PostGIS + Redis + Celery）
- **Shared Contract**：跨层契约（请求维度/输出 schema/枚举/口径说明/缓存 key 维度）
- **Infra/Governance**：缓存、观测、合规 gate、发布治理

### 0.3 Acceptance Anchor（验收锚点）
每条迁移项必须绑定至少一个验收锚点（来自 v2 需求分析）：
- **Data Product**：L0 / L1 / L2 / Overlays / AI Insights
- **Access Mode**：Demo/Public、Partner、Admin/Internal
- **Prediction Run**：prediction_run_id / active_run（一致性与回滚）
- **Perf/SLO**：p95、hover 0 重请求、节流边界
- **Security/Compliance**：后端强裁剪、Google Maps 合规与成本监控
- **Observability**：trace_id/correlation_id、active_run 审计

---

## 1. 迁移矩阵总表（v1 资产 → v2 去向）

> 说明：v1 资产名称来源于 `docs/v1/00-项目总览.md` 中的模块/目录描述（如 Next-gen-index 的 components/hooks/lib）。  
> 下面不要求后续 agent 去引用 v1 文档本身；**只把“可复用结论”写进 v2 规划与细则**。

| v1 资产（模块/能力） | v2 目标能力 | Reuse Type | Target Home | 迁移说明（关键约束） | 绑定验收锚点 |
|---|---|---:|---|---|---|
| 地图集成（Google Maps 初始化、容器、基础交互） | Map Stage 主舞台 | R1 | FE | API 加载方式/Map ID/marker/layer 选择需要按 v2 合规与性能方案重整；保留“地图主舞台优先”的交互原则 | Overlays、Perf/SLO、Compliance |
| 行政边界渲染（GeoJSON + Polygon/DataLayer） | Region Boundary + hover/click lock | R1 | FE + Shared Contract | 复用“边界数据驱动交互”的思路；需统一 region_code/region_scope 并与后端一致；hover 必须 0 明细重请求 | L0/L1、Perf/SLO、Shared Contract |
| 天气热力/可视化图层（历史/预测分层） | Weather Layer（historical/predicted） | R1 | FE + BE | v1 偏前端生成与渲染；v2 必须由后端提供可复用数据产品输出；前端只渲染聚合/图例 | Overlays、Prediction Run、Perf/SLO |
| 风险事件标记图层（历史/预测） | Risk Layer（与产品规则绑定） | R1 | FE + BE | v1 计算风险事件在前端；v2 风险事件必须后端计算、持久化；前端仅展示聚合/标记 | L1/L2、Prediction Run、Perf/SLO |
| Claims/理赔叠加（若 v1 仅展示概念） | Claims Overlay（Mode-aware） | R2 | BE + FE | v2 claims 为正式记录（历史数据生成）；Demo 模式仅聚合/弱化，严禁前端隐藏代替权限 | Access Mode、Security、L1/L2 |
| 产品选择器（ProductSelector） | Product Selector（随 weather_type 过滤、单选） | R1 | FE + BE | v2 products 来自后端产品表；前端只展示与选择；需与 weather_type/product_id 契约对齐 | L1/Overlays、Shared Contract |
| 产品库（productLibrary / products.ts） | products 表 + 产品服务（riskRules+payoutRules） | R2 | BE + Shared Contract | v1 产品配置结构可复用为 JSONB；必须落到 DB/服务，支撑版本化/is_active；前端仅消费 | Data Product、Security、Observability |
| 风险计算引擎（riskCalculationEngine / service） | Risk Calculator（后端计算 + Celery） | R2 | BE | 逻辑可复用，但必须异步化/幂等/可回放；禁止在 FastAPI async 路由直接跑重计算 | L1/L2、Perf/SLO、Reliability |
| 天气数据生成器（mock 生成） | Weather 数据层（MVP 可 mock/导入） | R2 | BE | 可复用“确定性生成/补齐”的规则，但落到后端；并设计未来接入真实数据的接口边界 | Data Product、Perf/SLO |
| 扩展数据获取（用于 rolling window 起点计算） | 计算输入数据准备（Compute input prep） | R2 | BE | v1 解决了“窗口起点缺数据导致曲线不准”的问题；v2 需在后端计算输入中固化并测试 | L1 Timeline、Correctness |
| 中心化 Hook（useRiskAnalysis） | v2 UI Orchestration + 数据产品消费 | R1 | FE | v2 不再让 FE 成为计算事实源；但可复用“单一事实来源/统一入口”的架构思想：Zustand + TanStack Query | L0/L1/L2、Perf/SLO |
| DataDashboard（图表/时间线） | Region Intelligence Panel（Overview/Timeline/Details） | R1 | FE | UI 组件可重构复用思路；数据来源需改为数据产品 API；Details 必须 Mode-aware | L1/L2、Access Mode |
| AI 对话面板（ContextualAssistant） | AI 聊天窗（必须保留） + AI Insight Cards（导演式联动） | R1 | FE + BE | v2 必须保留聊天窗作为稳定交互入口；同时主线是“导演式联动（CTA+UI Intent）”。两者并存：聊天用于表达需求/解释补充，洞察卡用于驱动 UI 行为与叙事节奏；所有输出与动作必须 Mode-aware | AI Insights、Access Mode、Observability |
| GPS 定位 + 反向地理编码/行政区解析 | GPS 定位（必须保留） + 坐标→行政区解析闭环 | R1 | FE + BE | v2 必须保留定位与解析链路：获取坐标→反向解析→映射到 region_code/region_scope→驱动 Map lock 与 L0/L1/L2 数据产品刷新；仍需节流/限流/失败降级，并遵守 Google Maps 条款（成本与合规 gate） | L0/L1、Compliance、Perf/SLO、Shared Contract |
| “全球范围任意区域”假设 | 可配置国家集（先支持已有边界数据） | R3 | Governance | v1 的“全球任意区域”易误导；v2 改为“国家集可配置，逐步扩展” | Scope/Non-goals |
| “仅产品级风险，不做理赔”假设 | 全栈闭环（policies+claims） | R3 | Governance | v2 明确要做 claims（历史生成）与 Mode 裁剪；v1 假设需从 v2 文档中彻底清理 | Scope、Access Mode |

---

## 2. 关键迁移项的“拆解落点”说明（给后续细则用）

### 2.1 R2（逻辑复用但后端重写）的统一落地规则
- **规则 1**：v1 的算法/规则只能作为“逻辑参考”，v2 必须在 BE 实现并可测试（单元 + 边界 + 幂等）。
- **规则 2**：任何 predicted 相关输出必须携带 `prediction_run_id`（或由 `active_run` 解析），缓存必须与批次绑定失效。
- **规则 3**：任何 Mode 相关裁剪必须在 BE 执行，前端仅做呈现与“不可用提示”。

### 2.2 R1（复用但重构）的统一重构方向
- **状态与数据**：从“中心化 Hook 计算”转为 “Zustand 管 UI/会话/模式 + TanStack Query 管数据产品请求”。
- **联动边界**：hover 轻交互（0 重请求）；click/CTA 重交互才允许触发 L1/L2。

---

## 3. 使用说明（如何在后续文档中引用本矩阵）

### 3.1 在 `v2项目总览` 中的用法
- 给每个“能力/模块”标注：Reuse Type（R0-R3）+ Target Home（FE/BE/Shared/Infra）+ 绑定验收锚点。

### 3.2 在 `v2实现步骤总览` 中的用法
- 每一步必须说明：该步交付哪些验收锚点、包含哪些 R2 后端重写项、是否触发 predicted/mode 的强约束。

### 3.3 在 `v2实现细则` 中的用法
- 每个模块细则开头必须写：本模块在矩阵中的分类（R0-R3），以及“不可复用/必须后端实现”的红线。
- **R0/R1 强制流程**：在撰写该模块的 `v2实施细则` 前，必须先产出该模块的 **Reuse Digest（复用逻辑摘录）**，用于承接 v1 可复用逻辑并完成 v2 化（维度/Mode/批次/验收）。
  - 目录约定：`docs/v2/v2复用逻辑摘录/RD-<模块名>.md`
  - 禁止：在 `v2实施细则` 中直接引用 v1 文档路径/段落作为依据（避免污染）。如需追溯，仅在 Reuse Digest 内部记录来源线索，并以 v2 统一语言重述为准。

---

**文档版本**：v2.0  
**创建日期**：2026-01-15  
**最后更新**：2026-01-15  

