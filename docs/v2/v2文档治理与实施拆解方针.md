# v2 文档治理与实施拆解方针（给后续 Agent 使用）

> 目的：把“如何把 v2 做成整全集（而不是增量 patch）”固化为可执行方针，让后续其他 agent 能稳定地产出：  
> - `v2项目总览`  
> - `v2实现步骤总览`  
> - `v2分模块/分文件实施细则`  
> 同时把 v1 已实现资产的复用与重写说清楚，避免口径漂移与误导。

---

## 0. 总原则（必须遵守）

### 0.1 v2 的“唯一真源”（Single Source of Truth）
v2 的口径与约束以以下文档为准：
- `docs/v2/v2需求分析.md`
- `docs/v2/v2页面设计提案.md`
- `docs/v2/v2架构升级-全栈方案.md`

### 0.2 v1 文档的定位
- `docs/v2/` 下**非 `v2` 开头**的业务/方案文档均视为 v1 时代资料，可能过时或误导。
- 例外：`docs/v2/TEMPLATE-*.md` 属于 v2 文档模板资产，可用于生成 v2 文档（不承载业务口径真源）。
- 任何 v2 规划与实施文档 **不得引用**这些旧文档作为真源。
- v1 资产只允许通过 `docs/v2/v2迁移分层矩阵.md` 以“复用结论”的形式进入 v2 规划。

> 补充约束：允许阅读 `docs/v1/` 的实施细则作为“输入材料”，但 **禁止**在 v2 文档中直接引用 v1 文档路径/段落作为依据（避免污染）。所有可复用逻辑必须先经过“复用逻辑摘录（Reuse Digest）”流程 v2 化后，才能进入 `v2实施细则`。

### 0.3 统一语言（禁止混用）
后续所有文档、任务拆解、接口讨论必须统一以下概念：
- **L0/L1/L2**：省级态势 / 区域情报 / 证据链
- **Access Mode**：Demo/Public、Partner、Admin/Internal（跨层契约）
- **Data Type**：historical / predicted
- **Prediction Run**：prediction_run_id / active_run（predicted 一致性与回滚）
- **Data Product**：L0/L1/L2/Overlays/AI Insights（可交付对象）

---

## 1. “迁移分层矩阵”的用法（必须先做，再拆解）

### 1.1 迁移分类（R0-R3）
后续拆解时，任何模块/能力都必须标注：
- **R0**：直接复用
- **R1**：复用但重构（适配 Vite + TanStack Query + Zustand + 数据产品）
- **R2**：逻辑复用但后端重写（产品库、风险事件、计算逻辑、预测批次、Mode 裁剪）
- **R3**：不复用（废弃/归档，避免 v1 假设污染 v2）

### 1.2 每条迁移项必须绑定“验收锚点”
至少绑定一项：
- Data Product（L0/L1/L2/Overlays/AI）
- Access Mode（强裁剪）
- Prediction Run（一致性/回滚）
- Perf/SLO（hover 0 重请求、p95 目标）
- Compliance（Google Maps 合规 + 成本/配额）
- Observability（trace + 审计）

### 1.3 复用逻辑摘录（Reuse Digest）是强制步骤（按模块拆分）
> 目标：既不丢 v1 的可复用逻辑与要求，又不把 v1 的隐含前提带入 v2。

硬规则：
- **R0/R1 模块必须先产出 Reuse Digest**，再写 v2 的“实施细则”（Implementation Spec）。
- Reuse Digest 必须用 v2 统一语言重述：L0/L1/L2、Access Mode、Data Type、Prediction Run、Data Product、输入维度与缓存 key 维度。
- Reuse Digest 必须包含“验收 + 反例”，否则视为不可用材料。

文件组织：
- Reuse Digest（复用逻辑摘录）统一放在：`docs/v2/v2复用逻辑摘录/`，**分不同文件**，按名称区分：
  - `docs/v2/v2复用逻辑摘录/RD-<模块名>.md`
- Implementation Spec（v2 实施细则）统一放在：`docs/v2/v2实施细则/`，并且必须按 `v2项目总览` / `v2实现步骤总览` 的实施顺序进行**编号**（用于表达依赖与执行顺序）：
  - `docs/v2/v2实施细则/<编号>-<模块名>-细则.md`

---

## 2. 文档产出顺序（推荐）

### 2.1 先产出：`v2项目总览`
目标：把 v2 “是什么”说清楚，输出可供任何 agent/开发者理解的地图。

模板：`docs/v2/TEMPLATE-v2项目总览.md`（后续生成 `docs/v2/v2项目总览.md` 时应先复制该模板再填充）。

必须包含：
- **能力地图（Capability Map）**：按 L0/L1/L2 + Map + AI + Access Mode + Prediction Run
- **数据产品清单（Data Product Catalog）**：每个数据产品的输入维度/输出形态/Mode 影响/预测批次要求（可直接复用 v2需求分析中的表格）
- **迁移摘要**：引用 `v2迁移分层矩阵`，列出 R0/R1/R2/R3 的分布与优先级

禁止包含：
- 任何 v1 文档链接或 v1 时代“默认假设”（例如“全球任意区域”“只做前端 mock”“不做 claims”）

### 2.2 再产出：`v2实现步骤总览`
目标：把 v2 “怎么交付”拆成可以并行推进的里程碑与泳道。

模板：`docs/v2/TEMPLATE-v2实现步骤总览.md`（后续生成 `docs/v2/v2实现步骤总览.md` 时应先复制该模板再填充）。

推荐泳道：
- **Shared Contract**：维度/枚举/输出 schema/缓存 key 维度/Mode 裁剪规则
- **Backend**：products/policies/risk_events/claims/prediction_runs + 缓存/任务/幂等
- **Frontend**：Map Stage + L0/L1/L2 Orchestration + Insights CTA
- **Governance**：合规 gate、观测、发布治理（Mode 默认与审计）

关键硬规则：
- Hover 不触发重请求写进步骤验收（否则联动风暴）
- predicted 必须绑定 prediction_run_id/active_run（否则解释断裂）
- Mode 裁剪必须由 BE 执行（前端隐藏不算）

### 2.3 最后产出：`v2分模块/分文件实施细则`
目标：把每个模块变成“可直接开工的任务包 + 可验收标准”。

在写每个模块实施细则前，必须先完成：
- 该模块在 `v2迁移分层矩阵` 中的 R0-R3 分类与验收锚点绑定
- 该模块的 `Reuse Digest`（R0/R1 必须；R2 强烈建议）

---

## 3. 模块实施细则模板（后续 Agent 必须照抄结构）

> 每个模块（例如：产品库、风险事件计算、L1 时间轴数据产品、Overlays 服务、AI 洞察卡）必须用同一模板，才能保证拆解可拼装、可审计。

### 3.1 模板
- **模块名称**
- **目标 / 非目标**
- **关联的数据产品（Data Product）**：L0/L1/L2/Overlays/AI 中的哪一项
- **输入维度（最小集合）**：region_scope/region_code/time_range/data_type/weather_type/product_id/access_mode/prediction_run_id
- **输出形态**：聚合/时间序列/明细/legend 元信息
- **Mode 规则**（必须写）：Demo/Partner/Admin 下哪些字段隐藏/范围化/脱敏
- **predicted 规则**（必须写）：prediction_run_id/active_run 如何传递、缓存如何失效、回滚怎么做
- **性能与缓存策略**：cache key 维度、p95 目标、节流边界（hover/brush）
- **可观测性**：trace_id/correlation_id、必须打点/日志字段、active_run 审计字段
- **复用声明（必须写清楚）**
  - Reuse Digest（必填引用）：`docs/v2/v2复用逻辑摘录/RD-<模块名>.md`
  - 来自 v1 的可复用资产（R0/R1）：迁移注意点（以 Reuse Digest 为准，禁止直接引用 v1 文档）
  - 来自 v1 的可复用逻辑（R2）：后端重写边界与幂等/回放/测试要求（以 Reuse Digest 为准）
  - 不复用内容（R3）：明确删掉或归档
- **验收用例（可勾选）**：功能/一致性/Mode/批次/性能/合规
- **风险与回滚策略**

---

## 4. 两个“最常见失败模式”（必须写进每个模块）

### 4.1 失败模式 A：前端隐藏当权限
症状：Demo/Public 仍能通过 API 拿到明细或敏感口径。  
硬规则：**BE 强裁剪** + 一致越权响应 + 审计。

### 4.2 失败模式 B：predicted 混批次
症状：UI/AI 使用了不同批次的数据，解释断裂；缓存命中但口径错。  
硬规则：prediction_run_id/active_run 全链路一致；cache key 必含批次；支持回滚（切 active_run）。

---

## 5. 交付与验收的“门槛化”表达（推荐写法）

在每个阶段/模块文档里，用“Go/No-Go”门槛表达，避免“做完了但不可演示/不可验收”：
- **功能闭环**：L0 → 锁区 → L1 Timeline →（按 Mode）L2
- **一致性闭环**：同一筛选条件下 L0/L1/L2 不矛盾；predicted 不混批次
- **安全闭环**：Demo/Public 下无法拿到敏感明细（可验证）
- **性能闭环**：hover 0 重请求；地图主舞台不掉帧
- **合规闭环**：Google Maps key 限制 + 预算/告警 + attribution 与缓存条款满足

---

**文档版本**：v2.0  
**创建日期**：2026-01-15  
**最后更新**：2026-01-15  

