# 全栈架构升级方案

**文档版本**：v2.0  
**创建日期**：2025-01-27  
**最后更新**：2025-01-27  
**目标**：将纯前端应用升级为全栈应用，支持保单管理、理赔计算、统计展示和AI Agent集成

---

## 1. 架构总览

### 1.1 架构模式
采用**前后端分离**的微服务架构，支持水平扩展和模块化开发。

```
┌─────────────────────────────────────────────────────────────┐
│                        前端层 (Frontend)                      │
│  Next.js (App Router) + React 19 + TypeScript + Tailwind CSS │
│  - 地图可视化（Google Maps + 粒子效果）                       │
│  - 数据面板（统计、图表）                                     │
│  - AI对话界面（Google Contextual View）                      │
└─────────────────────────────────────────────────────────────┘
                            ↕ HTTP/WebSocket
┌─────────────────────────────────────────────────────────────┐
│                      API网关层 (API Gateway)                  │
│  FastAPI (Python) - 统一入口、认证、限流                      │
└─────────────────────────────────────────────────────────────┘
                            ↕
        ┌───────────────────┼───────────────────┐
        ↓                   ↓                   ↓
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│  业务服务层   │  │  计算服务层   │  │  AI Agent层   │
│  (Services)  │  │  (Compute)   │  │  (Agents)    │
│              │  │              │  │              │
│ - 保单服务   │  │ - 风险计算   │  │ - Chat Agent │
│ - 理赔服务   │  │ - 理赔计算   │  │ - Orchestrator│
│ - 风险服务   │  │ - 天气计算   │  │ - 专业团队   │
│ - 统计服务   │  │              │  │              │
│ - 天气服务   │  │              │  │              │
└──────────────┘  └──────────────┘  └──────────────┘
        ↓                   ↓                   ↓
┌─────────────────────────────────────────────────────────────┐
│                      数据层 (Data Layer)                      │
│  PostgreSQL + PostGIS (地理空间数据)                          │
│  Redis (缓存)                                                │
│  Celery + Redis (任务队列)                                   │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 技术栈选型

#### 前端技术栈（V2 Fullstack 对齐）
- **框架**：Next.js（App Router）+ React 19 + TypeScript
- **渲染形态**：SSR/SSG/CSR 按页面与数据敏感性分层（默认以 CSR 交互为主，SSR 用于首屏与鉴权/路由一致性）
- **样式**：Tailwind CSS
- **状态与数据获取**：Zustand（UI/会话/模式） + TanStack Query（Server State）
- **动画与可视化**：Framer Motion + deck.gl（粒子/图层）
- **地图**：Google Maps JavaScript API
- **AI界面**：Google Contextual View AI kit
- **图表**：Recharts

#### 后端技术栈（新增）
- **框架**：FastAPI (Python 3.10+)
- **数据库**：PostgreSQL 15+ + PostGIS 3.3+
- **缓存**：Redis 7+
- **任务队列**：Celery 5.3+ + Redis
- **ORM**：SQLAlchemy 2.0+ + GeoAlchemy2
- **数据验证**：Pydantic 2.0+
- **AI Agent**：Google ADK (Agent Development Kit)

#### 基础设施
- **容器化**：Docker + Docker Compose
- **部署**：支持云部署（GCP/AWS/Azure）
- **监控**：Prometheus + Grafana（可选）

---

## 2. 数据库设计

### 2.1 核心表结构

#### 2.1.1 产品表 (products)
产品表用于存储**保险产品配置**，是风险计算（`riskRules`）与理赔计算（`payoutRules`）的权威来源。

> 说明：产品配置包含两层：`riskRules`（用于风险事件计算与可视化）与 `payoutRules`（用于 v2 理赔计算；不参与风险事件计算）。  
> MVP 阶段可采用“静态配置 + 启动时 seed 导入数据库”的方式；后续再演进为后台可编辑与版本化发布。

**关键字段（建议）**：
- `id`：产品ID（主键，例如 `daily` / `weekly` / `drought`）
- `name`：产品名称
- `type`：产品类型（daily/weekly/monthly…）
- `weather_type`：天气类型（如 rainfall/wind/temperature…；与 `risk_events.weather_type` 保持一致）
- `description`：产品描述（可用于前端展示）
- `icon`：产品图标标识（前端使用）
- `risk_rules`：产品级风险事件触发规则（JSONB，对应 `riskRules`）
  - 包含：时间窗口（hourly/daily/weekly/monthly）、阈值 tiers、聚合方式与比较运算符、单位等
- `payout_rules`：保单级赔付规则（JSONB，对应 `payoutRules`）
  - 包含：赔付频率限制（如 once per day per policy）、各 tier 赔付比例（tier1/2/3）、总赔付上限等
- `is_active`：是否启用（用于灰度/下线）
- `version`：产品配置版本（用于演进与回溯；建议预留）
- `created_at/updated_at`：审计字段

**索引策略（建议）**：
- 按 `weather_type`、`type`、`is_active` 建立索引，支持前端按天气类型过滤可选产品

#### 2.1.2 保单表 (policies)
存储保单基本信息，包括保单号、保障计划、投保人信息、保障区域、保障期限和保额。

**关键字段**：
- `policy_number`：保单号（唯一标识）
- `product_id`：保障计划ID（外键关联 `products.id`）
- `coverage_region`：被保区域（JSONB格式，包含country、province、district）
- `coverage_start/end`：保障起止时间（TIMESTAMPTZ，存储UTC时间）
- `coverage_amount`：保额（DECIMAL类型，避免浮点误差）
- `timezone`：时区信息（如"Asia/Shanghai"、"America/New_York"）
  - **用途**：用于将UTC时间转换为风险发生地的当地时间
  - **重要性**：保险业务对时间敏感，"每天赔付一次"的"天"必须基于风险发生地的当地时间，而非UTC时间
  - **示例**：如果保单覆盖区域在Asia/Shanghai时区，则"per day"限制应基于北京时间（UTC+8）的0点，而非UTC的0点

**索引策略**：
- 按产品ID、保障日期范围、区域建立索引，优化查询性能

#### 2.1.3 理赔单表 (claims)
存储理赔单信息，关联保单和风险事件，记录理赔金额和tier级别。

**关键字段**：
- `policy_id`：关联保单（外键）
- `risk_event_id`：关联风险事件（可选）
- `tier_level`：风险级别（tier1/tier2/tier3）
- `payout_percentage`：赔付百分比（如2.00, 8.00）
- `payout_amount`：理赔金额（DECIMAL类型）
- `trigger_timestamp`：触发时间

**索引策略**：
- 按保单ID、触发时间、状态、tier级别建立索引

#### 2.1.4 风险事件表 (risk_events)
持久化风险事件计算结果，用于理赔计算和历史查询。

**关键字段**：
- `product_id`：产品ID（外键关联 `products.id`）
- `region`：区域信息（JSONB）
- `timestamp`：事件时间
- `data_type`：数据类型（historical/predicted）
- `weather_type`：天气类型（rainfall/wind/temperature等）
- `tier_level`：风险级别
- `trigger_value`：触发时的累计值
- `threshold_value`：触发的阈值
- `prediction_run_id`：预测批次ID（仅对 `data_type='predicted'` 有意义；用于避免“混批次/口径断裂”）
  - **用途**：对齐 `docs/v2/v2技术方案.md` 的“预测数据版本化（active_run + 回滚）”要求
  - **历史数据**：`data_type='historical'` 时该字段应为 NULL（历史为单一真值，不做版本化）
  - **预测数据**：每次预测刷新（同步/重算）生成新的 `prediction_run_id`，用于：
    - 前端/后端/AI 在同一请求链路中显式携带并保持一致
    - 缓存 key 与批次绑定失效，避免新旧预测混用
    - 支持“切换 active_run”实现回滚（而不是覆盖历史预测）

**唯一约束（建议）**：
- historical：同一产品、区域、时间、天气类型、tier级别只能有一条记录
- predicted：同一产品、区域、时间、天气类型、tier级别、prediction_run_id 只能有一条记录

**数据流差异**：
- **历史风险事件**：数据不可变，一旦计算完成即固定
- **预测风险事件**：数据易变，每次预测数据更新时重新计算
  - **禁止策略：直接覆盖旧预测**（会导致审计困难、缓存混杂、解释断裂）
  - **推荐策略：批次版本化 + active_run 切换**（见下表 `prediction_runs`）

#### 2.1.6 预测批次表 (prediction_runs)
用于承载 predicted 数据的**批次元信息**与 **active_run 切换/回滚**能力，避免在 `risk_events` 上通过“全量更新 is_active”实现切换。

**关键字段（建议）**：
- `id`：预测批次ID（主键，对应 `risk_events.prediction_run_id`）
- `status`：状态（active/archived/failed…；至少需要能表达 active）
- `created_at`：批次创建时间（TIMESTAMPTZ，UTC）
- `source`：来源（如 external_sync / manual_backfill / rerun）
- `note`：备注（可选，用于解释“为什么切换批次/回滚”）

**约束（建议）**：
- 保证同一维度下仅有一个 active_run（维度范围取决于业务：可先按“全局单一 active_run”做 MVP；未来再扩展到按 weather_type / product / region_scope）

#### 2.1.5 历史天气数据表 (historical_weather_data)
存储历史天气数据，支持多种天气类型。

**关键字段**：
- `region`：区域信息（JSONB）
- `timestamp`：时间戳
- `weather_type`：天气类型
- `value`：数值（DECIMAL类型）
- `unit`：单位（mm/kmh/celsius等）
- `data_source`：数据来源（mock/api/manual）

**唯一约束**：同一区域、时间、天气类型只能有一条记录

### 2.2 数据关系图

```
products (产品)
    ├── policies (保单) [1:N]
    └── risk_events (风险事件) [1:N]

prediction_runs (预测批次)
    └── risk_events (风险事件, predicted only) [1:N]

policies (保单)
    ├── claims (理赔单) [1:N]
    └── risk_events (风险事件) [间接关联，通过product_id和region]

claims (理赔单)
    ├── policies (保单) [N:1，外键关联]
    └── risk_events (风险事件) [可选关联，通过risk_event_id]

risk_events (风险事件)
    ├── historical_weather_data (历史天气数据) [间接关联，通过region和timestamp]
    └── claims (理赔单) [可选关联，通过risk_event_id]

historical_weather_data (历史天气数据)
    └── risk_events (风险事件) [间接关联]
```

### 2.3 数据迁移策略

1. **初始数据导入**：使用 Alembic 管理数据库迁移
2. **Mock数据生成**：提供数据生成脚本，支持批量导入
3. **数据备份**：定期备份策略（建议每日）

---

## 3. 后端服务设计

### 3.1 服务架构概览

```
backend/
├── app/
│   ├── api/                    # API路由层
│   │   └── v1/                 # API版本管理
│   │       ├── products.py     # 产品API（产品配置/可用产品列表）
│   │       ├── policies.py     # 保单API
│   │       ├── claims.py        # 理赔API
│   │       ├── statistics.py   # 统计API
│   │       ├── weather.py      # 天气数据API
│   │       ├── risk_events.py  # 风险事件API
│   │       └── agents.py       # AI Agent API
│   │
│   ├── services/               # 业务逻辑层
│   │   ├── product_service.py  # 产品服务（产品配置读取/版本/启用状态）
│   │   ├── policy_service.py   # 保单服务
│   │   ├── claim_service.py    # 理赔服务
│   │   ├── risk_service.py     # 风险服务
│   │   ├── statistics_service.py # 统计服务
│   │   └── weather_service.py  # 天气数据服务
│   │
│   ├── compute/                 # 计算引擎层
│   │   ├── risk_calculator.py  # 风险计算引擎
│   │   ├── claim_calculator.py  # 理赔计算引擎
│   │   └── weather_calculator.py # 天气数据计算
│   │
│   ├── agents/                 # AI Agent层
│   │   ├── router_agent.py     # Router Agent（合并原Chat+Orchestrator）
│   │   ├── modality_adapters/   # 模态适配层
│   │   │   ├── __init__.py
│   │   │   ├── base.py          # 基础适配器接口
│   │   │   ├── text_adapter.py  # 文本适配器
│   │   │   └── voice_adapter.py # 语音适配器（VAD/STT/TTS）
│   │   └── expertise_agents/    # 专业团队Agent
│   │       ├── product_expertise_agent.py
│   │       ├── risk_claim_expertise_agent.py
│   │       └── policy_expertise_agent.py
│   │
│   ├── tasks/                   # Celery任务
│   │   ├── risk_event_calculation.py # 风险事件计算任务
│   │   ├── claim_calculation.py # 理赔计算任务
│   │   └── weather_sync.py     # 天气数据同步任务
│   │
│   ├── models/                  # 数据模型（SQLAlchemy）
│   │   ├── product.py
│   │   ├── policy.py
│   │   ├── claim.py
│   │   ├── risk_event.py
│   │   └── weather_data.py
│   │
│   ├── async_utils/              # 异步工具（新增）
│   │   ├── __init__.py
│   │   └── executor.py           # 线程池/进程池执行器（用于run_in_executor）
│   │
│   └── utils/                   # 工具函数
│       ├── __init__.py
│       ├── decimal_utils.py    # Decimal工具（金融计算）
│       ├── time_utils.py        # 时间处理（包含时区转换）
│       └── region_utils.py     # 区域处理
```

### 3.2 业务服务层详细说明

#### 3.2.1 产品服务 (Product Service)
**职责**：管理产品配置的读取、版本与启用状态，为风险计算与理赔计算提供权威产品规则。

**核心功能**：
- **产品查询**：按 `id` 查询产品；按 `weather_type` 与 `type` 过滤可用产品列表
- **版本与启用**：支持 `is_active` 与 `version`（用于灰度与回溯；MVP 可只读）
- **规则下发**：
  - 向风险计算引擎提供 `riskRules`
  - 向理赔计算引擎提供 `payoutRules`

**数据访问**：
- 直接操作 `products` 表（读取为主；MVP 阶段可通过 seed 导入）

#### 3.2.2 保单服务 (Policy Service)
**职责**：管理保单的完整生命周期

**核心功能**：
- **保单CRUD**：创建、查询、更新、删除保单
- **保单查询**：支持多维度查询（按产品、区域、时间范围、投保人等）
- **保单验证**：验证保单数据的完整性和合法性（如保障日期、区域有效性）
- **保单统计**：按产品、区域、时间范围统计保单数量和保额
- **产品关联**：获取保单关联的产品配置信息

**数据访问**：
- 直接操作 `policies` 表
- 通过产品ID关联产品配置

#### 3.2.3 理赔服务 (Claim Service)
**职责**：管理理赔单的完整生命周期

**核心功能**：
- **理赔单创建**：创建理赔单记录（主要供理赔计算引擎调用）
  - 验证理赔单数据的完整性和合法性
  - 生成理赔单号
  - 关联保单和风险事件
- **理赔查询**：支持多维度查询（按保单、区域、时间范围、tier级别等）
- **理赔统计**：按产品、区域、时间范围统计理赔数量和理赔额
- **理赔关联**：关联保单和风险事件信息
- **理赔状态管理**：管理理赔单状态（generated/approved/rejected）
- **理赔单更新**：更新理赔单信息（如状态变更）

**数据访问**：
- 直接操作 `claims` 表（创建、查询、更新）
- 关联查询 `policies` 和 `risk_events` 表

#### 3.2.4 风险服务 (Risk Service)
**职责**：管理风险事件的完整生命周期

**核心功能**：
- **风险事件创建**：创建风险事件记录（主要供风险计算引擎调用）
  - 验证风险事件数据的完整性和合法性
  - 检查唯一性约束（避免重复创建）
  - 关联产品、区域和天气数据
- **风险事件查询**：支持多维度查询（按产品、区域、时间范围、天气类型、tier级别等）
- **风险事件统计**：按产品、区域、时间范围统计风险事件数量和分布
- **风险事件关联**：关联天气数据和产品配置
- **风险事件批量创建**：批量创建风险事件（提高性能）

**数据访问**：
- 直接操作 `risk_events` 表（创建、查询）
- 关联查询 `historical_weather_data` 表

#### 3.2.5 统计服务 (Statistics Service)
**职责**：提供聚合统计和数据分析功能

**核心功能**：
- **面向大屏的信息分层（L0/L1/L2）**：
  - **L0 省级态势（全局背书）**：KPI + Top 排名（Policies/Claims/Combined），强调“10 秒内一眼看到态势”
  - 说明：v2 页面已将 L0 从“侧栏”调整为 “Left HUD Rail（Search 下方，HUD 化）”，以“金额 KPI + Top 导航（Pareto）+ sparkline 提示 + AI Insight”构成最小背书与导航入口
  - **L1 区域态势（选中区域）**：概览 + 趋势 + 风险/理赔/天气的统一时间轴（为“可解释”服务）
  - **L2 证据链（明细溯源）**：风险事件 ↔ 理赔信息的关联视图（为“可追溯”服务）
- **访问模式（Mode）驱动的数据口径**：
  - 同一套信息架构不推倒重来，但返回数据的**粒度、字段、默认展开能力**随 Mode（Demo/Public、Partner、Admin/Internal）变化
  - 统计服务需要支持“字段级脱敏 / 聚合摘要 / 隐藏敏感口径”等输出策略（由权限系统或 Feature Flags 驱动）
- **保单统计**：
  - 按产品、区域、时间范围统计保单数量和保额
  - 支持时间区间与保单保障期的交集计算
  - 支持地图级别（省份）和数据面板级别（district）的统计
- **理赔统计**：
  - 按产品、区域、时间范围统计理赔数量和理赔额
  - 支持时间趋势分析（时间序列数据）
  - 与风险事件图表对应
- **风险统计**：
  - 按产品、区域、时间范围统计风险事件数量和分布
  - 支持按tier级别分组统计
- **综合统计**：
  - 保单与理赔的关联分析
  - 风险与理赔的关联分析
- **地图叠加层的聚合能力（可视化友好）**：
  - 为 Map Stage 提供“可直接渲染”的聚合结果（例如区域级聚合、网格/Hex 聚合等），避免前端对海量明细做二次聚合
  - 结合缓存/预聚合策略（Redis、物化视图/分区等）确保高频交互（切区域、刷时间、切天气类型）下的稳定响应

**数据访问**：
- 聚合查询多个表（policies、claims、risk_events）
- 使用数据库聚合函数（COUNT、SUM、AVG等）

#### 3.2.6 天气服务 (Weather Service)
**职责**：管理天气数据的存储和查询

**核心功能**：
- **天气数据查询**：支持按区域、时间范围、天气类型查询
- **天气数据导入**：支持批量导入历史天气数据（MVP阶段使用mock数据）
- **天气数据统计**：计算天气数据的统计指标（均值、总量、最大值、最小值等）
- **天气数据缓存**：使用Redis缓存常用查询结果

**数据访问**：
- 直接操作 `historical_weather_data` 表
- 使用Redis缓存查询结果

### 3.3 计算服务层详细说明

#### 3.3.1 风险计算引擎 (Risk Calculator)
**职责**：基于产品规则和天气数据计算风险事件

**核心功能**：
- **产品规则解析**：解析产品的风险事件触发条件（riskRules）
  - 时间窗口配置（hourly/daily/weekly/monthly）
  - 阈值配置（tier1/tier2/tier3）
  - 计算逻辑（聚合方式、比较运算符）
- **天气数据聚合**：根据产品规则聚合天气数据
  - 滑动窗口计算（如4小时累计、7天累计）
  - 时间窗口匹配（如日内产品限制在00:00-23:59）
- **时区转换**：将UTC时间转换为风险发生地的当地时间
  - 从保单的timezone字段获取时区信息
  - 在判断"per day"、"per month"等时间窗口时，必须基于当地时间
  - 例如：如果保单时区为Asia/Shanghai，则"per day"限制应基于北京时间（UTC+8）的0点
- **风险事件生成**：判断是否触发风险事件
  - 比较聚合值与阈值
  - 确定触发的tier级别
  - 生成风险事件记录
- **扩展数据支持**：支持扩展数据回溯（用于风险叠加示意图和风险事件计算）

**输入**：
- 产品配置（riskRules）
- 天气数据（hourly/daily）
- 区域信息
- 时间范围
- 时区信息（从保单的timezone字段获取）

**输出**：
- 风险事件列表（包含tier级别、触发值、阈值等）

**时区处理**：
- 从保单的timezone字段获取时区信息
- 在判断时间窗口（如"per day"、"per month"）时，将UTC时间转换为当地时间
- 确保时间窗口判断基于风险发生地的当地时间，而非UTC时间

**与服务的协作**：
- 调用风险服务的 `create_risk_event()` 或 `batch_create_risk_events()` 方法将计算结果持久化到数据库

**执行方式**：
- **同步执行**：计算引擎本身保持同步实现（便于测试和调试）
- **异步调用**：由调用方（API路由或Celery任务）决定执行方式
  - 轻量级计算（< 0.5秒）：使用`run_in_executor`在线程池中执行
  - 重量级计算（> 0.5秒）：使用Celery异步任务处理

#### 3.3.2 理赔计算引擎 (Claim Calculator)
**职责**：基于风险事件和产品赔付规则计算理赔单

**核心功能**：
- **产品赔付规则解析**：解析产品的赔付规则（payoutRules）
  - 赔付百分比配置（以产品配置为准，例如：tier1: 20%, tier2: 50%, tier3: 100%）
  - 赔付频率限制（如once per day per policy）
- **Tier差额理赔计算逻辑**：实现tier差额理赔计算，确保总赔付金额满足payoutRules
  - **规则1**：若满足理赔条件时，同时期没有低档位的claim，则新生成claim的赔付为该档位原始比例
  - **规则2**：若满足理赔条件时，同时期已有低档位的claim，则新生成claim的赔付为差额（当前档位比例 - 已有最高档位比例）
  - **规则3**：同一时间点同时触发多个tier时，一定以最高tier为准，只生成最高tier的claim
  - **同时期定义**：特指同一个保单的赔付频率限制所定义的时间窗口
    - 例如："once per day per policy"中的"per day"表示同一天内的风险事件属于同一时期
    - 例如："once per month per policy"中的"per month"表示同一月内的风险事件属于同一时期
    - 同时期内的多个风险事件，按照tier差额逻辑计算理赔
- **时区转换**：在判断"同时期"时，必须基于风险发生地的当地时间
  - 从保单的timezone字段获取时区信息
  - 将UTC时间转换为当地时间，再判断是否属于同一时期
  - **关键**："per day"的"天"是指风险发生地当地时间的0点，而非UTC时间的0点
  - **示例**：如果保单时区为Asia/Shanghai，则北京时间2025-01-27 00:00:00（UTC+8）对应UTC时间2025-01-26 16:00:00，但"per day"限制应基于北京时间，即2025-01-27这一天的风险事件属于同一时期
- **理赔单生成**：生成理赔单记录
  - 关联保单和风险事件
  - 计算理赔金额（保额 × 赔付百分比）
  - 记录触发时间和计算时间
- **重复理赔检查**：检查是否已存在该时间点的理赔单，避免重复生成
- **并发控制**：防止重复计算和重复生成理赔单
  - **Redis分布式锁**：在计算开始前，使用Redis分布式锁（Key格式：`lock:claim_calc:{policy_id}:{date}`）
    - 锁的超时时间设置为计算任务的最大预期执行时间
    - 如果获取锁失败，说明该保单的理赔计算正在进行中，跳过本次计算
  - **数据库行锁**：在数据库事务中使用 `SELECT ... FOR UPDATE` 锁定相关的risk_events记录
    - 防止在计算过程中风险事件状态发生变化
    - 确保计算基于一致的数据快照

**计算逻辑示例**（假设产品配置：tier1: 20%, tier2: 50%, tier3: 100%，赔付频率限制：once per day per policy or once per month per policy）：

**示例1：按顺序触发（tier1 → tier2 → tier3）**
- 假设所有风险事件发生在同一天（同一时期，per day）
- 时间点T1：触发tier1风险事件，同时期（同一天）没有其他claim
  - 生成claim：赔付比例 = 20%（原始比例）
- 时间点T2：触发tier2风险事件，同时期（同一天）已有tier1的claim
  - 生成claim：赔付比例 = 50% - 20% = 30%（差额）
- 时间点T3：触发tier3风险事件，同时期（同一天）已有tier2的claim
  - 生成claim：赔付比例 = 100% - 50% = 50%（差额）
- **总赔付**：20% + 30% + 50% = 100% ✓

**示例2：跳过tier1，直接触发tier2和tier3**
- 假设所有风险事件发生在同一天（同一时期，per day）
- 时间点T1：触发tier2风险事件，同时期（同一天）没有其他claim
  - 生成claim：赔付比例 = 50%（原始比例）
- 时间点T2：触发tier3风险事件，同时期（同一天）已有tier2的claim
  - 生成claim：赔付比例 = 100% - 50% = 50%（差额）
- **总赔付**：50% + 50% = 100% ✓

**示例3：跳过tier1和tier2，直接触发tier3**
- 时间点T1：触发tier3风险事件，同时期（同一天）没有其他claim
  - 生成claim：赔付比例 = 100%（原始比例）
- **总赔付**：100% ✓

**示例4：先触发tier2，后触发tier1（逆序触发）**
- 假设所有风险事件发生在同一天（同一时期，per day）
- 时间点T1：触发tier2风险事件，同时期（同一天）没有其他claim
  - 生成claim：赔付比例 = 50%（原始比例）
- 时间点T2：触发tier1风险事件，同时期（同一天）已有tier2的claim
  - 不生成新claim（因为tier1 < tier2，已有更高档位的claim）
- **总赔付**：50%（注意：这种情况下，tier1的风险事件不会生成claim，因为已有更高档位的claim）

**示例5：同一时间点同时触发多个tier（一定以最高tier为准）**
- 时间点T1：同时触发tier1、tier2、tier3风险事件（同一时间点）
  - **处理规则**：一定以最高tier为准
  - 只生成最高档位tier3的claim：赔付比例 = 100%（原始比例）
  - 不生成tier1和tier2的claim（因为同一时间点已有更高档位的风险事件）
- **总赔付**：100% ✓

**示例6：同一时期（per day）内不同时间点触发多个tier**
- 假设产品配置：赔付频率限制为"once per day per policy"
- 假设保单时区：Asia/Shanghai（UTC+8）
- **时区转换**：所有UTC时间转换为北京时间（当地时间）来判断"同一天"
- 日期D1的08:00（北京时间）：触发tier1风险事件，同时期（同一天，基于北京时间）没有其他claim
  - 生成claim：赔付比例 = 20%（原始比例）
- 日期D1的14:00（北京时间）：触发tier2风险事件，同时期（同一天，基于北京时间）已有tier1的claim
  - 生成claim：赔付比例 = 50% - 20% = 30%（差额）
- 日期D1的20:00（北京时间）：触发tier3风险事件，同时期（同一天，基于北京时间）已有tier2的claim
  - 生成claim：赔付比例 = 100% - 50% = 50%（差额）
- **总赔付**：20% + 30% + 50% = 100% ✓
- **注意**：
  - 日期D2的风险事件属于新的时期（新的"天"），可以重新开始计算
  - "同一天"的判断基于北京时间（当地时间）的0点，而非UTC时间的0点
  - 例如：UTC时间2025-01-27 16:00:00对应北京时间2025-01-28 00:00:00，属于新的一天

**示例7：同一时期（per month）内不同日期触发多个tier**
- 假设产品配置：赔付频率限制为"once per month per policy"
- 假设保单时区：Asia/Shanghai（UTC+8）
- **时区转换**：所有UTC时间转换为北京时间（当地时间）来判断"同一月"
- 2025年1月5日（北京时间）：触发tier1风险事件，同时期（同一月，基于北京时间）没有其他claim
  - 生成claim：赔付比例 = 20%（原始比例）
- 2025年1月15日（北京时间）：触发tier2风险事件，同时期（同一月，基于北京时间）已有tier1的claim
  - 生成claim：赔付比例 = 50% - 20% = 30%（差额）
- 2025年1月25日（北京时间）：触发tier3风险事件，同时期（同一月，基于北京时间）已有tier2的claim
  - 生成claim：赔付比例 = 100% - 50% = 50%（差额）
- **总赔付**：20% + 30% + 50% = 100% ✓
- **注意**：
  - 2025年2月的风险事件属于新的时期（新的"月"），可以重新开始计算
  - "同一月"的判断基于北京时间（当地时间）的月份，而非UTC时间的月份
  - 例如：UTC时间2025-01-31 16:00:00对应北京时间2025-02-01 00:00:00，属于新的月份

**输入**：
- 保单信息（包含保额、timezone时区信息）
- 风险事件列表
- 产品配置（payoutRules）

**输出**：
- 理赔单列表（包含理赔金额、tier级别等）

**时区处理**：
- 从保单的timezone字段获取时区信息
- 在判断"同时期"（如"per day"、"per month"）时，将UTC时间转换为当地时间
- 确保"per day"的"天"基于风险发生地当地时间的0点，而非UTC时间的0点

**与服务的协作**：
- 调用理赔服务的 `create_claim()` 方法将计算结果持久化到数据库

**并发控制实现**：
1. **获取分布式锁**：使用Redis分布式锁，Key为 `lock:claim_calc:{policy_id}:{date}`
2. **开启数据库事务**：在事务中执行计算逻辑
3. **锁定相关数据**：使用 `SELECT ... FOR UPDATE` 锁定该保单相关的risk_events记录
4. **执行计算**：在锁定状态下执行理赔计算
5. **提交事务**：计算完成后提交事务
6. **释放锁**：释放Redis分布式锁

**执行方式**：
- **同步执行**：计算引擎本身保持同步实现（便于测试和调试）
- **异步调用**：由调用方（API路由或Celery任务）决定执行方式
  - 轻量级计算（< 0.5秒）：使用`run_in_executor`在线程池中执行
  - 重量级计算（> 0.5秒）：使用Celery异步任务处理

#### 3.3.3 天气数据计算引擎 (Weather Calculator)
**职责**：处理天气数据的计算和转换

**核心功能**：
- **天气数据生成**：MVP阶段生成mock天气数据
  - 支持多种天气类型（rainfall、wind、temperature等）
  - 基于区域种子生成确定性随机数据
  - 支持历史数据和预测数据
- **天气数据聚合**：按时间粒度聚合天气数据
  - 小时级数据聚合为日级数据
  - 支持多种聚合方式（sum、avg、max、min）
- **天气数据转换**：单位转换和格式转换
  - 单位转换（如mm到inch、celsius到fahrenheit）
  - 数据格式转换（适配不同API需求）

**输入**：
- 区域信息
- 时间范围
- 天气类型
- 数据粒度（hourly/daily）

**输出**：
- 天气数据列表（包含时间戳、数值、单位等）

### 3.4 Celery定时任务

#### 3.4.1 风险事件计算任务 (risk_event_calculation)
**执行频率**：根据产品类型的不同计算频率和逻辑，由Celery Beat动态调度

**职责**：
- 定期计算所有产品的历史风险事件
- 支持历史数据回溯计算
- **注意**：预测数据的风险事件不在本任务中计算，而是在天气数据同步任务中，当预测数据更新时一并计算

**执行流程**：
1. 获取所有需要计算的产品
2. 对每个产品：
   - 获取该产品的风险规则配置
   - 获取相关的历史天气数据（仅历史数据）
   - 调用风险计算引擎计算风险事件
   - 调用风险服务的批量创建方法将风险事件保存到数据库（data_type标记为'historical'）
3. 记录任务执行结果

#### 3.4.2 理赔计算任务 (claim_calculation)
**执行频率**：每天23:00执行

**职责**：
- 定期计算所有保单的理赔单
- 支持历史保单回溯计算
- 支持保障中保单的实时计算

**执行流程**：
1. 获取所有需要计算的保单（保障中或历史保单）
2. 对每个保单：
   - 获取该保单的风险事件（基于产品规则和天气数据）
   - 调用理赔计算引擎计算理赔单
   - 调用理赔服务的创建方法将理赔单保存到数据库
3. 记录任务执行结果

#### 3.4.3 天气数据同步任务 (weather_sync)
**执行频率**：根据数据源配置（未来扩展，预测数据定时更新）

**职责**：
- 同步外部天气数据API的数据（包括历史数据和预测数据）
- 将同步的数据保存到数据库
- **预测数据风险事件计算**：当预测数据更新时，自动计算基于预测数据的风险事件
  - 获取所有产品的风险规则配置
  - 基于更新的预测天气数据计算风险事件
  - 调用风险服务的批量创建方法将风险事件保存到数据库（data_type标记为'predicted'）
- 清理过期的缓存数据

### 3.5 API设计

#### 3.5.1 RESTful API规范

**基础URL**：`/api/v1`

**产品（Product）**：
- `GET /products` - 获取产品列表（支持按 `weather_type` / `type` / `is_active` 筛选）
- `GET /products/{id}` - 获取产品详情（包含 `riskRules` 与 `payoutRules`）

**保单管理**：
- `GET /policies` - 获取保单列表（支持筛选，读路径）
- `GET /policies/{id}` - 获取保单详情（读路径）
- **写入策略**：保单写入/修复走内部任务或内部接口（非对外公开）

**理赔管理**：
- `GET /claims` - 获取理赔单列表（支持筛选，读路径）
- `GET /claims/{id}` - 获取理赔单详情（读路径）
- `GET /policies/{id}/claims` - 获取保单的理赔单列表（读路径）
- **写入策略**：理赔写入由任务/内部接口执行（非对外公开）

**统计查询**：
- `GET /statistics/policies` - 保单统计（数量、保额）
- `GET /statistics/claims` - 理赔统计（数量、理赔额）
- `GET /statistics/trends` - 趋势统计（时间序列）

**天气数据**：
- `GET /weather/historical` - 获取历史天气数据
- `POST /weather/historical` - 导入历史天气数据（MVP用mock）

**风险事件**：
- `GET /risk-events` - 获取风险事件列表（读路径）
- `GET /risk-events/{id}` - 获取风险事件详情（可选，读路径）
- **写入策略**：risk_events 由计算任务/内部接口写入（非对外公开）

**内部写入能力（非公开）**：
- Policies 写入/修复：由内部任务或运维工具执行（不开放公网写）
- Risk Events 写入：由风险计算任务批量写入（historical/predicted 分流）
- Claims 写入：由理赔计算任务写入（仅 historical）
- Prediction Runs 写入：批次管理与 active_run 切换由内部服务执行

**AI Agent**：
- `POST /agents/chat` - AI对话接口（文本模式，支持流式输出）
  - **协议**：HTTP + Server-Sent Events (SSE)
  - **流式输出**：支持增量响应，实时返回Agent的思考过程和结果
  - **状态指示**：返回Agent当前状态（如"正在分析历史天气数据..."、"正在计算风险预测..."）
  - **参数**：`channel='text'`（默认）

- `WS /ws/agents/chat` - AI对话接口（语音模式，实时流式）
  - **协议**：WebSocket（双向通信，必须用于语音）
  - **输入**：音频二进制块（Bytes）或转写后的文本
  - **输出**：流式音频（TTS）或文本
  - **VAD支持**：接收前端VAD检测的"Commit"信号和"INTERRUPT"信号
  - **打断处理**：支持用户插嘴打断，立即停止生成并处理新输入
  - **参数**：`channel='voice'`
  - **技术**：使用 Gemini 1.5 Pro Multimodal 原生音频支持（无需STT转写）

**WebSocket 消息协议**：
```json
// 客户端 → 服务器
{
  "type": "audio_chunk" | "text" | "commit" | "interrupt",
  "data": "<音频二进制或文本>",
  "session_id": "xxx"
}

// 服务器 → 客户端
{
  "type": "audio_chunk" | "text" | "status" | "error",
  "data": "<音频二进制或文本>",
  "status": "thinking" | "calling_tool" | "generating" | "done"
}
```

#### 3.5.2 API异步处理策略

**CPU密集型计算的异步处理**：
- **原则**：所有计算逻辑（Calculator）绝对不要在FastAPI的async def路由中直接运行
- **方案A（轻量级计算 < 0.5秒）**：
  - 使用`asyncio.get_event_loop().run_in_executor(None, compute_function, args)`
  - 将计算任务扔到线程池执行
  - 适用于简单的实时试算接口
- **方案B（重量级计算 > 0.5秒，推荐）**：
  - 使用Celery异步任务处理
  - 通过Webhook或Polling机制返回结果
  - 或者在FastAPI中使用独立的Process Pool
  - 适用于复杂的风险计算、理赔计算

**实现示例**：
- 任务入口不对外暴露，触发计算由调度/后台执行

---

## 4. AI Agent架构设计

### 4.1 架构模式：Tool Use / Function Calling

AI Agent采用**工具调用（Tool Use / Function Calling）**模式，通过调用后端业务服务层的功能来实现AI能力，而不是作为独立的孤岛。这种方式确保：
- **业务逻辑复用**：AI Agent复用后端已有的业务逻辑，避免重复实现
- **数据一致性**：AI Agent和API使用相同的数据源和计算逻辑
- **可维护性**：业务逻辑集中管理，便于维护和扩展

### 4.2 多Agent协作架构（优化版）

**架构优化说明**：
- **合并 Chat Agent + Orchestrator Agent**：现代 LLM（GPT-4o、Gemini 1.5 Pro）完全可以在单次调用中完成 NLU + 意图识别 + Tool Calling，无需分离
- **引入 Modality Adapter Layer**：解耦交互模态（文本/语音）与 Agent 逻辑，提升扩展性
- **支持实时流式模式**：通过 WebSocket 支持语音交互和低延迟响应

```
┌─────────────────────────────────────────────────────────┐
│           表现层 (Presentation Layer)                     │
│  ┌──────────────────┐  ┌──────────────────┐           │
│  │ Text Chat UI     │  │ Voice Interface  │           │
│  │ (Contextual View)│  │ (Web Speech API)  │           │
│  └──────────────────┘  └──────────────────┘           │
└─────────────────────────────────────────────────────────┘
        ↕ HTTP/SSE              ↕ WebSocket
┌─────────────────────────────────────────────────────────┐
│          Modality Adapter Layer                         │
│  ┌──────────────────┐  ┌──────────────────┐           │
│  │ TextAdapter      │  │ VoiceAdapter     │           │
│  │ - 直通文本       │  │ - VAD检测        │           │
│  │ - 格式转换       │  │ - STT/TTS        │           │
│  │                  │  │ - 打断处理       │           │
│  └──────────────────┘  └──────────────────┘           │
└─────────────────────────────────────────────────────────┘
                        ↕ (统一文本协议)
┌─────────────────────────────────────────────────────────┐
│          Router Agent (Supervisor Agent)                 │
│  [合并原 Chat Agent + Orchestrator Agent]               │
│  - 自然语言理解 (NLU)                                    │
│  - 对话上下文管理 (Session State)                        │
│  - 意图识别 + 路由决策                                   │
│  - 调用 Expertise Agents (as Tools)                      │
│  - 响应格式化 (根据 channel: text/voice)                 │
│  - 语气控制 (语音模式：简短、不念表格)                   │
└─────────────────────────────────────────────────────────┘
        ↕              ↕              ↕
        │              │              │
        │ (Function Calling)         │
        │              │              │
┌──────────────┐ ┌──────────────┐ ┌──────────────┐
│ Product      │ │ Risk & Claim │ │ Policy       │
│ Expertise    │ │ Expertise     │ │ Expertise    │
│ Agent        │ │ Agent         │ │ Agent        │
│              │ │               │ │              │
│ - 产品说明   │ │ - 历史风险查询│ │ - 保单查询   │
│ - 产品规则   │ │ - 风险预测试算│ │ - 保单统计   │
│ - 产品对比   │ │ - 理赔查询   │ │ - 保单分析   │
│              │ │ - 理赔解释   │ │              │
│              │ │ - 理赔预测   │ │              │
└──────────────┘ └──────────────┘ └──────────────┘
        ↕              ↕              ↕
┌─────────────────────────────────────────────────────────┐
│             工具层 (Tools Layer)                         │
│  通过Function Calling调用后端业务服务                      │
│  - Policy Service (保单服务)                             │
│  - Claim Service (理赔服务)                              │
│  - Risk Service (风险服务)                               │
│  - Statistics Service (统计服务)                        │
│  - Weather Service (天气服务)                            │
│  - Risk Calculator (风险计算引擎)                         │
│  - Claim Calculator (理赔计算引擎)                        │
│                                                          │
│  ⚠️ 关键：Service层只返回纯JSON数据，不包含格式          │
│  Agent层根据channel参数决定响应格式（Markdown/语音）     │
└─────────────────────────────────────────────────────────┘
        ↕
┌─────────────────────────────────────────────────────────┐
│             数据层 (Data Layer)                           │
│         PostgreSQL + Redis (缓存)                         │
└─────────────────────────────────────────────────────────┘
```

### 4.3 Agent详细说明

#### 4.3.1 Modality Adapter Layer（模态适配层）

**设计目标**：解耦交互模态（文本/语音）与 Agent 逻辑，实现多模态扩展

**核心组件**：

##### TextAdapter（文本适配器）
- **职责**：处理文本输入/输出
- **实现**：
  - HTTP/SSE 协议
  - 直接传递文本，无需转换
  - 支持 Markdown 格式渲染

##### VoiceAdapter（语音适配器）
- **职责**：处理语音输入/输出，支持实时流式交互
- **关键技术**：
  - **VAD (Voice Activity Detection)**：
    - 前端使用 Silero VAD (WebAssembly) 或浏览器 Web Speech API
    - 检测用户静音，发送 "Commit" 信号给后端
    - 支持打断检测（Barge-in）
  - **STT (Speech-to-Text)**：
    - 支持 Gemini Native Audio（直接处理音频二进制，无需转文字）
    - 或使用 Google Speech-to-Text API
  - **TTS (Text-to-Speech)**：
    - 使用 Google Text-to-Speech API
    - 支持流式音频输出
  - **打断处理**：
    - 用户插嘴 → VAD 检测 → 发送 INTERRUPT 信号 → 后端停止生成 → 清空缓冲 → 处理新输入

**接口定义**：
```typescript
interface ModalityAdapter {
  // 将原始输入转换为文本（供 Agent 处理）
  transcribe(input: RawInput): Promise<string>;
  
  // 将 Agent 输出转换为模态输出
  synthesize(text: string, channel: 'text' | 'voice', streamCallback?: (chunk: OutputChunk) => void): Promise<Output>;
}
```

#### 4.3.2 Router Agent（路由Agent，原 Chat Agent + Orchestrator Agent 合并）

**职责**：作为统一的入口，处理自然语言理解、意图识别、路由决策和响应格式化

**核心功能**：
- **自然语言理解 (NLU)**：理解用户的自然语言输入（文本或转写后的文本）
- **对话上下文管理**：维护对话历史和上下文（Session State）
- **意图识别和路由**：
  - 识别用户意图（产品查询、风险查询、理赔查询、保单查询、风险预测、理赔预测等）
  - 路由到合适的专业 Agent（通过 Function Calling）
    - 产品相关 → Product Expertise Agent
    - 风险和理赔相关 → Risk & Claim Expertise Agent
    - 保单相关 → Policy Expertise Agent
- **多Agent协作**：
  - 协调多个专业 Agent 共同完成复杂任务
  - 管理 Agent 间的对话流程
- **工具调用管理**：
  - 管理对后端业务服务的工具调用
  - 处理工具调用的结果和错误
- **响应格式化（根据 channel）**：
  - **文本模式 (channel='text')**：返回 Markdown 格式，支持表格、列表等结构化展示
  - **语音模式 (channel='voice')**：
    - 响应控制在 2 句话以内
    - 不念原始数据表格，总结关键数字
    - 语气友好，适合语音场景（保险理赔安抚情绪）
- **Prompt 微调（语音模式）**：
  ```
  If the output_modality is 'voice':
    - Keep responses under 2 sentences
    - Do not read raw data tables
    - Summarize key figures
    - Use friendly, reassuring tone (important for insurance claims)
  ```

**技术实现**：
- 使用 Google ADK 实现
- 支持 Gemini 1.5 Pro Multimodal（原生音频输入）
- 实现 Function Calling 机制，调用后端业务服务和 Expertise Agents
- 根据 `channel` 参数（text/voice）动态调整响应格式

#### 4.3.3 Product Expertise Agent (产品专业Agent)
**职责**：处理产品相关的专业问题

**核心功能**：
- **产品说明**：解释产品的定义、特点、适用场景
- **产品规则解释**：解释产品的风险事件触发条件和赔付规则（仅说明规则本身，不涉及实际风险事件查询）
- **产品对比**：对比不同产品的差异和特点
- **产品推荐**：根据用户需求推荐合适的产品

**工具调用**：
- 调用产品库获取产品配置

#### 4.3.4 Risk & Claim Expertise Agent (风险与理赔专业Agent)
**职责**：处理风险事件和理赔相关的专业问题

**核心功能**：
- **历史风险查询**：查询历史风险事件信息（按产品、区域、时间范围、天气类型、tier级别等）
- **风险预测试算**：基于预测天气数据实时计算潜在风险事件
  - 调用风险计算引擎进行预测计算
  - 使用预测天气数据作为输入
  - 返回预测的风险事件结果
- **理赔查询**：查询理赔单信息（按保单、区域、时间范围等）
- **理赔解释**：解释理赔单的生成原因和计算逻辑
- **理赔预测**：基于预测风险事件预测潜在理赔
- **理赔统计**：提供理赔统计和分析
- **风险统计**：提供风险事件统计和分析

**工具调用**：
- 调用风险服务查询历史风险事件
- 调用风险计算引擎进行风险预测试算
- 调用理赔服务查询理赔单
- 调用统计服务获取理赔和风险统计
- 调用理赔计算引擎进行理赔预测

#### 4.3.5 Policy Expertise Agent (保单专业Agent)
**职责**：处理保单相关的专业问题

**核心功能**：
- **保单查询**：查询保单信息（按产品、区域、时间范围、投保人等）
- **保单统计**：提供保单统计和分析
- **保单分析**：分析保单的保障情况（不涉及风险事件查询）

**工具调用**：
- 调用保单服务查询保单
- 调用统计服务获取保单统计

### 4.4 工具调用机制

#### 4.4.1 Function Calling规范
每个后端业务服务提供标准化的Function接口，供AI Agent调用：

**Function定义格式**：
- Function名称：清晰描述功能
- Function描述：详细说明功能用途和参数
- 参数定义：使用JSON Schema定义参数结构
- 返回值定义：定义返回值的结构和格式

**示例Function**：
- `get_policy_statistics`：获取保单统计
- `get_claim_statistics`：获取理赔统计
- `get_risk_events`：查询历史风险事件
- `calculate_risk_prediction`：计算风险预测（基于预测天气数据）
- `explain_claim_calculation`：解释理赔计算逻辑

#### 4.4.2 工具调用流程
1. **Agent识别需求**：Router Agent理解用户需求，确定需要调用的工具
2. **状态通知**：向用户发送状态指示（如"正在查询历史风险事件..."）
3. **Function Calling**：Router Agent调用后端业务服务的Function
4. **业务逻辑执行**：后端服务执行业务逻辑，返回**纯JSON数据**（不包含格式）
5. **结果处理**：Router Agent根据 `channel` 参数处理返回结果：
   - **文本模式 (channel='text')**：将JSON数据格式化为Markdown表格、列表等结构化展示
   - **语音模式 (channel='voice')**：将JSON数据总结为2句话以内的自然语言，不念表格
6. **流式响应返回**：通过SSE（文本）或WebSocket（语音）流式返回响应给用户

**关键设计原则：响应格式器解耦**
- **Service层职责**：只返回纯JSON数据，不包含任何格式（HTML、Markdown、表格等）
- **Agent层职责**：根据 `channel` 参数（text/voice）决定响应格式
  - `channel='text'`：渲染为Markdown表格（给屏幕看）
  - `channel='voice'`：总结为简短自然语言（给耳朵听）
- **优势**：
  - 业务逻辑与展示逻辑分离
  - 支持多模态扩展（未来可扩展Image、AR等）
  - 便于测试和维护

#### 4.4.3 响应速度优化

**流式输出机制**：
- **文本模式**：API (`POST /agents/chat`) 支持Server-Sent Events (SSE)
- **语音模式**：API (`WS /ws/agents/chat`) 使用WebSocket双向通信
- **增量响应**：实时返回Agent的思考过程和中间结果，而非等待全部计算完成
- **状态指示**：当Agent调用耗时工具（如Risk Calculator）时，实时推送状态更新

**前端UI反馈**：
- **文本模式**：
  - 状态指示器：显示Agent当前状态（如"正在分析历史天气数据..."、"正在计算风险预测..."）
  - 进度提示：对于长时间运行的计算，提供进度提示
- **语音模式**：
  - 实时音频流：TTS音频流式输出，低延迟体验
  - VAD可视化：显示语音活动检测状态（说话中/静音）
  - 打断提示：用户插嘴时显示"已打断，正在处理新请求..."
- **错误处理**：当工具调用失败时，提供友好的错误提示和重试机制

**性能优化策略**：
- **缓存机制**：对于相同查询，使用缓存结果，避免重复计算
- **异步处理**：对于耗时操作，采用异步处理，不阻塞用户交互
- **批量查询**：合并多个小查询为批量查询，减少网络往返
- **Gemini Native Audio**：使用Gemini 1.5 Pro Multimodal原生音频支持，避免STT/TTS的额外延迟
- **WebSocket连接池**：复用WebSocket连接，减少握手开销

**语音模式特殊优化**：
- **低延迟TTS**：使用流式TTS，边生成边播放
- **VAD优化**：前端VAD检测静音后立即发送Commit，减少等待时间
- **打断响应**：支持用户插嘴打断，立即停止生成并处理新输入（Barge-in）
- **语气识别**：Gemini Native Audio能识别用户语气（焦急、生气），Router Agent据此调整响应语气（安抚情绪）

### 4.5 Voice Gateway 与实时流式模式

#### 4.5.1 Voice Gateway 架构

**设计目标**：在 FastAPI 层引入 WebSocket，支持实时双向语音通信

**关键组件**：

```
┌─────────────────────────────────────────────────────────┐
│             前端 (Frontend)                              │
│  - Web Speech API / Silero VAD (WebAssembly)            │
│  - 音频采集 → VAD检测 → WebSocket发送                   │
└─────────────────────────────────────────────────────────┘
                        ↕ WebSocket
┌─────────────────────────────────────────────────────────┐
│         Voice Gateway (FastAPI WebSocket)                │
│  - WebSocket连接管理                                     │
│  - 音频流接收/发送                                       │
│  - VAD信号处理（Commit/Interrupt）                      │
│  - 会话状态管理                                          │
└─────────────────────────────────────────────────────────┘
                        ↕
┌─────────────────────────────────────────────────────────┐
│         VoiceAdapter (Modality Adapter)                  │
│  - STT: Gemini Native Audio 或 Google Speech-to-Text   │
│  - TTS: Google Text-to-Speech (流式)                     │
│  - 音频格式转换                                          │
└─────────────────────────────────────────────────────────┘
                        ↕ (统一文本协议)
┌─────────────────────────────────────────────────────────┐
│         Router Agent                                    │
│  - 处理语义逻辑（与模态无关）                            │
└─────────────────────────────────────────────────────────┘
```

#### 4.5.2 VAD (Voice Activity Detection) 实现

**前端实现**：
- **方案A（推荐）**：使用 Silero VAD (WebAssembly)
  - 轻量级，无需网络请求
  - 实时检测语音活动
  - 检测到静音后发送 "Commit" 信号
- **方案B**：使用浏览器 Web Speech API
  - 原生支持，但兼容性有限

**VAD 信号协议**：
```json
// 客户端 → 服务器
{
  "type": "commit",      // 用户说完话，提交输入
  "session_id": "xxx"
}

{
  "type": "interrupt",   // 用户插嘴打断
  "session_id": "xxx"
}
```

#### 4.5.3 Gemini Native Audio 集成

**优势**：
- **无需STT转写**：直接将音频二进制块（Bytes）传给 Gemini
- **语气识别**：能识别用户语气（焦急、生气、平静等）
- **低延迟**：减少STT转写的额外延迟

**实现方式**：
```python
# 使用 Gemini 1.5 Pro Multimodal API
from google.generativeai import GenerativeModel

model = GenerativeModel('gemini-1.5-pro')

# 直接传入音频二进制
response = model.generate_content(
    contents=[
        {"mime_type": "audio/webm", "data": audio_bytes}
    ],
    generation_config={
        "response_modality": "audio"  # 或 "text"
    }
)
```

**注意**：如果 Gemini Native Audio 不可用，回退到传统方案：
1. 前端/后端 STT 转写音频为文本
2. Router Agent 处理文本
3. TTS 合成音频返回

#### 4.5.4 打断处理 (Barge-in) 实现

**流程**：
1. **用户插嘴**：前端 VAD 检测到用户开始说话
2. **发送 INTERRUPT 信号**：通过 WebSocket 发送 `{"type": "interrupt"}`
3. **后端处理**：
   - 立即停止当前音频生成/传输
   - 清空上下文缓冲（避免混乱）
   - 等待新输入
4. **处理新输入**：接收新的音频/文本，重新开始对话

**实现要点**：
- 使用 `asyncio.CancelledError` 或 `asyncio.Task.cancel()` 取消正在进行的生成任务
- 维护会话状态，支持打断后的上下文恢复

#### 4.5.5 WebSocket 实现示例

**FastAPI WebSocket 路由**：
```python
from fastapi import WebSocket, WebSocketDisconnect
from app.agents.modality_adapters.voice_adapter import VoiceAdapter
from app.agents.router_agent import RouterAgent

@app.websocket("/ws/agents/chat")
async def websocket_chat(websocket: WebSocket):
    await websocket.accept()
    voice_adapter = VoiceAdapter()
    router_agent = RouterAgent()
    session_id = None
    
    try:
        while True:
            # 接收消息
            data = await websocket.receive()
            
            if data["type"] == "websocket.receive":
                if "text" in data:
                    message = json.loads(data["text"])
                    msg_type = message.get("type")
                    
                    if msg_type == "audio_chunk":
                        # 处理音频块
                        audio_bytes = base64.b64decode(message["data"])
                        text = await voice_adapter.transcribe(audio_bytes)
                        # 调用 Router Agent
                        response = await router_agent.process(text, channel="voice")
                        # TTS 合成并流式返回
                        async for audio_chunk in voice_adapter.synthesize_stream(response):
                            await websocket.send_bytes(audio_chunk)
                    
                    elif msg_type == "commit":
                        # 用户说完话，处理最后一段
                        # ...
                    
                    elif msg_type == "interrupt":
                        # 用户插嘴，停止生成
                        # 取消当前任务
                        # ...
                        
    except WebSocketDisconnect:
        # 清理资源
        pass
```

#### 4.5.6 架构师的避坑建议（MVP阶段准备）

**1. 解耦响应格式器**：
- ✅ **Service层**：只返回纯JSON数据，不包含格式（HTML、Markdown、表格等）
- ✅ **Agent层**：根据 `channel` 参数（text/voice）决定响应格式
  - `channel='text'`：渲染为Markdown表格（给屏幕看）
  - `channel='voice'`：总结为2句话（给耳朵听）

**2. 保留WebSocket入口**：
- ✅ 在FastAPI路由规划时，预留 `/ws/agents/chat` 位置
- ✅ 即使MVP阶段只实现HTTP，也要在代码结构中预留WebSocket接口

**3. 关注Gemini API更新**：
- ✅ Google正在推 Live API（类似OpenAI Realtime API）
- ✅ 未来可能不需要自己写STT/TTS，直接建立端到端连接
- ✅ 保持架构灵活性，支持未来升级

---

## 5. 前端架构升级

本章对齐 `docs/v2/v2页面设计提案.md` 的新信息架构（L0/L1/L2）与新增的“权限与模式（先设计，后实现）”原则，聚焦**顶层架构契约**，避免陷入具体组件实现。

### 5.1 产品信息架构（L0/L1/L2）上升为前端运行时分层

前端不再只是“地图 + 若干面板”，而是一个可编排的 Dashboard Workbench：

- **L0 省级态势（全局）**：Left HUD Rail（Search 下方的 HUD）负责背书与导航（金额 KPI + Top 导航（Pareto）+ sparkline 提示 + AI Insight），目标是“10 秒内一眼看到态势”
- **L1 区域态势（选中区域）**：区域情报面板（Overview + 趋势 + 统一时间轴），目标是“可解释”
- **L2 证据链（Details）**：明细溯源与回指时间轴，目标是“可追溯”

架构含义：三层不是三个 UI 区块，而是三类不同的**数据产品形态**（聚合 / 时间序列 / 明细证据），对后端缓存、权限、与性能策略提出硬约束。

### 5.2 UI 编排层（UI Orchestration Layer）与交互状态机

为保证“联动可预期且不打扰”，需要将联动逻辑提升为独立的编排层概念：

- **事件驱动联动**：Map Hover/Click、Pareto Click、AI Insight Click/CTA、Time Brush、Weather Type Toggle、Layer Toggle、Product Selector、Panel Snap 等触发统一的 UI Event
- **交互状态机（体验层）**：至少区分“默认态 → 区域锁定 → 情报面板打开 → 分析态”，以避免隐式副作用（例如 Hover 触发大量数据请求）
- **唯一事实来源（Single Source of Truth）**：区域选择、时间范围、天气类型、产品选择、图层可见性、以及访问模式（见 5.3）应在同一状态域中建模，减少跨组件耦合

### 5.3 权限与“模式”（Audience Mode / View Mode）——先定义跨层契约

页面设计提案中将权限视为“信息密度与操作能力的分级开关”。在架构层面建议将其正式定义为 **Access Mode**（避免与“分析态”等交互状态混淆）：

- **Demo/Public（路演默认）**：少数字、强可视化、强解释；敏感口径与明细以聚合/脱敏/隐藏呈现
- **Partner（合作伙伴）**：开放更深的 Top 导航与 KPI；明细可字段级脱敏
- **Admin/Internal（内部）**：开放全量（含明细、导出、配置、对比等）

跨层契约（不重型实现，也必须先约定）：

- **前端**：Mode 影响默认展开、可用能力（Compare/导出/分享/Details 等），但遵循“可见但不可用”的降级原则（锁标识 + 解释），避免演示口径断流
- **后端**：Mode 不是纯 UI 开关，必须能驱动输出裁剪（字段级脱敏、聚合摘要、敏感口径范围化），并对越权请求做一致处理
- **AI Agent**：洞察生成与动作建议必须 Mode-aware（避免在 Demo/Public 下引导不可用或敏感操作）

### 5.4 AI Insight：从“回答”升级为“导演式联动”

AI 在该页面的定位是 Director Cues（结论 + CTA），因此架构上需把“可执行动作”视为一等公民：

- **输出形态**：AI 需要同时输出洞察内容与“联动意图”（打开面板到某 section、叠加阈值层、刷选时间窗、触发对比等）
- **安全边界**：动作必须经过 UI 编排层与权限/模式校验后才能执行（避免 Agent 直接操控敏感能力）
- **可观测性**：前端需要统一呈现 AI 状态（ready/thinking/calling_tool/generating/done），并与数据请求节流策略协同

### 5.5 可视化性能与体验降级（架构级约束）

- **性能优先级**：Map Stage 是主舞台，任何 L1/L2 展开都不能让地图交互“掉帧”或卡死
- **渐进式披露**：默认简洁，按需下钻（Peek → Half → Full），避免一开始加载“全量明细”
- **动效可控**：尊重 `prefers-reduced-motion`；移动端提供粒子/图层降级路径
- **数据侧配合**：对地图叠加层优先返回聚合结果（而非海量明细），与统计服务的预聚合/缓存策略形成闭环

### 5.6 Google Maps + 图层架构（沿用前端可复用要点，按 v2 口径修订）

> 本节抽取“仍应沿用”的前端地图集成关键点（不复用旧文档的数据实体字段），并与 v2 Fullstack（Next.js + TanStack Query + Zustand）对齐。  
> Google Maps 合规、缓存与 Key 安全的 Gate 以 `docs/v2/v2技术方案.md` 为准（避免在多文档中出现口径漂移）。

**Maps JS API 加载与运行时约束**：
- **优先使用 Dynamic Library Import / js-api-loader 的按需加载模式**：避免重复加载，降低首屏成本；仅加载需要的 libraries（maps/marker/places 等）
- **版本策略**：使用 `weekly`（或团队约定的固定版本），并通过可控升级流程更新
- **Key 注入**：仅通过环境变量读取（前端 `NEXT_PUBLIC_GOOGLE_MAPS_API_KEY`），禁止硬编码

**地图主舞台（Map Stage）的图层分层**：
- **Base Map（Google Map）**：仅承担底图与基础交互（pan/zoom、controls）
- **行政区域边界（Region Boundary）**：
  - 以 GeoJSON 边界数据渲染区域轮廓与 hover/lock 高亮
  - 注意：Google Maps JS API 不直接提供完整行政边界数据，需自备权威边界数据源并进行预处理（GeoJSON），通过静态资源或后端接口下发
  - 小数据量可用原生 Data Layer/Polygon；大数据量或复杂动效优先考虑 deck.gl + GoogleMapsOverlay（WebGL）
- **天气可视化（Weather Layer）**：
  - 以“按天气类型切换”的图层体系组织（rain/wind/…）
  - 以 `data_type`（historical/predicted）作为图层维度：同一 weather_type 下至少存在“历史层/预测层”的表达（颜色/透明度/图例需区分）
  - 小数据量可采用区域级渲染（更易与行政边界对齐）；数据量上升后优先走“服务端聚合 → 前端渲染”的路径
- **风险事件（Risk Layer）**：
  - 事件点位/强度可用 Advanced Markers 或 deck.gl IconLayer/ScatterPlotLayer 表达
  - 同样受 `data_type` 影响：历史与预测风险事件需要不同的视觉语义（样式/动效/图例）
  - 与产品 `riskRules` 强绑定：切产品/切天气类型会改变阈值/口径与图例（Legend）
- **理赔叠加（Claims Overlay，Mode-aware）**：
  - Demo/Public 模式建议仅展示聚合强弱或区间化信息；Partner/Admin 才允许更细粒度
  - 建议优先采用聚合图层（如 hex/column 等表现）避免明细点位过载与敏感信息泄露

**图层控制与联动原则（与 UI Orchestration 对齐）**：
- Hover 是轻交互：只做边界高亮与轻量 tooltip，避免触发重数据请求
- Click lock / Pareto Click / AI Insight Click 是重交互：允许触发 L1/L2 的数据产品请求；其中：
  - Pareto Click：只驱动 map fly-to + lock（默认不自动展开面板）
  - AI Insight Click/CTA：驱动打开面板到 Half 并定位 section
- Legend/阈值提示属于“解释层”：随 weather_type + product + mode 变化，必须与后端口径保持一致

**GPS 定位与反向解析（可选能力，成本/限流敏感）**：
- GPS 获取（浏览器）与反向解析（Geocoding）属于高成本与高风险能力：必须做节流、限流与失败降级
- 任何缓存/存储必须遵循 Google Maps Platform 条款（详见 `docs/v2/v2技术方案.md` 第 9、16 节）

---

## 6. 部署架构

### 6.1 Docker容器化

**服务容器**：
- `postgres`：PostgreSQL + PostGIS数据库
- `redis`：Redis缓存
- `backend`：后端API服务（FastAPI）
- `celery_worker`：Celery Worker（执行异步任务）
- `celery_beat`：Celery Beat（定时任务调度）
- `frontend`：前端服务（Next.js 开发服务器或生产 Node 服务，可选 Nginx/边缘缓存）

**数据持久化**：
- PostgreSQL数据卷：持久化数据库数据
- Redis数据卷：持久化缓存数据

### 6.2 环境变量配置

**后端环境变量**：
- `DATABASE_URL`：数据库连接字符串
- `REDIS_URL`：Redis连接字符串
- `GOOGLE_MAPS_API_KEY`：Google Maps API密钥
- `GOOGLE_GENERATIVE_AI_API_KEY`：Google Generative AI API密钥（用于Gemini）
- `CELERY_BROKER_URL`：Celery消息队列URL
- `CELERY_RESULT_BACKEND`：Celery结果后端URL
- `GOOGLE_SPEECH_TO_TEXT_API_KEY`：Google Speech-to-Text API密钥（语音模式降级方案，可选）
- `GOOGLE_TEXT_TO_SPEECH_API_KEY`：Google Text-to-Speech API密钥（语音模式降级方案，可选）

**前端环境变量**：
- `NEXT_PUBLIC_API_BASE_URL`：后端API地址
- `NEXT_PUBLIC_GOOGLE_MAPS_API_KEY`：Google Maps API密钥

---

## 7. 测试策略

### 7.1 测试层次

#### 7.1.1 单元测试
- **目标**：测试单个函数或方法的正确性
- **覆盖范围**：
  - 计算引擎的核心逻辑（风险计算、理赔计算）
  - 业务服务的CRUD操作
  - 工具函数的正确性

#### 7.1.2 集成测试
- **目标**：测试多个组件协同工作的正确性
- **覆盖范围**：
  - API端到端测试
  - 数据库操作测试
  - Celery任务执行测试

#### 7.1.3 Property-Based Testing（属性测试）
- **目标**：通过自动生成大量测试用例，验证系统属性的正确性
- **工具**：Python的Hypothesis库
- **关键属性（Invariant）验证**：
  1. **总赔付比例永远不超过100%**
     - 自动生成随机天气数据和保单组合
     - 验证任何情况下，同一保单在同一时期内的总赔付比例不超过100%
  2. **理赔金额计算精度正确**
     - 使用Decimal类型，验证浮点运算精度
     - 验证保额 × 赔付百分比 = 理赔金额的精确性
  3. **同时期内的理赔逻辑正确**
     - 验证tier差额逻辑的正确性
     - 验证逆序触发、跳档触发等边界情况
  4. **数据一致性**
     - 验证风险事件与理赔单的关联正确性
     - 验证保单与理赔单的关联正确性
- **边缘Case发现**：
  - 跨越午夜0点的极端天气（影响"per day"的时期判断）
  - 跨越月份边界的风险事件（影响"per month"的时期判断）
  - 同一时间点多个tier同时触发
  - 逆序触发（tier3 → tier2 → tier1）
  - 极端数值（超大保额、极小赔付比例等）

#### 7.1.4 并发测试
- **目标**：验证并发控制机制的正确性
- **测试场景**：
  - 同时触发多个理赔计算任务（同一保单）
  - 验证Redis分布式锁的正确性
  - 验证数据库行锁的并发场景
  - 验证重复任务执行的处理

#### 7.1.5 性能测试
- **目标**：验证系统在负载下的性能表现
- **测试场景**：
  - 大量保单的理赔计算性能
  - 数据库查询性能
  - 前端粒子效果渲染性能
  - AI Agent响应速度

### 7.2 测试工具和框架

- **单元测试**：pytest
- **属性测试**：Hypothesis
- **集成测试**：pytest + FastAPI TestClient
- **并发测试**：pytest + 多线程/多进程模拟
- **性能测试**：locust 或 pytest-benchmark

---

## 8. 实施计划

### 8.1 阶段一：后端基础架构（2-3周）
1. 搭建FastAPI项目结构
2. 配置PostgreSQL + PostGIS数据库
3. 实现数据模型和迁移
4. 实现基础API（保单、理赔、统计、风险、天气）

### 8.2 阶段二：计算引擎和定时任务（2-3周）
1. 实现风险计算引擎（复用前端逻辑）
2. 实现理赔计算引擎（tier差额逻辑）
3. 实现理赔计算的并发控制（Redis分布式锁 + 数据库行锁）
4. 实现时区转换逻辑（UTC转当地时间，用于判断"同时期"）
5. 实现天气数据计算引擎
6. 实现Celery定时任务（风险事件计算、理赔计算、天气同步）
7. 实现 prediction_run_id + active_run 机制，区分预测批次并支持一致性与回滚（避免混批次）
8. 实现异步执行工具（run_in_executor封装，用于API层的异步调用）

### 8.3 阶段三：前端集成（2-3周）
1. 实现API客户端
2. 实现保单统计和理赔统计组件
3. 集成到现有Dashboard
4. 实现数据面板联动
5. 实现粒子效果系统（使用deck.gl，而非Three.js）
6. 实现粒子效果的性能优化（动态密度调整、移动端降级）

### 8.4 阶段四：AI Agent集成（2-3周）
1. 搭建Google ADK Agent架构
2. **实现Router Agent**（合并原Chat Agent + Orchestrator Agent）
   - 自然语言理解 (NLU)
   - 对话上下文管理
   - 意图识别 + 路由决策
   - 响应格式化（根据channel参数）
3. **实现Modality Adapter Layer**
   - TextAdapter（文本适配器）
   - VoiceAdapter（语音适配器，VAD/STT/TTS）
4. 实现专业团队Agent（Product、Risk & Claim、Policy）
5. 实现Function Calling机制，集成后端业务服务
6. **实现流式输出**
   - 文本模式：SSE (Server-Sent Events)
   - 语音模式：WebSocket（预留接口，MVP阶段可选实现）
7. 实现状态指示和UI反馈机制
8. **解耦响应格式器**
   - Service层只返回纯JSON数据
   - Agent层根据channel参数决定响应格式
9. 集成到ContextualAssistant组件

### 8.5 阶段五：语音交互实现（可选，2-3周）
**注意**：如果MVP阶段不需要语音，此阶段可延后。但建议在代码结构中预留WebSocket接口。

1. **实现Voice Gateway**
   - FastAPI WebSocket路由 (`/ws/agents/chat`)
   - WebSocket连接管理和心跳检测
   - 会话状态管理
2. **实现前端VAD**
   - 集成Silero VAD (WebAssembly) 或浏览器Web Speech API
   - 实现Commit信号发送
   - 实现打断检测（Barge-in）
3. **集成Gemini Native Audio**
   - 直接处理音频二进制输入
   - 或实现降级方案（STT + TTS）
4. **实现打断处理**
   - 用户插嘴时立即停止生成
   - 清空上下文缓冲
   - 处理新输入
5. **优化语音延迟**
   - 流式TTS实现
   - Router Agent Prompt优化（语音模式）
   - 响应长度控制（2句话以内）
6. **测试和优化**
   - WebSocket连接稳定性测试
   - VAD误检测试
   - 打断场景测试
   - 延迟优化

### 8.6 阶段六：动画效果和天气扩展（2-3周）
1. 完善粒子效果系统（使用deck.gl的ParticleLayer）
2. 支持风速数据可视化
3. 实现粒子效果的性能优化（动态密度、移动端降级）
4. 实现台风气旋和轨迹（未来扩展）
5. 性能测试和优化

### 8.7 阶段七：测试和优化（1-2周）
1. **单元测试和集成测试**
   - 实现计算引擎的单元测试
   - 实现API的集成测试
   - 实现定时任务的测试
2. **Property-Based Testing（属性测试）**
   - 引入Python的Hypothesis库
   - 自动生成成千上万组随机的天气数据和保单组合
   - 验证关键属性（Invariant）：
     - 总赔付比例永远不超过100%
     - 理赔金额计算精度正确（使用Decimal）
     - 同时期内的理赔逻辑正确
   - 发现人类思维难以覆盖的边缘Case（如跨越午夜0点的极端天气、逆序触发等）
3. **并发控制测试**
   - 测试Redis分布式锁的正确性
   - 测试数据库行锁的并发场景
   - 测试重复任务执行的处理
4. **端到端测试**
   - 完整业务流程测试
   - 前端与后端集成测试
5. **性能优化**
   - 数据库查询优化
   - 缓存策略优化
   - 前端渲染性能优化
6. **文档完善**
7. **部署准备**

---

## 9. 技术风险和注意事项

### 9.1 金融计算精度
- **风险**：使用float可能导致精度误差
- **解决方案**：使用Python `decimal.Decimal` 和 PostgreSQL `DECIMAL` 类型

### 9.2 定时任务可靠性
- **风险**：Celery任务可能失败或重复执行
- **解决方案**：
  - 实现任务幂等性
  - 添加任务重试机制
  - 监控任务执行状态

### 9.2.1 并发控制（至关重要）
- **风险**：如果Celery意外触发了两次针对同一保单的计算任务（或人工重试），可能导致重复生成Claim
- **解决方案**：
  - **Redis分布式锁**：在理赔计算开始前，使用Redis分布式锁
    - Key格式：`lock:claim_calc:{policy_id}:{date}`
    - 锁的超时时间设置为计算任务的最大预期执行时间
    - 如果获取锁失败，说明该保单的理赔计算正在进行中，跳过本次计算
  - **数据库行锁**：在数据库事务中使用 `SELECT ... FOR UPDATE` 锁定相关的risk_events记录
    - 防止在计算过程中风险事件状态发生变化
    - 确保计算基于一致的数据快照
  - **实现位置**：在理赔计算引擎（Claim Calculator）中实现

### 9.3 数据一致性
- **风险**：理赔计算依赖风险事件，需要保证数据一致性
- **解决方案**：
  - 使用数据库事务
  - 实现数据版本控制
  - 添加数据校验

### 9.4 性能优化
- **风险**：大量保单和理赔数据可能导致查询慢
- **解决方案**：
  - 添加数据库索引
  - 使用Redis缓存
  - 实现数据分页
  - 考虑数据分区（按时间）

### 9.5 AI Agent稳定性
- **风险**：Agent可能返回错误结果
- **解决方案**：
  - 实现结果验证
  - 添加错误处理
  - 提供fallback机制
  - 通过Function Calling确保业务逻辑的一致性

### 9.6 AI响应速度
- **风险**：Orchestrator -> Agent -> Tool的多层架构链路较长，用户可能感觉卡顿
- **解决方案**：
  - **流式输出**：后端API支持Server-Sent Events (SSE) 或 WebSocket流式返回
  - **状态指示**：实时推送Agent当前状态（如"正在分析历史天气数据..."）
  - **前端UI反馈**：显示状态指示器和进度提示
  - **缓存机制**：对于相同查询，使用缓存结果

### 9.7 前端粒子效果性能
- **风险**：Google Maps上叠加Three.js Canvas对性能要求极高，尤其是移动端
- **解决方案**：
  - **优先使用deck.gl**：而非Three.js，deck.gl专门为地理数据可视化设计
  - **性能优化**：根据地图缩放级别动态调整粒子密度
  - **移动端降级**：降低粒子数量或使用简化效果
  - **MVP阶段**：不要一开始就追求3D粒子，优先使用deck.gl的ParticleLayer

### 9.8 Python异步编程的CPU阻塞陷阱（至关重要）
- **风险**：FastAPI是异步（Async）框架，但核心业务是密集计算（风险计算、理赔Tier计算）
  - Python的asyncio是单线程的
  - 如果在FastAPI的async def路由中直接运行复杂的for循环或Pandas计算（CPU密集型任务），整个API服务会卡死，无法响应其他用户的请求
- **解决方案**：
  - **严格隔离**：确保所有计算逻辑（Calculator）绝对不要在FastAPI的async def路由中直接运行
  - **方案A（简单）**：使用`run_in_executor`将计算扔到线程池
    - 适用于轻量级计算（< 0.5秒）
    - 使用`asyncio.get_event_loop().run_in_executor(None, compute_function, args)`
  - **方案B（推荐）**：坚决走Celery
    - 即使是"实时试算"接口，如果计算超过0.5秒，也建议通过Webhook或Polling机制异步处理
    - 或者在FastAPI中使用独立的Process Pool
  - **实现位置**：
    - API路由层：所有涉及计算引擎的API，必须异步处理
    - 计算引擎层：保持同步实现，由调用方决定执行方式（线程池或Celery）

### 9.9 时区处理（时间相对论）
- **风险**：保险业务对时间极其敏感，"每天赔付一次"的"天"需要明确时区定义
  - 场景：保单说"每天赔付一次"。这个"天"是指UTC时间的0点，还是投保人所在地的0点，还是北京时间0点？
  - 如果是台风，跨越了时区怎么办？
- **解决方案**：
  - **存储**：数据库永远存UTC时间（TIMESTAMPTZ）
  - **计算**：必须将UTC转换为**"风险发生地"的当地时间**来判定"Day"
  - **字段补充**：在policies表中明确存储timezone字段（如Asia/Shanghai）
  - **计算引擎**：在判断per day限制时，必须加载保单的timezone进行转换
    - 将UTC时间转换为风险发生地的当地时间
    - 基于当地时间判断是否属于同一时期（同一天、同一月等）
  - **示例**：
    - 保单时区：Asia/Shanghai（UTC+8）
    - UTC时间：2025-01-27 16:00:00
    - 转换为北京时间：2025-01-28 00:00:00
    - "per day"限制应基于北京时间，即2025-01-28这一天的风险事件属于同一时期
  - **跨时区处理**：如果保单覆盖多个时区，使用主要时区或按区域分别处理

### 9.10 语音交互技术风险

#### 9.10.1 WebSocket 连接稳定性
- **风险**：WebSocket 连接可能因网络波动断开，导致语音交互中断
- **解决方案**：
  - 实现自动重连机制（指数退避）
  - 维护会话状态，支持断线重连后恢复上下文
  - 使用心跳检测（Ping/Pong）保持连接活跃

#### 9.10.2 VAD 误检和延迟
- **风险**：
  - VAD 可能误检静音（用户还在说话）
  - VAD 延迟导致响应慢（用户说完后等待时间过长）
- **解决方案**：
  - 使用 Silero VAD (WebAssembly) 提高检测精度
  - 设置合理的静音阈值（如 1-2 秒）
  - 支持手动提交（用户点击"发送"按钮）

#### 9.10.3 打断处理复杂性
- **风险**：用户插嘴打断时，需要立即停止生成、清空缓冲、处理新输入，逻辑复杂
- **解决方案**：
  - 使用 `asyncio.Task.cancel()` 优雅取消正在进行的生成任务
  - 维护清晰的会话状态机（idle → listening → processing → speaking → interrupted）
  - 测试各种打断场景（说话中打断、静音中打断、生成中打断）

#### 9.10.4 Gemini Native Audio 可用性
- **风险**：Gemini Native Audio 可能不可用或有限制（地区、配额等）
- **解决方案**：
  - 实现降级方案：STT (Google Speech-to-Text) + TTS (Google Text-to-Speech)
  - 在 VoiceAdapter 中实现适配器模式，支持多种音频处理方案
  - 监控 API 可用性，自动切换方案

#### 9.10.5 响应格式器解耦
- **风险**：如果 Service 层返回格式化的 HTML/Markdown，Agent 层无法根据 channel 调整格式
- **解决方案**：
  - **强制规范**：Service 层只返回纯 JSON 数据
  - **Agent 层职责**：根据 `channel` 参数（text/voice）决定响应格式
  - **代码审查**：确保所有 Service 方法不包含格式逻辑

#### 9.10.6 语音延迟和用户体验
- **风险**：STT + Agent + TTS 的链路较长，用户可能感觉卡顿
- **解决方案**：
  - 使用 Gemini Native Audio 减少 STT 步骤
  - 实现流式 TTS，边生成边播放
  - 优化 Router Agent 的 Prompt，减少生成时间
  - 语音模式响应控制在 2 句话以内

---

## 10. 后续扩展方向

1. **用户认证系统**：支持多租户、角色权限管理
2. **实时通知**：理赔生成后通知投保人（邮件、短信）
3. **数据导入导出**：支持CSV/Excel批量导入保单
4. **报表系统**：生成保单和理赔报表
5. **移动端应用**：React Native应用
6. **更多天气类型**：温度、湿度、气压等
7. **台风预测**：集成台风轨迹预测API
8. **机器学习**：使用ML模型优化风险预测
9. **语音交互增强**：
   - 集成Google Live API（端到端语音连接，无需STT/TTS）
   - 多语言语音支持
   - 语音情感分析（识别用户情绪，优化响应语气）
10. **多模态扩展**：
    - 图像输入（上传保单截图、天气图表）
    - AR/VR可视化（3D风险地图）
    - 视频通话集成

---

**文档版本**：v2.3  
**创建日期**：2025-01-27  
**最后更新**：2025-01-12

**更新说明**：
- v2.3 (2025-01-12)：
  - **架构优化**：合并Chat Agent + Orchestrator Agent为Router Agent（减少50%延迟）
  - **引入Modality Adapter Layer**：解耦交互模态（文本/语音）与Agent逻辑，提升扩展性
  - **支持实时流式模式**：添加WebSocket支持、Voice Gateway、VAD、Gemini Native Audio
  - **响应格式器解耦**：Service层只返回纯JSON，Agent层根据channel参数决定格式
  - **语音交互设计**：完整的语音交互架构（VAD、打断处理、流式TTS）
  - **技术风险补充**：新增语音交互相关的技术风险和解决方案
  - **实施计划更新**：更新AI Agent集成阶段，新增语音交互实现阶段（可选）
- v2.2 (2025-01-27)：
  - 新增Python异步编程的CPU阻塞陷阱说明和解决方案
  - 新增时区处理机制（policies表timezone字段，计算引擎时区转换逻辑）
  - 明确"同时期"判断必须基于风险发生地的当地时间
  - 更新API设计，说明异步处理方案（run_in_executor或Celery）
  - 更新计算引擎说明，明确执行方式（同步实现，异步调用）
- v2.1 (2025-01-27)：
  - 新增数据库并发控制机制（Redis分布式锁 + 数据库行锁）
  - 新增Property-Based Testing测试策略
  - 更新前端粒子效果方案（推荐使用deck.gl而非Three.js）
  - 新增AI Agent流式输出和UI反馈机制
  - 新增风险事件表的 `prediction_run_id` 与 `prediction_runs` 表，支撑预测批次版本化（active_run 切换/回滚）
  - 完善技术风险和注意事项章节
