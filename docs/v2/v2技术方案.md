# V2 技术方案（实施指导版 / 无代码）

**文档版本**：v2.0  
**创建日期**：2026-01-14  
**最后更新**：2026-01-14  
**定位**：在 `v2页面设计提案.md`（体验/信息架构）与 `v2架构升级-全栈方案.md`（系统分层/基础设施）之间，提供可落地的“实施指导与风险规避”桥梁文档（不包含代码/伪代码）。  

> 说明：本方案刻意强调“系统级契约、模块边界、风险与护栏”，以降低后续实施返工率。项目拆解与任务计划将由后续 Agent 另行输出。

---

## 0. 相关文档（前置阅读）

- `docs/v2/v2页面设计提案.md`：页面信息架构（L0/L1/L2）、联动状态机、Access Mode（Demo/Partner/Admin）、AI Director Cues
- `docs/v2/v2架构升级-全栈方案.md`：全栈分层架构、数据库/服务/计算/AI Agent/部署
- `docs/v2/01-实现步骤总览.md`：阶段化实施顺序（用于宏观里程碑对齐）

---

## 1. 文档目标与非目标（Scope / Non-goals）

### 1.1 目标（MVP 必须满足）

- **Dashboard Workbench**：地图主舞台 + L0 Left HUD Rail（Search 下方 HUD） + Region Intelligence Panel（L1/L2）+ 顶栏全局过滤 + AI Insight（ticker + pin，导演式 CTA）
- **统一时间轴**：Weather / Risk / Claims 三泳道对齐，并可由全局时间范围与 brush 驱动联动
- **Access Mode（先设计、后实现）**：Demo/Public、Partner、Admin/Internal，贯穿前后端与 AI
- **计算隔离**：CPU 密集风险/理赔计算不得阻塞 API（轻量计算可线程池，重计算走 Celery）
- **安全底线**：敏感字段/明细必须由后端做 Mode 裁剪（禁止“前端隐藏=权限”）
- **可观测性**：关键链路可追踪（用户动作→数据请求→缓存/DB→渲染→AI 状态）

### 1.2 非目标（避免过度设计）

- 不建设“通用 BI 自助分析平台”
- 不承诺“秒级实时全量刷新”（优先准实时：缓存 + 定时刷新 + 预测批次）
- 不一开始做重型 IAM/组织架构权限（先 Mode + feature flags + 轻量认证/鉴权）

---

## 2. 一句话架构（Architecture One-liner）

这是一个面向路演与运营的“态势大屏工作台”系统：**前端以事件驱动编排（UI Orchestration）为核心**，后端以**场景化数据产品（L0/L1/L2 + Map Overlays）**为核心，并由 **Access Mode** 贯穿数据裁剪、能力开关与 AI 动作建议。

---

## 3. 体验契约上升为系统契约（必须固化的三件事）

### 3.1 L0/L1/L2 信息分层 = 三类数据产品形态（强约束）

> 关键点：L0/L1/L2 不是 UI 分区，而是三类不同的“数据产品”，决定后端查询形态、缓存/预聚合策略与权限边界。

- **L0 省级态势（全局背书）**
  - 输出：金额 KPI + Top 导航（Pareto）+ claim sparkline（趋势提示）
  - 系统含义：高频、低延迟、稳定口径；必须优先“预聚合/强缓存”
- **L1 区域态势（选中区域）**
  - 输出：概览 + 趋势 + 统一时间轴三泳道（Weather/Risk/Claims 对齐）
  - 系统含义：交互高频刷选（区域/时间/天气/产品）；要求查询可组合、缓存可复用
- **L2 证据链（Details/明细溯源）**
  - 输出：风险事件 ↔ 理赔信息关联（支持回指时间轴/地图定位）
  - 系统含义：敏感、重查询；默认按需加载；必须可裁剪/脱敏；严禁默认全量拉取

### 3.2 Access Mode（受众模式）= 信息密度与操作能力的跨层开关

建议明确为 **Access Mode**（避免与“分析模式 S3”等交互状态混淆）：

- **Demo/Public（路演默认）**
  - 目标：少数字、强可视化、强解释
  - 策略：敏感口径范围化/聚合；L2 默认隐藏或只给聚合摘要；禁用 Compare/导出/分享/保存视图等复杂能力
- **Partner（合作伙伴）**
  - 目标：可更深入对比与分析
  - 策略：开放更深 KPI 与 Top 导航/排行；L2 字段级脱敏（可配置）
- **Admin/Internal（内部）**
  - 目标：全量运营与治理
  - 策略：开放全量明细、导出、配置、对比等

**系统级约束（必须写死）**：

- Mode 不能只由前端“隐藏按钮”实现：**后端必须按 Mode 裁剪输出**（字段级/粒度级/能力级）
- Mode 必须影响：
  - **数据输出**（字段/粒度/摘要化）
  - **默认展开**（例如 Demo 默认展开 Overview+Timeline、Details 折叠/隐藏）
  - **可用动作**（Compare/导出/分享等）
  - **AI 可说内容与可建议动作**（Mode-aware）

### 3.3 AI Director Cues = “建议 + 可执行意图”的一等公民

AI 在该页面的角色不是“长对话客服”，而是 **导演式提示卡**（Insight + CTA）：

- **Insight**：一句话结论 + 证据点 + 口径说明
- **Intent（联动意图）**：例如打开面板到 `Timeline/Correlation/Details`、叠加阈值提示层、刷选时间窗、触发对比等

**系统级约束（必须写死）**：

- AI 意图不能绕过 UI 编排层直接执行：必须经过 **Orchestration + Mode/权限校验**
- AI 工具调用返回必须是**纯数据**；格式化由 Agent/前端承担（防止多通道输出失控）

---

## 4. 系统拆分（模块边界与职责）

### 4.1 前端：Dashboard Workbench（事件驱动编排）

**目标**：让联动“可预期且不打扰”，避免组件互相 setState 导致隐式副作用。

建议在顶层明确三类状态域（概念层）：

- **View State（工作台状态）**
  - region selection（hover/lock）、time range、weather type、product、layer toggles、panel snap（peek/half/full）
- **Access State（模式与能力）**
  - Access Mode + feature flags（Compare/Export/Details 等能力矩阵）
- **Server State（服务端数据）**
  - L0/L1/L2/MapOverlays 的查询结果、缓存策略、失效策略、并发合并与节流策略

**前端必踩坑与规避策略**：

- **坑：hover 触发重查询** → 地图掉帧/卡顿
  - **规避**：定义“轻交互（hover）不触发重数据拉取”的规则；只有显式 lock/CTA 才触发 L1/L2 重查询
- **坑：联动逻辑散落在多个组件** → 行为不可预测、调试困难
  - **规避**：所有联动触发统一进入 Orchestration 层（事件总线/状态机）
- **坑：用 `useEffect` 拉数据** → 请求风暴与竞态
  - **规避**：统一用 TanStack Query 管理 Server State（缓存、重试、失效、并发合并）

### 4.2 后端：从“表级 API”升级为“场景化数据产品层”

除了 OLTP 域服务（Policies/Claims/RiskEvents/Weather），必须显式建设“数据产品层”（哪怕先薄实现）：

- **接口读写分离（最优策略）**
  - 对外仅提供读路径（GET 列表/详情/统计）
  - 写入路径由任务/内部接口承担（不对外公开）
  - **内部写入能力（明确责任归属）**：
    - Policies：内部录入/修复任务
    - Risk Events：风险计算任务批量写入
    - Claims：理赔计算任务写入（仅 historical）
    - Prediction Runs：批次管理服务写入/切换

- **Dashboard Query（L0）**
  - 金额 KPI + Top 导航（Pareto）
  - 强缓存/预聚合优先
- **Region Intelligence Query（L1）**
  - Overview + 趋势 + 统一时间轴三泳道
  - 面向交互刷选优化（参数可组合、缓存可复用）
- **Evidence Query（L2）**
  - 证据链（风险事件 ↔ 理赔）支持回指
  - Mode 驱动字段裁剪/摘要化
- **Map Overlays Query**
  - 为地图提供可直接渲染的聚合数据（区域级/网格/hex 级）
  - 避免前端对海量明细二次聚合

**后端必踩坑与规避策略**：

- **坑：用一个泛 `/statistics/*` 接口拼装所有视图** → 口径漂移、缓存困难、N+1
  - **规避**：按场景提供稳定的数据产品契约（L0/L1/L2/Overlays）
- **坑：Mode 只在前端实现** → 抓包即可拿到敏感数据（重大安全风险）
  - **规避**：后端输出裁剪作为强制要求；越权请求行为一致（拒绝或返回裁剪后结果）

### 4.3 计算与任务：CPU 隔离 + 幂等 + 并发控制

**核心原则**：

- 计算逻辑保持“同步纯函数”，不直接依赖 DB Session；调用方决定线程池或 Celery
- 重任务必须走 Celery（风险事件批量、预测刷新、理赔生成、重聚合等）
- Celery 任务必须：
  - **幂等**：重复执行不会产生重复结果
  - **并发控制**：Redis 分布式锁 + 数据库事务/行锁（防止重复写入）
  - **可观测**：任务状态、耗时、失败原因可追踪

**必踩坑与规避策略**：

- **坑：把 CPU 计算塞进 FastAPI async 路由** → event loop 阻塞，整站雪崩
  - **规避**：严格隔离；轻量 <0.5s 才考虑线程池；其余 Celery
- **坑：预测数据刷新重复触发** → 重复 risk_events/claims
  - **规避**：预测批次（run id）+ 唯一约束 + 幂等写策略

### 4.4 AI 子系统：工具调用与输出治理

**关键原则**：

- Service 层返回纯 JSON 数据；Agent/前端按 channel（text/voice）渲染
- Agent 不直写 DB，只能通过后端服务工具调用
- AI 必须 Mode-aware：字段与动作建议都受 Mode 限制

**必踩坑与规避策略**：

- **坑：Prompt 注入诱导越权查询/导出** → 数据泄露
  - **规避**：工具层与服务层二次校验（不信任 LLM）；Mode/权限在服务端强制执行

---

## 5. 数据与口径（OLTP vs OLAP：轻量版也要先立规矩）

### 5.1 统一维度（贯穿所有数据产品）

建议在所有数据产品层契约中统一这些维度（否则后期无法做可复用缓存与口径一致性）：

- **region scope**：省/市/区层级（使用稳定 code，不依赖展示名）
- **time range**：存储 UTC；展示本地；业务“per day/per month”按风险地区时区判断
- **weather_type**：降雨/风/温度…（枚举化）
- **data_type**：historical / predicted
- **product**：产品 id +（必要时）版本（避免产品规则变化导致历史解释失真）

### 5.2 预测数据版本化（必须提前设计）

预测数据“会变”，同一时间点可能被多次刷新。必须有机制区分预测批次：

- 对外展示必须明确：
  - 当前预测批次（active）
  - 历史预测批次（可选保留，用于回溯/审计）
- 缓存失效必须与预测批次切换绑定（避免新旧混杂）

### 5.3 L0 Top 导航与地图叠加必须优先预聚合/强缓存

**原则**：

- L0 KPI/Top 导航（Pareto）属于“高频强交互背书”，必须优先强缓存/预聚合
- Map Overlays 优先服务端输出聚合结果（区域级/网格/hex），前端只渲染

**必踩坑与规避策略**：

- **坑：直接用明细 claims group-by 排名** → 数据量上来性能崩
  - **规避**：预聚合/缓存 + 分区/索引策略提前规划
- **坑：前端拿海量明细做二次聚合** → JS 线程吃满、地图掉帧、移动端崩
  - **规避**：Overlays 输出“可渲染聚合”，避免前端做重计算

---

## 6. Access Mode 的工程化落地（先契约，后系统）

### 6.1 Mode 裁剪维度（必须在接口契约层显式化）

- **字段级裁剪**：金额、个人/组织信息、内部 id、明细属性等
- **粒度级裁剪**：精确值 → 区间值；明细 → 聚合摘要
- **能力级裁剪**：Compare/导出/分享/保存视图/配置等

### 6.2 前后端职责分工（防止“假权限”）

- **前端**：决定默认展开与交互呈现；遵循“可见但不可用”的降级 UX（锁 + tooltip），避免演示断流
- **后端**：决定能否拿到字段/明细；对越权请求行为一致（拒绝或返回裁剪后结果）

### 6.3 AI 与 Mode（必须写入约束）

- AI 洞察口径随 Mode 调整（Demo 不输出敏感数字、Partner 可更细、Admin 全量）
- AI 动作建议必须只包含 Mode 可执行动作集合（避免“点了没用”造成断流）

---

## 7. 性能预算与降级策略（地图大屏的生死线）

### 7.1 前端性能硬约束

- Map Stage 永远是主舞台：任何 L1/L2 展开都不能让地图交互不可用
- 渐进披露：默认只加载 L0 + L1 最小集；L2 必须按需加载
- 动效/粒子：必须提供移动端/低性能设备降级路径（否则路演翻车）

### 7.2 后端性能硬约束

- 高频查询必须可缓存、可复用、可批量（减少 RTT）
- 避免 N+1：尤其 Evidence（L2）与排行（L0）
- 重计算必须异步化并可回放（支持重跑与定位）

---

## 8. 可观测性（Observability）与故障演练

### 8.1 必须可追踪的链路（最低要求）

- 用户动作（Map Click/Brush/Toggle）→ 数据产品层请求 → 缓存/DB 命中 → 响应 → 渲染完成
- AI 状态：thinking / calling_tool / generating / done 与 UI 同步
- Celery：任务入队/执行/重试/失败原因/耗时分布可见

### 8.2 推荐的验收指标（用于后续压测与验收）

- L0 首屏可用时间（TTI）与 L0 数据加载延迟
- 交互刷新延迟（切区域/刷时间/切天气类型/切产品）
- 地图帧率与渲染卡顿率（尤其移动端）
- Celery 任务耗时分布、失败率、重试次数
- 缓存命中率（按 L0/L1/L2/Overlays 维度）

---

## 9. 安全与合规（尤其 Google Maps）

### 9.1 API Key 与环境变量

- 客户端 Key 必须受限（HTTP referrer + API scope）
- 严禁硬编码；提供 `.env.example`；生产环境用密钥管理

### 9.2 Google Maps 平台合规风险点（必须在实施前核对条款）

> 本节基于 Google Maps Platform 官方政策/条款与最佳实践文档进行落地约束整理，实施前务必逐条对齐并在代码评审中作为“合规 Gate”。  
> 参考：  
> - Maps JavaScript API Policies：`https://developers.google.com/maps/documentation/javascript/policies?utm_source=gmp-code-assist`  
> - Geocoding API Policies：`https://developers.google.com/maps/documentation/geocoding/policies?utm_source=gmp-code-assist`  
> - Places API (New) Policies：`https://developers.google.com/maps/documentation/places/web-service/policies?utm_source=gmp-code-assist`  
> - Map Tiles API Policies：`https://developers.google.com/maps/documentation/tile/policies?utm_source=gmp-code-assist`  
> - Maps Service Specific Terms：`https://cloud.google.com/maps-platform/terms/maps-service-terms`  
> - API Security Best Practices：`https://developers.google.com/maps/api-security-best-practices?utm_source=gmp-code-assist`  
> - Maps FAQ（map loads、限流与监控）：`https://developers.google.com/maps/faq?utm_source=gmp-code-assist`  
> - Maps JS API Loading（Dynamic import / js-api-loader）：`https://developers.google.com/maps/documentation/javascript/load-maps-js-api?utm_source=gmp-code-assist`

#### 9.2.1 Attribution（署名）与内容区分

- **不得移除/遮挡/弱化 Google Maps attribution**。如果内容显示在 Google Map 上且 attribution 已可见，通常无需额外添加；但如果在非 Google 地图或自定义 UI 中展示 Google Maps Platform 内容，需要确保 attribution 清晰可见（Maps JS API Policies）。  
- **UI 上必须清晰区分“Google Maps Platform 内容”与“自有内容”**：例如用边框、背景、阴影或留白做视觉区分（Maps JS API Policies）。  
- **Logo vs 文本**：空间允许优先用 Google Maps logo；空间不足可用 “Google Maps” 文本，但需确保用户明确哪些内容来自 Google Maps（Maps JS API Policies）。

#### 9.2.2 缓存/预取/存储（Caching / Prefetch / Storage）

- **总体原则**：除条款明确允许的有限情形外，不得预取、索引、存储或缓存 Google Maps Content（Maps Service Specific Terms；Map Tiles API Policies）。  
- **Place ID 例外**：多份政策文档明确指出 **place ID 可长期存储**（Places API (New) Policies；Geocoding/Maps JS Policies 同样引用该例外）。  
- **lat/lng 的临时缓存**：Maps Service Specific Terms 对部分服务允许“lat/lng 临时缓存 30 天”并要求到期删除（例如 Places API、Routes API 等条款段落）；因此如果我们在后端缓存地理编码/地点解析结果，必须以“可审计的 TTL”强制过期。  
- **Map Tiles API（如未来使用）**：响应可能包含 `Cache-Control` 与 `ETag`，客户端缓存必须遵循 HTTP 协议与响应指令（Map Tiles API Policies）。  
- **工程落地约束（建议写入代码评审清单）**：
  - 任何“缓存 Google 返回内容”的行为都必须标注：来源 API、缓存字段集合、TTL、失效策略与合规依据（指向上述政策/条款链接）。
  - 严禁以“离线地图/批量抓取/内容爬取”方式使用 Maps 内容（Maps JS API Policies 中的 scraping 提示；Map Tiles API Policies 中的预取/离线限制）。

#### 9.2.3 API Key 安全（必须执行）

- **必须启用 Key 限制**：对 Web 前端 Key 使用 **HTTP Referrer 限制**；并对 Key 进行 **API 限制**（只允许实际用到的 APIs），以降低被盗用后的爆账风险（API Security Best Practices）。  
- **细化到本项目**：
  - 前端 Key：限制到站点域名（HTTP Referrer），并仅允许 Maps JavaScript API（以及确实需要的库/能力对应的 API）。  
  - 后端（如调用 Geocoding/Places Web Service）：应使用服务端 Key（IP 限制）并同样做 API 限制（API Security Best Practices；Maps FAQ 的 key/credentials 说明）。
- **authReferrerPolicy**：Maps JS API 加载参数支持通过 `authReferrerPolicy` 降低 referrer 数据外泄，并与 Cloud Console 的 referrer 限制协同（Maps JS API Loading 文档）。

#### 9.2.4 Maps JS API 加载方式（性能与稳定性）

- **推荐 Dynamic Library Import / js-api-loader**：支持按需加载库，避免重复加载，并提升首屏性能（Maps JS API Loading 文档；`@googlemaps/js-api-loader` 说明）。  
- **版本策略**：Maps JS API 支持通过 `v` 参数选择版本（例如 `weekly`），需在技术方案中固定版本策略并在上线时可控升级（Maps JS API Loading 文档）。

#### 9.2.5 成本、配额与限流（避免“突然爆账/被限流”）

- **Map load 计费认知**：Maps FAQ 说明“地图加载计费”的触发点，以及交互（平移/缩放/切图层）不会产生额外 map load；这会影响我们对“多地图实例/切换视图”设计的成本评估。  
- **配额与监控**：Maps FAQ 给出在 Cloud Console 里查看 Metrics/Quotas 的路径，并建议设置 quota limit/预算以防止意外开销。  
- **工程约束**：
  - 对 Geocoding / Places 等高成本 API：必须有调用频控（前端防抖、后端限流）、缓存（合规 TTL）与失败降级（提示/重试策略）。
  - 必须建立“用量突增告警 + 预算上限策略”，避免演示/路演场景流量异常导致不可控支出（Maps FAQ）。

#### 9.2.6 EEA Terms（如适用）

- 若项目 Billing Address 在 EEA，需要遵循 EEA 专属条款与功能限制（Maps JS API Policies 的 EEA 提示；Maps Service Specific Terms）。上线前应由负责人确认 Billing 区域并记录在文档中。

### 9.3 数据敏感分级（最低要求）

- Claims/Policies 明细属于敏感数据：Demo/Public 下必须彻底裁剪（禁止通过接口拿到全量）
- 导出能力必须强审计/强授权（即使后续才实现，也要预留）

---

## 10. 测试策略（专打最容易踩的坑）

### 10.1 口径一致性测试

- 同一筛选条件下：L0 KPI、L1 时间轴汇总、L2 证据链摘要不得互相矛盾
- predicted 批次切换：前端/AI 不应混用不同批次数据

### 10.2 计算引擎性质测试（强烈建议）

- 金额与比例全程 Decimal（避免浮点误差）
- 理赔总赔付不超过 100%（或不超过保额）等不变量
- 时区边界（跨日/月）与“per day/per month”限制

### 10.3 并发与幂等测试

- Celery 重试/重复触发不会产生重复 claims/risk events
- 锁失效/超时/任务中断的恢复策略（至少做到可重试且不重复写）

---

## 11. 风险清单（按“概率×影响”排序）与规避策略

### 11.1 P0（最高优先级）

1) **Mode 只在前端隐藏导致敏感数据泄露**  
- 规避：后端输出裁剪强制执行；接口层统一鉴权与裁剪；日志审计越权请求

2) **CPU 计算阻塞 FastAPI event loop 导致雪崩**  
- 规避：轻量线程池、重任务 Celery；计算逻辑与 DB 解耦；压测验证

3) **预测数据刷新导致数据不一致/混批次**  
- 规避：预测批次版本化；缓存与批次绑定；前端/AI 显式显示当前批次

4) **L0 Top 导航与地图叠加用 OLTP 明细硬扛导致性能崩**  
- 规避：场景化数据产品层 + 预聚合/强缓存；Overlays 服务端聚合

### 11.2 P1（高优先级）

5) **联动逻辑散落导致竞态/请求风暴**  
- 规避：前端 Orchestration 统一入口；TanStack Query 统一 Server State；节流与去抖策略

6) **AI 动作建议越权或不可执行导致断流**  
- 规避：Intent 必须过 Mode/权限校验；AI 输出动作集合与 Mode 绑定

7) **时区导致“per day/per month”判断错误**  
- 规避：UTC 存储；按风险地区时区判定“同一天/同一月”；增加边界测试

### 11.3 P2（中优先级）

8) **地图粒子/动效移动端掉帧导致现场演示失败**  
- 规避：明确移动端降级；按缩放/性能动态降载；提供“关闭特效”开关（可受 Mode 控制）

9) **缓存失效策略错误导致展示陈旧/错口径**  
- 规避：以数据产品维度定义失效；与预测批次/时间范围绑定；关键路径提供强制刷新入口（受权限控制）

---

## 12. 系统约定（Conventions / System Contracts）

> 目的：为后续任务拆解提供“统一语言”，避免不同模块对 region/time/weather/product/mode 的命名与口径漂移，导致缓存错口径与数据不一致。

### 12.1 关键概念的命名与正交关系（必须统一）

- **Access Mode（受众模式）**：Demo/Public、Partner、Admin/Internal（跨层：前端能力、后端裁剪、AI 动作/话术）
- **UI State（交互状态机）**：默认态/锁定态/面板打开态/分析态（体验层状态，不等同于权限）
- **Data Type**：historical / predicted（数据来源与稳定性不同）
- **Weather Type**：rain / wind / temperature / ...（必须枚举化）
- **Region Scope**：province / district / ...（必须有稳定 code，不依赖展示名）
- **Prediction Run（预测批次）**：用于标识 predicted 数据的“当前批次/历史批次”，避免解释断裂

> 强制要求：任何一个模块在讨论“模式/状态/批次”时，必须使用上述概念，禁止混用与模糊描述（例如把“分析态”当成权限、把“预测数据”当成单一真值）。

### 12.2 统一维度与它们出现的位置（减少口径漂移）

这些维度必须在以下位置保持一致（维度缺失会导致“缓存命中但口径错误”）：

- **前端 View State**：region、time range、weather_type、product、layer toggles
- **前端 Access State**：access_mode、feature flags（能力矩阵）
- **数据产品层请求**：region scope、time range、weather_type、data_type、product、prediction_run_id、access_mode
- **缓存 key**：必须至少包含会改变口径/结果集的维度（例如 access_mode 与 prediction_run_id）
- **可观测性字段**：trace_id / correlation_id + 关键维度（便于定位“为何不一致”）

### 12.3 缓存 Key 约束（避免“命中即错口径”）

- 缓存 key 的组成必须包含：**region + time range + weather_type + data_type + product + access_mode**  
- 对 predicted 数据：缓存 key 必须额外包含 **prediction_run_id**（或包含 “active_run 标识”）
- 任何省略维度的缓存，都必须在文档中说明“为何不会导致口径变化”（否则一律视为风险）

### 12.4 观测事件命名与必带字段（无代码约定）

为了让后续排障可执行，建议统一事件命名与必带字段（可在实施时落地到日志/埋点/Tracing）：

- **前端交互事件（示例命名）**：map_hover、map_lock、pareto_click、time_range_change、timeline_brush、weather_type_toggle、layer_toggle、panel_snap_change、ai_insight_click、ai_cta_click
- **后端数据产品事件（示例命名）**：dp_l0_dashboard_query、dp_l1_region_intelligence_query、dp_l2_evidence_query、dp_overlays_query
- **任务事件（示例命名）**：task_weather_sync、task_risk_recalc_predicted、task_claim_calc、task_aggregate_refresh
- **AI 事件（示例命名）**：ai_tool_call、ai_intent_proposed、ai_intent_blocked_by_mode、ai_intent_executed

建议所有事件至少携带：

- trace_id / correlation_id
- access_mode
- region_code（若有）
- time range（若有）
- weather_type / data_type（若有）
- product_id（若有）
- prediction_run_id（predicted 场景）

---

## 13. 数据产品目录（Data Product Catalog）

> 目的：把 L0/L1/L2/Overlays 变成“可交付对象”，为后续任务拆解提供稳定的后端/前端对接边界（不涉及具体路由）。

> 说明：SLO 为建议值，后续应按数据规模与成本预算调整；但必须有明确目标，否则无法验收“体验是否达标”。

| 数据产品 | 对应信息层 | 主要目的 | 输入维度（最小集合） | 输出类型 | Mode 影响 | 缓存建议 | 建议 SLO（示例） |
|---|---|---|---|---|---|---|---|
| L0 Dashboard（省级态势） | L0 | “10 秒内一眼看到态势”：金额 KPI + Top 导航（Pareto） + claim sparkline（提示） | region=province、time_range、data_type、weather_type（可选）、access_mode、prediction_run_id（predicted） | 聚合 + Top 导航 | Demo 需范围化/隐藏敏感口径；Partner 更细；Admin 全量 | 强缓存/预聚合优先；predicted 与 run 绑定失效 | p95 < 500ms（缓存命中）；新鲜度可容忍分钟级 |
| L1 Region Intelligence（区域情报） | L1 | “可解释”：Overview + 趋势 + 统一时间轴三泳道 | region（选中区域）、time_range、data_type、weather_type、product、access_mode、prediction_run_id（predicted） | 时间序列 + 轻量聚合 | Demo 隐藏/摘要化部分指标；明细字段裁剪 | 缓存可复用（按维度）；brush 高频需节流 | p95 < 1.5s；交互刷新稳定优先 |
| L2 Evidence（证据链） | L2 | “可追溯”：风险事件 ↔ 理赔信息关联（回指时间轴） | region、time_range、data_type、weather_type、product、access_mode、prediction_run_id（predicted） | 明细/半明细 + 关联 | Demo 默认隐藏或仅摘要；Partner 字段脱敏；Admin 全量 | 默认不预取；按需加载；强制 Mode 裁剪 | p95 < 2.5s（可接受） |
| Map Overlays（地图叠加） | Map | 可视化友好：直接渲染的聚合结果 + legend 元信息 | region_scope（province/district）、time_range、data_type、weather_type、product（可选）、access_mode、prediction_run_id（predicted） | 渲染聚合（区域/网格/hex） | Demo 避免暴露敏感金额粒度；必要时只出强弱 | 强缓存；与地图交互节流；按缩放级别可分层 | p95 < 800ms（命中）；地图不掉帧优先 |

---

## 14. 联动矩阵（高层版：交互 → 数据产品）

> 目的：让拆解时清晰知道“哪个交互触发什么数据”，并把性能红线写死（例如 hover 不触发重请求）。

| Trigger（用户/系统事件） | 允许触发的数据产品 | 必须遵守的限制 | 典型用途 |
|---|---|---|---|
| Map Hover（轻） | 不触发 L1/L2；可使用本地已加载的轻量 tooltip | **禁止**发起重查询；禁止刷新排行/时间轴 | 轻提示（≤3 指标） |
| Map Click Lock / Pareto Click（重） | L1（必要时预取 L2 摘要） | 锁定后再加载；保持地图主舞台；避免并发风暴；Pareto Click 默认不自动展开面板 | 选区锁定、联动刷新 |
| AI Insight Click / AI CTA（显式下钻） | L2（按 Mode 裁剪） | 必须 Mode 校验；Demo 默认摘要化；打开面板到 Half 并定位 section | 打开证据链/定位小节 |
| Global Time Range Change | L0 + L1 + Overlays（节流）；L2 视打开状态决定 | predicted 场景必须携带 prediction_run_id；避免重算 | 全局刷新 |
| Timeline Brush（底部） | L1（主）；Overlays（可选） | 高频交互必须节流；避免每像素一次请求 | 聚焦时间窗 |
| Weather Type Toggle | L0/L1/Overlays（按口径需要） | 若产品不支持该天气类型：必须有降级/提示；避免混口径 | 切换天气叙事 |
| Layer Toggles | Overlays（可选）；一般不触发 L2 | 禁止因为开关导致全量明细加载 | 图层可见性 |
| Panel Snap（Peek/Half/Full） | 不应触发额外数据（除非进入 L2 明细页） | 交互仅改变呈现，不应引发重计算 | 体验节奏控制 |

---

## 15. 预测批次一致性模型（Predicted Consistency Model）

> 目的：避免 predicted 数据“刷新后解释断裂”，以及缓存与 AI 引用新旧混杂。

### 15.1 核心定义

- **prediction_run_id**：一次预测刷新（数据同步/重算）生成的批次标识
- **active_run**：当前对外展示的预测批次（前端/后端/AI 必须一致）

### 15.2 刷新传播链（必须闭环）

预测数据更新至少应形成以下闭环（否则会出现 UI/AI 解释与数据不一致）：

1. 预测天气数据更新（外部同步或内部生成）
2. 基于该批次重算 predicted 风险事件（必要时也影响理赔推演）
3. 刷新/失效 L0/L1/Overlays 的缓存（与 prediction_run_id 绑定）
4. 前端与 AI 在展示层明确当前批次（active_run），并避免引用历史批次的缓存

### 15.3 回滚与保留策略（防止“坏批次上线”）

- 建议保留至少 1 个上一批次用于回滚（保留时长按存储与合规策略确定）
- 回滚必须是“切换 active_run”，而不是直接覆盖历史数据（避免审计困难）

---

## 16. Google Maps 合规 Gate Checklist（可执行清单）

> 目的：把 9.2 的原则转成“PR/上线 gate”，让后续拆解/实现阶段可检查、可审计。

参考：  
- `https://developers.google.com/maps/documentation/javascript/policies?utm_source=gmp-code-assist`  
- `https://cloud.google.com/maps-platform/terms/maps-service-terms`  
- `https://developers.google.com/maps/api-security-best-practices?utm_source=gmp-code-assist`  
- `https://developers.google.com/maps/faq?utm_source=gmp-code-assist`

### 16.1 Key 管理与限制（dev/stage/prod）

- [ ] 前端 Key 使用 **HTTP Referrer** 限制，且仅授权必要 APIs（最小权限）
- [ ] 后端（若调用 Web Service APIs）使用服务端 Key（如 IP 限制）并做 API 限制
- [ ] Key 仅通过环境变量注入；仓库内仅提供 `.env.example`（无真实 key）
- [ ] 预算上限与配额监控已设置（避免异常流量爆账）

### 16.2 允许缓存/必须 TTL 的内容（示例表，实施时需落实到配置）

> 注意：此表用于“架构约束”，具体字段集合与 TTL 必须以政策/条款为准并在实现中可审计。

| 内容 | 是否允许缓存 | 期限/约束 | 依据 |
|---|---|---|---|
| place_id | ✅ 允许长期存储 | 可长期保存 | Policies 中的 caching exceptions（Places/Geocoding/Maps JS） |
| lat/lng（来自部分服务） | ✅ 允许临时缓存 | 通常 30 天，期满删除 | Maps Service Specific Terms（不同服务条款段落） |
| 地图瓦片/地图内容（离线/预取） | ❌ 禁止 | 不得预取/离线/抓取 | Policies/Terms |

### 16.3 禁止项（零容忍）

- [ ] 不得移除/遮挡/弱化 attribution
- [ ] 不得以离线、批量抓取、内容爬取方式处理 Maps 内容
- [ ] 不得在不允许的场景对 Google Maps Content 做衍生存储/导出

### 16.4 成本与限流（避免“爆账/被限流/路演翻车”）

- [ ] 对 Geocoding/Places 等高成本调用做前端防抖 + 后端限流
- [ ] 对“地图实例数量/切换视图”做 map load 成本评估（Maps FAQ）
- [ ] 用量突增告警 + 预算上限策略已就绪

---

## 17. 验收门槛（Go/No-Go）

> 目的：把“原则”变成可验收门槛，拆解时每个模块都有明确交付标准。下列为建议值，可按数据规模调整，但必须显式写出并达成一致。

### 17.1 功能闭环（必须）

- [ ] Demo/Public 模式下可完成：L0 → 选区锁定 → L1 Timeline →（可选）L2 摘要证据链
- [ ] Partner/Admin 模式下可完成：L2 证据链按 Mode 规则展示（脱敏/全量）
- [ ] AI Insight（ticker + pin）在各 Mode 下：
  - 只输出该 Mode 可展示口径
  - 只建议该 Mode 可执行动作
  - 动作执行必须经 Orchestration + Mode 校验

### 17.2 口径一致性（必须）

- [ ] 同一筛选条件下：L0 KPI、L1 时间轴汇总、L2 证据链摘要自洽，不出现互相矛盾
- [ ] predicted 场景下：active_run 一致；缓存与 AI 不得混用不同批次

### 17.3 性能与体验（必须）

- [ ] L0 Dashboard：缓存命中时 p95 延迟达到目标（建议 < 500ms）
- [ ] L1 Region Intelligence：交互刷新稳定（建议 p95 < 1.5s，且不影响地图交互）
- [ ] Overlays：地图切换图层/范围时不掉帧（需设定 FPS/卡顿率门槛）
- [ ] hover 不触发重请求（以埋点/日志验证）

### 17.4 安全与合规（必须）

- [ ] Mode 裁剪不可绕过（抓包/接口直调无法拿到 Demo 禁止的字段/明细）
- [ ] Google Maps 合规 Gate Checklist（第 16 节）全部通过

### 17.5 可靠性（必须）

- [ ] Celery 关键任务具备幂等与并发控制验证（重复触发不产生重复写）
- [ ] 预测刷新链路闭环（第 15 节）可被观测与回滚

---

## 18. 配置与发布治理（Mode / Feature Flags / Defaulting）

> 目的：Mode 是跨层契约，必须有“来源、默认值、审计、回滚”四件事，否则后续拆解会陷入无穷分支。

### 18.1 Access Mode 默认值与切换来源

- 默认 Mode 建议为 **Demo/Public**
- Mode 的来源建议明确为一种“可审计的配置来源”（例如环境配置/后端配置中心），并在前端启动时获取
- Mode 切换必须记录：操作者、时间、原因、影响范围（便于审计与复盘）

### 18.2 Feature Flags（能力矩阵）的版本化与回滚

- 能力矩阵建议版本化（避免不同环境/不同版本口径不一致）
- 灰度开关必须可回滚（尤其涉及 L2 明细、导出、对比等高风险能力）

---

## 19. 推荐目录结构（便于后续拆解与引用）

你后续若要把本文做成稳定“工程基线”，建议目录保持如下（便于引用定位）：

1. 背景与目标  
2. 范围与非目标  
3. 体验契约 → 系统契约（L0/L1/L2、Mode、AI Intent）  
4. 模块边界（前端/后端/计算/AI）  
5. 数据与口径（含 predicted 版本化）  
6. Access Mode（裁剪维度、前后端职责、AI 约束）  
7. 性能预算与降级策略（前端/后端）  
8. 可观测性与运维  
9. 安全与合规（含 Google Maps）  
10. 测试策略  
11. 风险清单与规避  
12. 系统约定（Conventions）  
13. 数据产品目录（Data Product Catalog）  
14. 联动矩阵（高层版）  
15. 预测批次一致性模型  
16. Google Maps 合规 Gate Checklist  
17. 验收门槛（Go/No-Go）  
18. 配置与发布治理  

---

## 20. 下一步（不做拆解，仅给方向）

- 由后续 Agent 产出：模块级实施拆解（每模块：职责/输入/输出/依赖/验收/风险）
- 建议在拆解前先确认（作为共识会议输出）：
  - Data Product Catalog 的 SLO 与缓存策略是否接受
  - Mode/Feature Flags 的默认值与治理流程
  - predicted 批次的一致性与回滚策略

