# 全栈架构升级方案

**文档版本**：v1.0  
**创建日期**：2025-01-27  
**目标**：将纯前端应用升级为全栈应用，支持保单管理、理赔计算、统计展示和AI Agent集成

---

## 1. 架构总览

### 1.1 架构模式
采用**前后端分离**的微服务架构，支持水平扩展和模块化开发。

```
┌─────────────────────────────────────────────────────────────┐
│                        前端层 (Frontend)                      │
│  React 19 + TypeScript + Vite + Tailwind CSS                │
│  - 地图可视化（Google Maps + 粒子效果）                       │
│  - 数据面板（统计、图表）                                     │
│  - AI对话界面（Google Contextual View）                      │
└─────────────────────────────────────────────────────────────┘
                            ↕ HTTP/WebSocket
┌─────────────────────────────────────────────────────────────┐
│                      API网关层 (API Gateway)                  │
│  FastAPI (Python) - 统一入口、认证、限流                      │
└─────────────────────────────────────────────────────────────┘
                            ↕
        ┌───────────────────┼───────────────────┐
        ↓                   ↓                   ↓
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│  业务服务层   │  │  计算服务层   │  │  AI Agent层   │
│  (Services)  │  │  (Compute)   │  │  (Agents)    │
│              │  │              │  │              │
│ - 保单服务   │  │ - 风险计算   │  │ - 对话Agent  │
│ - 理赔服务   │  │ - 理赔计算   │  │ - 查询Agent  │
│ - 统计服务   │  │ - 天气计算   │  │ - 预测Agent  │
└──────────────┘  └──────────────┘  └──────────────┘
        ↓                   ↓                   ↓
┌─────────────────────────────────────────────────────────────┐
│                      数据层 (Data Layer)                      │
│  PostgreSQL + PostGIS (地理空间数据)                          │
│  Redis (缓存)                                                │
│  Celery + Redis (任务队列)                                   │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 技术栈选型

#### 前端技术栈（保持现有）
- **框架**：React 19 + TypeScript
- **构建工具**：Vite
- **样式**：Tailwind CSS
- **动画**：Framer Motion + Three.js（粒子效果）
- **地图**：Google Maps JavaScript API
- **AI界面**：Google Contextual View AI kit
- **图表**：Recharts

#### 后端技术栈（新增）
- **框架**：FastAPI (Python 3.10+)
- **数据库**：PostgreSQL 15+ + PostGIS 3.3+
- **缓存**：Redis 7+
- **任务队列**：Celery 5.3+ + Redis
- **ORM**：SQLAlchemy 2.0+ + GeoAlchemy2
- **数据验证**：Pydantic 2.0+
- **AI Agent**：Google ADK (Agent Development Kit)

#### 基础设施
- **容器化**：Docker + Docker Compose
- **部署**：支持云部署（GCP/AWS/Azure）
- **监控**：Prometheus + Grafana（可选）

---

## 2. 数据库设计

### 2.1 核心表结构

#### 2.1.1 保单表 (policies)
```sql
CREATE TABLE policies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    policy_number VARCHAR(50) UNIQUE NOT NULL,
    product_id VARCHAR(50) NOT NULL,  -- 关联产品ID
    product_name VARCHAR(200) NOT NULL,
    policyholder_name VARCHAR(200) NOT NULL,
    policyholder_email VARCHAR(255) NOT NULL,
    coverage_region JSONB NOT NULL,  -- {country, province, district}
    coverage_start TIMESTAMPTZ NOT NULL,
    coverage_end TIMESTAMPTZ NOT NULL,
    coverage_amount DECIMAL(15, 2) NOT NULL,  -- 保额（使用DECIMAL避免浮点误差）
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- 地理空间索引（使用PostGIS）
    CONSTRAINT valid_coverage_dates CHECK (coverage_end > coverage_start)
);

-- 索引
CREATE INDEX idx_policies_product_id ON policies(product_id);
CREATE INDEX idx_policies_coverage_dates ON policies(coverage_start, coverage_end);
CREATE INDEX idx_policies_region ON policies USING GIN(coverage_region);
```

#### 2.1.2 理赔单表 (claims)
```sql
CREATE TABLE claims (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    policy_id UUID NOT NULL REFERENCES policies(id) ON DELETE CASCADE,
    claim_number VARCHAR(50) UNIQUE NOT NULL,
    risk_event_id UUID,  -- 关联风险事件（可选）
    tier_level VARCHAR(10) NOT NULL,  -- 'tier1', 'tier2', 'tier3'
    payout_percentage DECIMAL(5, 2) NOT NULL,  -- 赔付百分比（如2.00, 8.00）
    payout_amount DECIMAL(15, 2) NOT NULL,  -- 理赔金额
    trigger_timestamp TIMESTAMPTZ NOT NULL,  -- 触发时间
    calculated_at TIMESTAMPTZ DEFAULT NOW(),  -- 计算时间
    status VARCHAR(20) DEFAULT 'generated',  -- 'generated', 'approved', 'rejected'
    
    -- 确保理赔金额 = 保额 * 赔付百分比
    CONSTRAINT valid_payout CHECK (payout_amount >= 0 AND payout_percentage >= 0)
);

-- 索引
CREATE INDEX idx_claims_policy_id ON claims(policy_id);
CREATE INDEX idx_claims_trigger_timestamp ON claims(trigger_timestamp);
CREATE INDEX idx_claims_status ON claims(status);
CREATE INDEX idx_claims_tier_level ON claims(tier_level);
```

#### 2.1.3 风险事件表 (risk_events)
```sql
CREATE TABLE risk_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    product_id VARCHAR(50) NOT NULL,
    region JSONB NOT NULL,  -- {country, province, district}
    timestamp TIMESTAMPTZ NOT NULL,
    data_type VARCHAR(20) NOT NULL,  -- 'historical' or 'predicted'
    weather_type VARCHAR(20) NOT NULL,  -- 'rainfall', 'wind', 'temperature', etc.
    tier_level VARCHAR(10) NOT NULL,  -- 'tier1', 'tier2', 'tier3'
    trigger_value DECIMAL(10, 2) NOT NULL,  -- 触发时的累计值
    threshold_value DECIMAL(10, 2) NOT NULL,  -- 触发的阈值
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- 唯一约束：同一产品、区域、时间、天气类型、tier级别只能有一条记录
    CONSTRAINT unique_risk_event UNIQUE (product_id, region, timestamp, weather_type, tier_level)
);

-- 索引
CREATE INDEX idx_risk_events_product_id ON risk_events(product_id);
CREATE INDEX idx_risk_events_timestamp ON risk_events(timestamp);
CREATE INDEX idx_risk_events_region ON risk_events USING GIN(region);
CREATE INDEX idx_risk_events_weather_type ON risk_events(weather_type);
```

#### 2.1.4 历史天气数据表 (historical_weather_data)
```sql
CREATE TABLE historical_weather_data (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    region JSONB NOT NULL,  -- {country, province, district}
    timestamp TIMESTAMPTZ NOT NULL,
    weather_type VARCHAR(20) NOT NULL,  -- 'rainfall', 'wind', 'temperature', etc.
    value DECIMAL(10, 2) NOT NULL,
    unit VARCHAR(10) NOT NULL,  -- 'mm', 'kmh', 'celsius', etc.
    data_source VARCHAR(50) DEFAULT 'mock',  -- 'mock', 'api', 'manual'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- 唯一约束：同一区域、时间、天气类型只能有一条记录
    CONSTRAINT unique_weather_data UNIQUE (region, timestamp, weather_type)
);

-- 索引（时序数据优化）
CREATE INDEX idx_weather_data_region_timestamp ON historical_weather_data(region, timestamp);
CREATE INDEX idx_weather_data_weather_type ON historical_weather_data(weather_type);
CREATE INDEX idx_weather_data_timestamp ON historical_weather_data(timestamp);
```

### 2.2 数据关系图

```
policies (保单)
    ├── claims (理赔单) [1:N]
    └── risk_events (风险事件) [间接关联，通过product_id和region]

risk_events (风险事件)
    ├── historical_weather_data (历史天气数据) [间接关联，通过region和timestamp]
    └── claims (理赔单) [可选关联]

historical_weather_data (历史天气数据)
    └── risk_events (风险事件) [间接关联]
```

### 2.3 数据迁移策略

1. **初始数据导入**：使用 Alembic 管理数据库迁移
2. **Mock数据生成**：提供数据生成脚本，支持批量导入
3. **数据备份**：定期备份策略（建议每日）

---

## 3. 后端服务设计

### 3.1 服务架构

```
backend/
├── app/
│   ├── __init__.py
│   ├── main.py                 # FastAPI应用入口
│   ├── config.py               # 配置管理
│   ├── database.py             # 数据库连接
│   │
│   ├── api/                    # API路由
│   │   ├── __init__.py
│   │   ├── v1/
│   │   │   ├── __init__.py
│   │   │   ├── policies.py     # 保单API
│   │   │   ├── claims.py        # 理赔API
│   │   │   ├── statistics.py   # 统计API
│   │   │   ├── weather.py      # 天气数据API
│   │   │   └── risk_events.py  # 风险事件API
│   │   └── agents.py            # AI Agent API
│   │
│   ├── services/               # 业务逻辑层
│   │   ├── __init__.py
│   │   ├── policy_service.py   # 保单服务
│   │   ├── claim_service.py    # 理赔服务
│   │   ├── statistics_service.py # 统计服务
│   │   └── weather_service.py  # 天气数据服务
│   │
│   ├── compute/                 # 计算引擎
│   │   ├── __init__.py
│   │   ├── risk_calculator.py  # 风险计算引擎
│   │   ├── claim_calculator.py  # 理赔计算引擎
│   │   └── weather_calculator.py # 天气数据计算
│   │
│   ├── agents/                 # AI Agent层
│   │   ├── __init__.py
│   │   ├── orchestrator.py     # Agent编排器
│   │   ├── dialogue_agent.py   # 对话Agent
│   │   ├── query_agent.py      # 查询Agent
│   │   ├── prediction_agent.py # 预测Agent
│   │   └── tools/               # Agent工具集
│   │       ├── policy_tools.py
│   │       ├── claim_tools.py
│   │       └── statistics_tools.py
│   │
│   ├── models/                  # 数据模型（SQLAlchemy）
│   │   ├── __init__.py
│   │   ├── policy.py
│   │   ├── claim.py
│   │   ├── risk_event.py
│   │   └── weather_data.py
│   │
│   ├── schemas/                 # Pydantic模型（API请求/响应）
│   │   ├── __init__.py
│   │   ├── policy.py
│   │   ├── claim.py
│   │   ├── statistics.py
│   │   └── weather.py
│   │
│   ├── tasks/                   # Celery任务
│   │   ├── __init__.py
│   │   ├── claim_calculation.py # 理赔计算任务
│   │   └── weather_sync.py     # 天气数据同步任务
│   │
│   └── utils/                   # 工具函数
│       ├── __init__.py
│       ├── decimal_utils.py    # Decimal工具（金融计算）
│       ├── time_utils.py        # 时间处理
│       └── region_utils.py     # 区域处理
│
├── alembic/                     # 数据库迁移
│   ├── versions/
│   └── env.py
│
├── tests/                       # 测试
│   ├── unit/
│   ├── integration/
│   └── e2e/
│
├── scripts/                     # 脚本
│   ├── generate_mock_policies.py
│   ├── generate_mock_weather.py
│   └── seed_data.py
│
├── requirements.txt
├── Dockerfile
└── docker-compose.yml
```

### 3.2 核心服务实现

#### 3.2.1 理赔计算服务 (claim_calculator.py)

```python
"""
理赔计算引擎
实现tier差额逻辑：
- tier 1: 2% 保额
- tier 2: 8% 保额（与tier 1的差额）
- tier 3: 更高差额（与tier 2的差额）
"""

from decimal import Decimal
from typing import List, Dict
from datetime import datetime, timezone
from sqlalchemy.orm import Session

from app.models.policy import Policy
from app.models.claim import Claim
from app.models.risk_event import RiskEvent
from app.compute.risk_calculator import RiskCalculator
from app.services.policy_service import PolicyService


class ClaimCalculator:
    def __init__(self, db: Session):
        self.db = db
        self.risk_calculator = RiskCalculator(db)
        self.policy_service = PolicyService(db)
    
    def calculate_claims_for_policy(
        self,
        policy_id: str,
        risk_events: List[RiskEvent]
    ) -> List[Claim]:
        """
        为保单计算理赔单
        
        逻辑：
        1. 获取保单信息
        2. 获取产品配置（payoutRules）
        3. 对每个风险事件，计算是否需要生成理赔单
        4. 实现tier差额逻辑
        """
        policy = self.policy_service.get_policy(policy_id)
        if not policy:
            raise ValueError(f"Policy {policy_id} not found")
        
        # 获取产品配置
        product = self.policy_service.get_product(policy.product_id)
        payout_rules = product.payout_rules
        
        # 获取该保单已有的理赔单（用于判断是否需要生成新理赔单）
        existing_claims = self._get_existing_claims(policy_id)
        
        new_claims = []
        
        for risk_event in risk_events:
            # 检查风险事件是否在保单保障期内
            if not self._is_in_coverage_period(risk_event, policy):
                continue
            
            # 检查是否已存在该时间点的理赔单
            if self._has_existing_claim(existing_claims, risk_event):
                continue
            
            # 计算理赔金额（tier差额逻辑）
            claim = self._calculate_claim_amount(
                policy, risk_event, payout_rules, existing_claims
            )
            
            if claim:
                new_claims.append(claim)
        
        return new_claims
    
    def _calculate_claim_amount(
        self,
        policy: Policy,
        risk_event: RiskEvent,
        payout_rules: Dict,
        existing_claims: List[Claim]
    ) -> Claim:
        """
        计算理赔金额，实现tier差额逻辑
        
        规则：
        - 如果当前是tier 1，且没有tier 1理赔单，则生成2%保额的理赔单
        - 如果当前是tier 2，且已有tier 1理赔单，则生成8%保额的理赔单（差额）
        - 如果当前是tier 3，且已有tier 2理赔单，则生成更高差额的理赔单
        """
        tier = risk_event.tier_level
        payout_percentages = payout_rules['payoutPercentages']
        
        # 获取该时间点已有的最高tier理赔单
        existing_tier = self._get_highest_existing_tier(
            existing_claims, risk_event.timestamp
        )
        
        if tier == 'tier1':
            if existing_tier is None:
                # 首次触发tier 1，生成2%保额理赔单
                payout_percentage = Decimal('2.00')
            else:
                # 已有理赔单，不重复生成
                return None
        
        elif tier == 'tier2':
            if existing_tier == 'tier1':
                # 已有tier 1，生成tier 2的差额（8% = 50% - 20% - 20%）
                # 实际应该是：tier2百分比 - tier1百分比
                tier2_pct = Decimal(str(payout_percentages['tier2']))
                tier1_pct = Decimal(str(payout_percentages['tier1']))
                payout_percentage = tier2_pct - tier1_pct
            elif existing_tier == 'tier2':
                # 已有tier 2，不重复生成
                return None
            else:
                # 没有tier 1，先需要生成tier 1（这种情况理论上不应该发生）
                return None
        
        elif tier == 'tier3':
            if existing_tier == 'tier2':
                # 已有tier 2，生成tier 3的差额
                tier3_pct = Decimal(str(payout_percentages['tier3']))
                tier2_pct = Decimal(str(payout_percentages['tier2']))
                payout_percentage = tier3_pct - tier2_pct
            elif existing_tier == 'tier3':
                # 已有tier 3，不重复生成
                return None
            else:
                # 需要先有tier 2
                return None
        
        else:
            return None
        
        # 计算理赔金额
        coverage_amount = Decimal(str(policy.coverage_amount))
        payout_amount = coverage_amount * payout_percentage / Decimal('100')
        
        # 生成理赔单
        claim = Claim(
            policy_id=policy.id,
            tier_level=tier,
            payout_percentage=payout_percentage,
            payout_amount=payout_amount,
            trigger_timestamp=risk_event.timestamp,
            risk_event_id=risk_event.id
        )
        
        return claim
    
    def _get_highest_existing_tier(
        self,
        existing_claims: List[Claim],
        timestamp: datetime
    ) -> str | None:
        """获取指定时间点已有的最高tier理赔单"""
        # 简化实现：查找同一时间点（同一天/同一小时）的理赔单
        # 实际可能需要更精确的时间匹配逻辑
        tier_order = {'tier1': 1, 'tier2': 2, 'tier3': 3}
        max_tier = None
        max_tier_value = 0
        
        for claim in existing_claims:
            if self._is_same_time_period(claim.trigger_timestamp, timestamp):
                tier_value = tier_order.get(claim.tier_level, 0)
                if tier_value > max_tier_value:
                    max_tier_value = tier_value
                    max_tier = claim.tier_level
        
        return max_tier
```

#### 3.2.2 Celery定时任务 (claim_calculation.py)

```python
"""
理赔计算定时任务
每天23:00执行，计算所有保单的理赔
"""

from celery import Celery
from datetime import datetime, timezone
from sqlalchemy.orm import Session

from app.database import get_db
from app.compute.claim_calculator import ClaimCalculator
from app.compute.risk_calculator import RiskCalculator
from app.services.policy_service import PolicyService

celery_app = Celery('claim_calculation')


@celery_app.task(name='calculate_claims_daily')
def calculate_claims_daily():
    """
    每天23:00执行理赔计算任务
    
    流程：
    1. 获取所有保障中的保单和历史保单（在保障期内）
    2. 对每个保单：
       a. 获取该保单的风险事件（基于产品规则和天气数据）
       b. 计算理赔单
       c. 保存理赔单
    """
    db = next(get_db())
    
    try:
        policy_service = PolicyService(db)
        risk_calculator = RiskCalculator(db)
        claim_calculator = ClaimCalculator(db)
        
        # 获取所有需要计算的保单（保障中或历史保单）
        now = datetime.now(timezone.utc)
        policies = policy_service.get_policies_in_coverage(now)
        
        total_claims = 0
        
        for policy in policies:
            # 获取该保单的风险事件
            risk_events = risk_calculator.calculate_risk_events_for_policy(
                policy_id=policy.id,
                coverage_start=policy.coverage_start,
                coverage_end=policy.coverage_end
            )
            
            # 计算理赔单
            new_claims = claim_calculator.calculate_claims_for_policy(
                policy_id=policy.id,
                risk_events=risk_events
            )
            
            # 保存理赔单
            for claim in new_claims:
                db.add(claim)
                total_claims += 1
        
        db.commit()
        
        return {
            'status': 'success',
            'policies_processed': len(policies),
            'claims_generated': total_claims,
            'executed_at': datetime.now(timezone.utc).isoformat()
        }
    
    except Exception as e:
        db.rollback()
        raise e
    finally:
        db.close()


# Celery Beat配置（在celery_config.py中）
CELERY_BEAT_SCHEDULE = {
    'calculate-claims-daily': {
        'task': 'calculate_claims_daily',
        'schedule': crontab(hour=23, minute=0),  # 每天23:00
    },
}
```

### 3.3 API设计

#### 3.3.1 RESTful API规范

```
基础URL: /api/v1

保单管理:
  GET    /policies              # 获取保单列表（支持筛选）
  GET    /policies/{id}         # 获取保单详情
  POST   /policies              # 创建保单（MVP用mock data）
  PUT    /policies/{id}         # 更新保单
  DELETE /policies/{id}         # 删除保单

理赔管理:
  GET    /claims                # 获取理赔单列表（支持筛选）
  GET    /claims/{id}           # 获取理赔单详情
  GET    /policies/{id}/claims  # 获取保单的理赔单列表

统计查询:
  GET    /statistics/policies   # 保单统计（数量、保额）
  GET    /statistics/claims     # 理赔统计（数量、理赔额）
  GET    /statistics/trends     # 趋势统计（时间序列）

天气数据:
  GET    /weather/historical    # 获取历史天气数据
  POST   /weather/historical    # 导入历史天气数据（MVP用mock）

风险事件:
  GET    /risk-events           # 获取风险事件列表
  GET    /risk-events/calculate # 实时计算风险事件

AI Agent:
  POST   /agents/chat           # AI对话接口
  POST   /agents/query          # 查询Agent接口
  POST   /agents/predict        # 预测Agent接口
```

#### 3.3.2 API响应示例

```python
# GET /api/v1/statistics/policies
{
  "summary": {
    "total_count": 1000,
    "total_coverage_amount": 5000000.00,
    "by_product": {
      "daily": {"count": 300, "coverage_amount": 1500000.00},
      "weekly": {"count": 400, "coverage_amount": 2000000.00},
      "drought": {"count": 300, "coverage_amount": 1500000.00}
    },
    "by_region": {
      "IDN-Jakarta": {"count": 200, "coverage_amount": 1000000.00},
      "MYS-Kuala Lumpur": {"count": 150, "coverage_amount": 750000.00}
    }
  },
  "filters": {
    "product_id": "daily",
    "region": {"country": "IDN", "province": "Jakarta"},
    "time_range": {"from": "2025-01-01T00:00:00Z", "to": "2025-01-31T23:59:59Z"}
  }
}

# GET /api/v1/statistics/claims
{
  "summary": {
    "total_count": 50,
    "total_payout_amount": 250000.00,
    "trends": [
      {"date": "2025-01-01", "count": 5, "payout_amount": 25000.00},
      {"date": "2025-01-02", "count": 3, "payout_amount": 15000.00}
    ]
  },
  "filters": {
    "product_id": "daily",
    "region": {"country": "IDN", "province": "Jakarta", "district": "Central Jakarta"},
    "time_range": {"from": "2025-01-01T00:00:00Z", "to": "2025-01-31T23:59:59Z"}
  }
}
```

---

## 4. AI Agent架构设计

### 4.1 多Agent架构

```
┌─────────────────────────────────────────────────────────┐
│           表现层 (Presentation Layer)                     │
│         Google Contextual View AI kit                    │
│         (前端集成，用户交互界面)                           │
└─────────────────────────────────────────────────────────┘
                        ↕
┌─────────────────────────────────────────────────────────┐
│          Agent编排层 (Orchestrator)                      │
│         - 路由用户请求到合适的Agent                        │
│         - 协调多个Agent的协作                              │
│         - 管理对话上下文                                   │
└─────────────────────────────────────────────────────────┘
        ↕              ↕              ↕
┌──────────────┐ ┌──────────────┐ ┌──────────────┐
│  对话Agent    │ │  查询Agent    │ │  预测Agent    │
│ (Dialogue)   │ │  (Query)     │ │ (Prediction) │
│              │ │              │ │              │
│ - 产品说明   │ │ - 保单查询   │ │ - 风险预测   │
│ - 理赔解释   │ │ - 理赔查询   │ │ - 理赔预测   │
│ - 使用指导   │ │ - 统计查询   │ │ - 趋势预测   │
└──────────────┘ └──────────────┘ └──────────────┘
        ↕              ↕              ↕
┌─────────────────────────────────────────────────────────┐
│             工具层 (Tools Layer)                         │
│  - policy_tools: 保单查询工具                            │
│  - claim_tools: 理赔查询工具                              │
│  - statistics_tools: 统计查询工具                        │
│  - risk_calculation_tools: 风险计算工具                   │
└─────────────────────────────────────────────────────────┘
        ↕
┌─────────────────────────────────────────────────────────┐
│             数据层 (Data Layer)                           │
│         PostgreSQL + Redis (缓存)                         │
└─────────────────────────────────────────────────────────┘
```

### 4.2 Agent实现（使用Google ADK）

```python
"""
AI Agent实现（使用Google ADK）
"""

from google.adk import Agent, Tool
from typing import List, Dict, Any
from app.agents.tools import (
    PolicyQueryTool,
    ClaimQueryTool,
    StatisticsQueryTool,
    RiskCalculationTool
)


class DialogueAgent(Agent):
    """对话Agent - 处理产品说明、理赔解释、使用指导"""
    
    def __init__(self):
        super().__init__(
            name="dialogue_agent",
            description="Handles product explanations, claim explanations, and usage guidance",
            tools=[
                PolicyQueryTool(),
                ClaimQueryTool(),
                StatisticsQueryTool()
            ]
        )
    
    def process(self, user_input: str, context: Dict[str, Any]) -> str:
        """处理用户输入，返回回复"""
        # 使用Google ADK的对话能力
        response = self.generate_response(
            user_input=user_input,
            context=context,
            tools=self.tools
        )
        return response


class QueryAgent(Agent):
    """查询Agent - 处理保单查询、理赔查询、统计查询"""
    
    def __init__(self):
        super().__init__(
            name="query_agent",
            description="Handles policy queries, claim queries, and statistics queries",
            tools=[
                PolicyQueryTool(),
                ClaimQueryTool(),
                StatisticsQueryTool()
            ]
        )
    
    def process(self, user_input: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """处理查询请求，返回结构化数据"""
        # 解析用户查询意图
        intent = self.parse_intent(user_input)
        
        # 调用相应的工具
        if intent == "policy_query":
            tool = PolicyQueryTool()
            result = tool.execute(user_input, context)
        elif intent == "claim_query":
            tool = ClaimQueryTool()
            result = tool.execute(user_input, context)
        elif intent == "statistics_query":
            tool = StatisticsQueryTool()
            result = tool.execute(user_input, context)
        else:
            result = {"error": "Unknown query type"}
        
        return result


class PredictionAgent(Agent):
    """预测Agent - 处理风险和理赔预测"""
    
    def __init__(self):
        super().__init__(
            name="prediction_agent",
            description="Handles risk prediction and claim prediction",
            tools=[
                RiskCalculationTool(),
                StatisticsQueryTool()
            ]
        )
    
    def process(self, user_input: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """处理预测请求，返回预测结果"""
        # 解析预测参数（区域、时间范围、产品等）
        params = self.parse_prediction_params(user_input)
        
        # 使用预测天气数据计算潜在风险
        risk_calculator = RiskCalculationTool()
        prediction = risk_calculator.calculate_prediction(
            region=params['region'],
            product_id=params['product_id'],
            time_range=params['time_range']
        )
        
        return prediction


class AgentOrchestrator:
    """Agent编排器 - 路由请求到合适的Agent"""
    
    def __init__(self):
        self.dialogue_agent = DialogueAgent()
        self.query_agent = QueryAgent()
        self.prediction_agent = PredictionAgent()
    
    def route(self, user_input: str, context: Dict[str, Any]) -> Any:
        """路由用户请求到合适的Agent"""
        # 简单的意图识别（实际可以使用更复杂的NLP模型）
        intent = self._classify_intent(user_input)
        
        if intent == "dialogue":
            return self.dialogue_agent.process(user_input, context)
        elif intent == "query":
            return self.query_agent.process(user_input, context)
        elif intent == "prediction":
            return self.prediction_agent.process(user_input, context)
        else:
            # 默认使用对话Agent
            return self.dialogue_agent.process(user_input, context)
    
    def _classify_intent(self, user_input: str) -> str:
        """简单的意图分类"""
        query_keywords = ["查询", "查询", "统计", "show", "get", "list"]
        prediction_keywords = ["预测", "预测", "forecast", "predict", "future"]
        
        user_input_lower = user_input.lower()
        
        if any(kw in user_input_lower for kw in query_keywords):
            return "query"
        elif any(kw in user_input_lower for kw in prediction_keywords):
            return "prediction"
        else:
            return "dialogue"
```

### 4.3 Agent工具实现

```python
"""
Agent工具实现
"""

from typing import Dict, Any, List
from app.services.policy_service import PolicyService
from app.services.claim_service import ClaimService
from app.services.statistics_service import StatisticsService
from app.compute.risk_calculator import RiskCalculator


class PolicyQueryTool:
    """保单查询工具"""
    
    def execute(self, query: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """执行保单查询"""
        # 解析查询参数
        params = self._parse_query(query, context)
        
        # 调用保单服务
        policy_service = PolicyService()
        policies = policy_service.query_policies(**params)
        
        return {
            "type": "policy_query",
            "count": len(policies),
            "data": policies
        }
    
    def _parse_query(self, query: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """解析查询参数"""
        # 使用NLP或规则解析用户查询
        # 返回查询参数：region, product_id, time_range等
        pass


class ClaimQueryTool:
    """理赔查询工具"""
    
    def execute(self, query: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """执行理赔查询"""
        params = self._parse_query(query, context)
        
        claim_service = ClaimService()
        claims = claim_service.query_claims(**params)
        
        return {
            "type": "claim_query",
            "count": len(claims),
            "data": claims
        }


class StatisticsQueryTool:
    """统计查询工具"""
    
    def execute(self, query: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """执行统计查询"""
        params = self._parse_query(query, context)
        
        statistics_service = StatisticsService()
        stats = statistics_service.get_statistics(**params)
        
        return stats


class RiskCalculationTool:
    """风险计算工具（用于预测）"""
    
    def calculate_prediction(
        self,
        region: Dict[str, str],
        product_id: str,
        time_range: Dict[str, str]
    ) -> Dict[str, Any]:
        """使用预测天气数据计算潜在风险"""
        risk_calculator = RiskCalculator()
        prediction = risk_calculator.calculate_prediction(
            region=region,
            product_id=product_id,
            time_range=time_range
        )
        
        return prediction
```

---

## 5. 前端架构升级

### 5.1 新增组件和功能

```
Next-gen-index/src/
├── components/
│   ├── home/
│   │   ├── PolicyStatistics.tsx      # 保单统计组件（新增）
│   │   ├── ClaimStatistics.tsx       # 理赔统计组件（新增）
│   │   └── WeatherParticleLayer.tsx   # 天气粒子效果图层（新增）
│   │
│   └── policy/                       # 保单管理组件（新增）
│       ├── PolicyList.tsx
│       ├── PolicyDetail.tsx
│       └── PolicyImport.tsx
│
├── hooks/
│   ├── usePolicyStatistics.ts        # 保单统计Hook（新增）
│   ├── useClaimStatistics.ts         # 理赔统计Hook（新增）
│   ├── usePolicies.ts                # 保单数据Hook（新增）
│   ├── useClaims.ts                  # 理赔数据Hook（新增）
│   └── useWeatherParticles.ts         # 天气粒子效果Hook（新增）
│
├── lib/
│   ├── api/                          # API客户端（新增）
│   │   ├── policies.ts
│   │   ├── claims.ts
│   │   ├── statistics.ts
│   │   └── weather.ts
│   │
│   └── particles/                    # 粒子效果库（新增）
│       ├── rainParticles.ts          # 降雨粒子效果
│       ├── windParticles.ts          # 风速粒子效果
│       └── typhoonParticles.ts        # 台风粒子效果
│
└── types/
    ├── policy.ts                     # 保单类型（新增）
    └── claim.ts                      # 理赔类型（新增）
```

### 5.2 粒子效果实现（参考Windy.com）

```typescript
/**
 * 天气粒子效果实现
 * 参考Windy.com的粒子效果
 */

import * as THREE from 'three';
import { GoogleMap } from '@react-google-maps/api';

interface ParticleSystemConfig {
  particleCount: number;
  particleSize: number;
  color: string;
  opacity: number;
  speed: number;
  direction: number; // 风向角度
}

export class WeatherParticleSystem {
  private scene: THREE.Scene;
  private camera: THREE.Camera;
  private renderer: THREE.WebGLRenderer;
  private particles: THREE.Points;
  private map: google.maps.Map;
  
  constructor(map: google.maps.Map, config: ParticleSystemConfig) {
    this.map = map;
    this.initThreeJS(config);
  }
  
  private initThreeJS(config: ParticleSystemConfig) {
    // 初始化Three.js场景
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    // 创建WebGL渲染器
    this.renderer = new THREE.WebGLRenderer({ alpha: true });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    
    // 创建粒子系统
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(config.particleCount * 3);
    const colors = new Float32Array(config.particleCount * 3);
    
    // 初始化粒子位置和颜色
    for (let i = 0; i < config.particleCount; i++) {
      const i3 = i * 3;
      positions[i3] = (Math.random() - 0.5) * 1000;
      positions[i3 + 1] = (Math.random() - 0.5) * 1000;
      positions[i3 + 2] = (Math.random() - 0.5) * 1000;
      
      // 颜色基于配置
      const color = new THREE.Color(config.color);
      colors[i3] = color.r;
      colors[i3 + 1] = color.g;
      colors[i3 + 2] = color.b;
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const material = new THREE.PointsMaterial({
      size: config.particleSize,
      vertexColors: true,
      opacity: config.opacity,
      transparent: true
    });
    
    this.particles = new THREE.Points(geometry, material);
    this.scene.add(this.particles);
  }
  
  public update(deltaTime: number, windData: WindData) {
    // 更新粒子位置（基于风速和风向）
    const positions = this.particles.geometry.attributes.position.array as Float32Array;
    
    for (let i = 0; i < positions.length; i += 3) {
      // 根据风向和风速更新粒子位置
      const angle = windData.direction;
      const speed = windData.speed * deltaTime;
      
      positions[i] += Math.cos(angle) * speed;
      positions[i + 1] += Math.sin(angle) * speed;
      
      // 边界处理（循环）
      if (positions[i] > 500) positions[i] = -500;
      if (positions[i] < -500) positions[i] = 500;
      if (positions[i + 1] > 500) positions[i + 1] = -500;
      if (positions[i + 1] < -500) positions[i + 1] = 500;
    }
    
    this.particles.geometry.attributes.position.needsUpdate = true;
  }
  
  public render() {
    this.renderer.render(this.scene, this.camera);
  }
}
```

### 5.3 API客户端实现

```typescript
/**
 * API客户端实现
 */

import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000/api/v1';

// 保单API
export const policyAPI = {
  getPolicies: async (filters?: PolicyFilters) => {
    const response = await axios.get(`${API_BASE_URL}/policies`, { params: filters });
    return response.data;
  },
  
  getPolicy: async (id: string) => {
    const response = await axios.get(`${API_BASE_URL}/policies/${id}`);
    return response.data;
  },
  
  createPolicy: async (policy: CreatePolicyRequest) => {
    const response = await axios.post(`${API_BASE_URL}/policies`, policy);
    return response.data;
  }
};

// 理赔API
export const claimAPI = {
  getClaims: async (filters?: ClaimFilters) => {
    const response = await axios.get(`${API_BASE_URL}/claims`, { params: filters });
    return response.data;
  },
  
  getPolicyClaims: async (policyId: string) => {
    const response = await axios.get(`${API_BASE_URL}/policies/${policyId}/claims`);
    return response.data;
  }
};

// 统计API
export const statisticsAPI = {
  getPolicyStatistics: async (filters: StatisticsFilters) => {
    const response = await axios.get(`${API_BASE_URL}/statistics/policies`, { params: filters });
    return response.data;
  },
  
  getClaimStatistics: async (filters: StatisticsFilters) => {
    const response = await axios.get(`${API_BASE_URL}/statistics/claims`, { params: filters });
    return response.data;
  },
  
  getTrends: async (filters: StatisticsFilters) => {
    const response = await axios.get(`${API_BASE_URL}/statistics/trends`, { params: filters });
    return response.data;
  }
};
```

---

## 6. 部署架构

### 6.1 Docker容器化

```yaml
# docker-compose.yml
version: '3.8'

services:
  # PostgreSQL数据库
  postgres:
    image: postgis/postgis:15-3.3
    environment:
      POSTGRES_DB: index_insurance
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
  
  # Redis缓存
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
  
  # 后端API服务
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    environment:
      DATABASE_URL: postgresql://postgres:postgres@postgres:5432/index_insurance
      REDIS_URL: redis://redis:6379
      GOOGLE_MAPS_API_KEY: ${GOOGLE_MAPS_API_KEY}
    ports:
      - "8000:8000"
    depends_on:
      - postgres
      - redis
  
  # Celery Worker（理赔计算）
  celery_worker:
    build:
      context: ./backend
      dockerfile: Dockerfile
    command: celery -A app.tasks.celery_app worker --loglevel=info
    environment:
      DATABASE_URL: postgresql://postgres:postgres@postgres:5432/index_insurance
      REDIS_URL: redis://redis:6379
    depends_on:
      - postgres
      - redis
      - backend
  
  # Celery Beat（定时任务调度）
  celery_beat:
    build:
      context: ./backend
      dockerfile: Dockerfile
    command: celery -A app.tasks.celery_app beat --loglevel=info
    environment:
      DATABASE_URL: postgresql://postgres:postgres@postgres:5432/index_insurance
      REDIS_URL: redis://redis:6379
    depends_on:
      - postgres
      - redis
      - backend
  
  # 前端服务
  frontend:
    build:
      context: ./Next-gen-index
      dockerfile: Dockerfile
    ports:
      - "5173:5173"
    environment:
      VITE_API_BASE_URL: http://localhost:8000/api/v1
      VITE_GOOGLE_MAPS_API_KEY: ${GOOGLE_MAPS_API_KEY}
    depends_on:
      - backend

volumes:
  postgres_data:
  redis_data:
```

### 6.2 环境变量配置

```bash
# .env.example
# 数据库配置
DATABASE_URL=postgresql://postgres:postgres@localhost:5432/index_insurance

# Redis配置
REDIS_URL=redis://localhost:6379

# Google Maps API
GOOGLE_MAPS_API_KEY=your_api_key_here

# Celery配置
CELERY_BROKER_URL=redis://localhost:6379/0
CELERY_RESULT_BACKEND=redis://localhost:6379/0

# 前端API地址
VITE_API_BASE_URL=http://localhost:8000/api/v1
```

---

## 7. 实施计划

### 7.1 阶段一：后端基础架构（2-3周）
1. 搭建FastAPI项目结构
2. 配置PostgreSQL + PostGIS数据库
3. 实现数据模型和迁移
4. 实现基础API（保单、理赔、统计）

### 7.2 阶段二：理赔计算引擎（2-3周）
1. 实现风险计算引擎（复用前端逻辑）
2. 实现理赔计算引擎（tier差额逻辑）
3. 实现Celery定时任务
4. 测试理赔计算准确性

### 7.3 阶段三：前端集成（2-3周）
1. 实现API客户端
2. 实现保单统计和理赔统计组件
3. 集成到现有Dashboard
4. 实现数据面板联动

### 7.4 阶段四：AI Agent集成（2-3周）
1. 搭建Google ADK Agent架构
2. 实现Agent工具集
3. 实现Agent编排器
4. 集成到ContextualAssistant组件

### 7.5 阶段五：动画效果和天气扩展（2-3周）
1. 实现粒子效果系统（降雨、风速）
2. 支持风速数据可视化
3. 实现台风气旋和轨迹（未来扩展）
4. 性能优化

### 7.6 阶段六：测试和优化（1-2周）
1. 端到端测试
2. 性能优化
3. 文档完善
4. 部署准备

---

## 8. 技术风险和注意事项

### 8.1 金融计算精度
- **风险**：使用float可能导致精度误差
- **解决方案**：使用Python `decimal.Decimal` 和 PostgreSQL `DECIMAL` 类型

### 8.2 定时任务可靠性
- **风险**：Celery任务可能失败或重复执行
- **解决方案**：
  - 实现任务幂等性
  - 添加任务重试机制
  - 监控任务执行状态

### 8.3 数据一致性
- **风险**：理赔计算依赖风险事件，需要保证数据一致性
- **解决方案**：
  - 使用数据库事务
  - 实现数据版本控制
  - 添加数据校验

### 8.4 性能优化
- **风险**：大量保单和理赔数据可能导致查询慢
- **解决方案**：
  - 添加数据库索引
  - 使用Redis缓存
  - 实现数据分页
  - 考虑数据分区（按时间）

### 8.5 AI Agent稳定性
- **风险**：Agent可能返回错误结果
- **解决方案**：
  - 实现结果验证
  - 添加错误处理
  - 提供fallback机制

---

## 9. 后续扩展方向

1. **用户认证系统**：支持多租户、角色权限管理
2. **实时通知**：理赔生成后通知投保人（邮件、短信）
3. **数据导入导出**：支持CSV/Excel批量导入保单
4. **报表系统**：生成保单和理赔报表
5. **移动端应用**：React Native应用
6. **更多天气类型**：温度、湿度、气压等
7. **台风预测**：集成台风轨迹预测API
8. **机器学习**：使用ML模型优化风险预测

---

**文档版本**：v1.0  
**创建日期**：2025-01-27  
**最后更新**：2025-01-27
